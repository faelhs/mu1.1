; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\gObjMonster.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttKALIMAGATE_LEVEL DD 028H
	DD	082H
	DD	014H
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	015dH
	DD	0137H
	DD	015dH
	DD	015eH
	DD	0190H
	DD	015eH
	DD	0190H
_g_iKalimaGateGateIndex DD 058H
	DD	059H
	DD	05aH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	074H
	ORG $+4
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
_DATA	ENDS
PUBLIC	?gObjMonsterMoveRegen@@YAXHHPAUOBJECTSTRUCT@@@Z	; gObjMonsterMoveRegen
EXTRN	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z:PROC ; CMonsterSetBase::GetBoxPosition
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\gobjmonster.cpp
;	COMDAT ?gObjMonsterMoveRegen@@YAXHHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_lpObj$ = 16						; size = 4
?gObjMonsterMoveRegen@@YAXHHPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterMoveRegen, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   : 	gMSetBase.GetBoxPosition(lpObj->MapNumber, x-1, y-1, x+1, y+1, lpObj->X, lpObj->Y);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	57		 push	 edi
  0000c	8d be 06 01 00
	00		 lea	 edi, DWORD PTR [esi+262]
  00012	57		 push	 edi
  00013	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00016	8d 9e 04 01 00
	00		 lea	 ebx, DWORD PTR [esi+260]
  0001c	53		 push	 ebx
  0001d	51		 push	 ecx
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00021	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  00024	52		 push	 edx
  00025	48		 dec	 eax
  00026	50		 push	 eax
  00027	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0002e	49		 dec	 ecx
  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00036	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition

; 30   : 
; 31   : 	lpObj->TX = lpObj->X;
; 32   : 	lpObj->TY = lpObj->Y;

  0003b	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  0003e	0f b7 03	 movzx	 eax, WORD PTR [ebx]

; 33   : 	lpObj->MTX = lpObj->X;
; 34   : 	lpObj->MTY = lpObj->Y;
; 35   : 	lpObj->StartX = lpObj->X;
; 36   : 	lpObj->StartY = lpObj->Y;

  00041	8a 17		 mov	 dl, BYTE PTR [edi]
  00043	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  0004a	66 89 8e 26 01
	00 00		 mov	 WORD PTR [esi+294], cx
  00051	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00053	5f		 pop	 edi
  00054	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  0005b	66 89 86 24 01
	00 00		 mov	 WORD PTR [esi+292], ax
  00062	88 8e 1a 01 00
	00		 mov	 BYTE PTR [esi+282], cl
  00068	88 96 1b 01 00
	00		 mov	 BYTE PTR [esi+283], dl
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx

; 37   : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?gObjMonsterMoveRegen@@YAXHHPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterMoveRegen
_TEXT	ENDS
PUBLIC	?gObjMonsterViewportIsCharacter@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterViewportIsCharacter
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterViewportIsCharacter@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjMonsterViewportIsCharacter@@YAHPAUOBJECTSTRUCT@@@Z PROC ; gObjMonsterViewportIsCharacter, COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  : 	int tObjNum;
; 148  : 
; 149  : 	for ( int n = 0; n<MAX_VIEWPORT_MONSTER ; n++ )

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	8d 8a 16 07 00
	00		 lea	 ecx, DWORD PTR [edx+1814]
  0000e	56		 push	 esi
  0000f	90		 npad	 1
$LL5@gObjMonste:

; 150  : 	{
; 151  : 		if ( lpObj->VpPlayer2[n].state  != 0 )

  00010	80 79 fe 00	 cmp	 BYTE PTR [ecx-2], 0
  00014	74 0c		 je	 SHORT $LN4@gObjMonste

; 152  : 		{
; 153  : 			tObjNum = lpObj->VpPlayer2[n].number;
; 154  : 
; 155  : 			if ( tObjNum == lpObj->TargetNumber ) 

  00016	66 8b 31	 mov	 si, WORD PTR [ecx]
  00019	66 3b b2 d4 02
	00 00		 cmp	 si, WORD PTR [edx+724]
  00020	74 0c		 je	 SHORT $LN6@gObjMonste
$LN4@gObjMonste:

; 147  : 	int tObjNum;
; 148  : 
; 149  : 	for ( int n = 0; n<MAX_VIEWPORT_MONSTER ; n++ )

  00022	40		 inc	 eax
  00023	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00026	83 f8 14	 cmp	 eax, 20			; 00000014H
  00029	7c e5		 jl	 SHORT $LL5@gObjMonste

; 156  : 			{
; 157  : 				return n;
; 158  : 			}
; 159  : 		}
; 160  : 	}
; 161  : 
; 162  : 	return -1;

  0002b	83 c8 ff	 or	 eax, -1
$LN6@gObjMonste:
  0002e	5e		 pop	 esi

; 163  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?gObjMonsterViewportIsCharacter@@YAHPAUOBJECTSTRUCT@@@Z ENDP ; gObjMonsterViewportIsCharacter
_TEXT	ENDS
PUBLIC	?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterHitDamageInit, COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 167  : 	for ( int i = 0; i< MAX_ST_HIT_DAMAGE ; i++ )

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00006	8d 82 a0 0a 00
	00		 lea	 eax, DWORD PTR [edx+2720]
  0000c	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00011	56		 push	 esi
$LL3@gObjMonste@2:

; 168  : 	{
; 169  : 		lpObj->sHD[i].number  = -1;

  00012	83 ce ff	 or	 esi, -1
  00015	66 89 30	 mov	 WORD PTR [eax], si
  00018	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001b	49		 dec	 ecx
  0001c	75 f4		 jne	 SHORT $LL3@gObjMonste@2

; 170  : 	}
; 171  : 
; 172  : 	lpObj->sHDCount = 0;

  0001e	33 c0		 xor	 eax, eax
  00020	66 89 82 80 0c
	00 00		 mov	 WORD PTR [edx+3200], ax
  00027	5e		 pop	 esi

; 173  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterHitDamageInit
_TEXT	ENDS
PUBLIC	?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
EXTRN	?gObjCheckTileArea@@YAHHHHH@Z:PROC		; gObjCheckTileArea
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_delindex$ = -8						; size = 4
_delok$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z PROC ; gObjMonsterHitDamageUserDel, COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 177  : 	int delok = 0;
; 178  : 	int delindex = -1;

  00009	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _delindex$[ebp], -1

; 179  : 
; 180  : 	for ( int n = 0;n<MAX_ST_HIT_DAMAGE ; n++ )

  00013	33 db		 xor	 ebx, ebx
  00015	8d b7 a0 0a 00
	00		 lea	 esi, DWORD PTR [edi+2720]
  0001b	eb 03 8d 49 00	 npad	 5
$LL20@gObjMonste@3:

; 181  : 	{
; 182  : 		if ( lpObj->sHD[n].number >= 0 )

  00020	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00023	66 85 c0	 test	 ax, ax
  00026	78 7b		 js	 SHORT $LN10@gObjMonste@3

; 183  : 		{
; 184  : 			delok = FALSE;
; 185  : 
; 186  : 			if ( gObjIsConnected(lpObj->sHD[n].number ) == TRUE )

  00028	98		 cwde
  00029	50		 push	 eax
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 0
  00031	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00036	83 c4 04	 add	 esp, 4
  00039	83 f8 01	 cmp	 eax, 1
  0003c	75 55		 jne	 SHORT $LN17@gObjMonste@3

; 187  : 			{
; 188  : 				if ( (GetTickCount()- lpObj->sHD[n].LastHitTime) > 20000 )

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00044	2b 46 08	 sub	 eax, DWORD PTR [esi+8]
  00047	3d 20 4e 00 00	 cmp	 eax, 20000		; 00004e20H
  0004c	76 07		 jbe	 SHORT $LN6@gObjMonste@3

; 189  : 				{
; 190  : 					delok = TRUE;

  0004e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _delok$[ebp], 1
$LN6@gObjMonste@3:

; 191  : 				}
; 192  : 
; 193  : 				if ( gObj[lpObj->sHD[n].number].MapNumber != lpObj->MapNumber)

  00055	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00058	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005e	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00064	3a 8f 09 01 00
	00		 cmp	 cl, BYTE PTR [edi+265]

; 194  : 				{
; 195  : 					delok = TRUE;

  0006a	75 27		 jne	 SHORT $LN17@gObjMonste@3

; 196  : 				}
; 197  : 				else if ( gObjCheckTileArea(lpObj->m_Index, gObj[lpObj->sHD[n].number].X , gObj[lpObj->sHD[n].number].Y , 20) == FALSE )

  0006c	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00073	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0007a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0007c	6a 14		 push	 20			; 00000014H
  0007e	52		 push	 edx
  0007f	50		 push	 eax
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?gObjCheckTileArea@@YAHHHHH@Z ; gObjCheckTileArea
  00086	83 c4 10	 add	 esp, 16			; 00000010H
  00089	85 c0		 test	 eax, eax

; 198  : 				{
; 199  : 					delok = TRUE;
; 200  : 				}
; 201  : 			}
; 202  : 			else

  0008b	74 06		 je	 SHORT $LN17@gObjMonste@3

; 203  : 			{
; 204  : 				delok = TRUE;
; 205  : 			}
; 206  : 
; 207  : 
; 208  : 			if ( delok == TRUE )

  0008d	83 7d fc 01	 cmp	 DWORD PTR _delok$[ebp], 1
  00091	75 10		 jne	 SHORT $LN10@gObjMonste@3
$LN17@gObjMonste@3:

; 209  : 			{
; 210  : 				lpObj->sHD[n].number = -1;

  00093	83 ca ff	 or	 edx, -1
  00096	66 89 16	 mov	 WORD PTR [esi], dx

; 211  : 				delindex = n;
; 212  : 				lpObj->sHDCount--;

  00099	66 ff 8f 80 0c
	00 00		 dec	 WORD PTR [edi+3200]
  000a0	89 5d f8	 mov	 DWORD PTR _delindex$[ebp], ebx
$LN10@gObjMonste@3:

; 179  : 
; 180  : 	for ( int n = 0;n<MAX_ST_HIT_DAMAGE ; n++ )

  000a3	43		 inc	 ebx
  000a4	83 c6 0c	 add	 esi, 12			; 0000000cH
  000a7	83 fb 28	 cmp	 ebx, 40			; 00000028H
  000aa	0f 8c 70 ff ff
	ff		 jl	 $LL20@gObjMonste@3

; 213  : 			}
; 214  : 
; 215  : 
; 216  : 		}
; 217  : 	}
; 218  : 
; 219  : 	return delindex;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _delindex$[ebp]
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx

; 220  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z ENDP ; gObjMonsterHitDamageUserDel
_TEXT	ENDS
PUBLIC	??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error?$AA@ ; `string'
PUBLIC	?gObjMonsterSetHitDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ; gObjMonsterSetHitDamage
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error?$AA@
CONST	SEGMENT
??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error?$AA@ DB 'error-'
	DB	'L2 : Hit Damage Set error', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterSetHitDamage@@YAXPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_hit_player$ = 12					; size = 4
_hit_damage$ = 16					; size = 4
?gObjMonsterSetHitDamage@@YAXPAUOBJECTSTRUCT@@HH@Z PROC	; gObjMonsterSetHitDamage, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 225  : 	int blank = -1;

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _hit_player$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000c	83 c8 ff	 or	 eax, -1

; 226  : 
; 227  : 	for (int n=0;n<MAX_ST_HIT_DAMAGE;n++)

  0000f	33 f6		 xor	 esi, esi
  00011	8d 97 a0 0a 00
	00		 lea	 edx, DWORD PTR [edi+2720]
$LL12@gObjMonste@4:

; 228  : 	{
; 229  : 		if ( lpObj->sHD[n].number >= 0 )

  00017	0f b7 0a	 movzx	 ecx, WORD PTR [edx]
  0001a	66 85 c9	 test	 cx, cx
  0001d	78 4e		 js	 SHORT $LN9@gObjMonste@4

; 230  : 		{
; 231  : 			if ( lpObj->sHD[n].number == hit_player )

  0001f	0f bf c9	 movsx	 ecx, cx
  00022	3b cb		 cmp	 ecx, ebx
  00024	75 4d		 jne	 SHORT $LN11@gObjMonste@4

; 232  : 			{
; 233  : 				lpObj->sHD[n].HitDamage += hit_damage;

  00026	8b 45 10	 mov	 eax, DWORD PTR _hit_damage$[ebp]
  00029	8d 94 76 a9 02
	00 00		 lea	 edx, DWORD PTR [esi+esi*2+681]
  00030	01 04 97	 add	 DWORD PTR [edi+edx*4], eax
  00033	8d 1c 97	 lea	 ebx, DWORD PTR [edi+edx*4]

; 234  : 				lpObj->sHD[n].LastHitTime = GetTickCount();

  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 235  : 
; 236  : 				if ( lpObj->sHD[n].HitDamage > lpObj->MaxLife )

  0003c	db 03		 fild	 DWORD PTR [ebx]
  0003e	8d 0c 76	 lea	 ecx, DWORD PTR [esi+esi*2]
  00041	89 84 8f a8 0a
	00 00		 mov	 DWORD PTR [edi+ecx*4+2728], eax
  00048	d9 87 c0 00 00
	00		 fld	 DWORD PTR [edi+192]
  0004e	de d9		 fcompp
  00050	df e0		 fnstsw	 ax
  00052	f6 c4 05	 test	 ah, 5
  00055	0f 8a 94 00 00
	00		 jp	 $LN1@gObjMonste@4

; 237  : 				{
; 238  : 					lpObj->sHD[n].HitDamage = lpObj->MaxLife;

  0005b	d9 87 c0 00 00
	00		 fld	 DWORD PTR [edi+192]
  00061	e8 00 00 00 00	 call	 __ftol2_sse
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	89 03		 mov	 DWORD PTR [ebx], eax
  0006a	5b		 pop	 ebx

; 271  : 	}
; 272  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN9@gObjMonste@4:

; 239  : 				}
; 240  : 
; 241  : 				return;
; 242  : 			}
; 243  : 		}
; 244  : 		else if ( blank < 0 )

  0006d	85 c0		 test	 eax, eax
  0006f	79 02		 jns	 SHORT $LN11@gObjMonste@4

; 245  : 		{
; 246  : 			blank = n;

  00071	8b c6		 mov	 eax, esi
$LN11@gObjMonste@4:

; 226  : 
; 227  : 	for (int n=0;n<MAX_ST_HIT_DAMAGE;n++)

  00073	46		 inc	 esi
  00074	83 c2 0c	 add	 edx, 12			; 0000000cH
  00077	83 fe 28	 cmp	 esi, 40			; 00000028H
  0007a	7c 9b		 jl	 SHORT $LL12@gObjMonste@4

; 247  : 		}
; 248  : 	}
; 249  : 
; 250  : 	if ( blank < 0 )

  0007c	85 c0		 test	 eax, eax
  0007e	79 0d		 jns	 SHORT $LN18@gObjMonste@4

; 251  : 	{
; 252  : 		blank = gObjMonsterHitDamageUserDel(lpObj);

  00080	57		 push	 edi
  00081	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageUserDel@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
  00086	83 c4 04	 add	 esp, 4

; 253  : 	}
; 254  : 
; 255  : 	if ( blank >= 0 )

  00089	85 c0		 test	 eax, eax
  0008b	78 53		 js	 SHORT $LN3@gObjMonste@4
$LN18@gObjMonste@4:

; 256  : 	{
; 257  : 		lpObj->sHD[blank].number = hit_player;
; 258  : 		lpObj->sHD[blank].HitDamage = hit_damage;

  0008d	8b 4d 10	 mov	 ecx, DWORD PTR _hit_damage$[ebp]

; 259  : 
; 260  : 		if ( lpObj->sHD[blank].HitDamage > lpObj->MaxLife )

  00090	db 45 10	 fild	 DWORD PTR _hit_damage$[ebp]
  00093	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00096	8d 34 97	 lea	 esi, DWORD PTR [edi+edx*4]
  00099	8d 84 40 a9 02
	00 00		 lea	 eax, DWORD PTR [eax+eax*2+681]
  000a0	66 89 9e a0 0a
	00 00		 mov	 WORD PTR [esi+2720], bx
  000a7	8d 1c 87	 lea	 ebx, DWORD PTR [edi+eax*4]
  000aa	89 0b		 mov	 DWORD PTR [ebx], ecx
  000ac	d9 87 c0 00 00
	00		 fld	 DWORD PTR [edi+192]
  000b2	de d9		 fcompp
  000b4	df e0		 fnstsw	 ax
  000b6	f6 c4 05	 test	 ah, 5
  000b9	7a 0d		 jp	 SHORT $LN2@gObjMonste@4

; 261  : 		{
; 262  : 			lpObj->sHD[blank].HitDamage = lpObj->MaxLife;

  000bb	d9 87 c0 00 00
	00		 fld	 DWORD PTR [edi+192]
  000c1	e8 00 00 00 00	 call	 __ftol2_sse
  000c6	89 03		 mov	 DWORD PTR [ebx], eax
$LN2@gObjMonste@4:

; 263  : 		}
; 264  : 	
; 265  : 		lpObj->sHD[blank].LastHitTime = GetTickCount();

  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ce	89 86 a8 0a 00
	00		 mov	 DWORD PTR [esi+2728], eax

; 266  : 		lpObj->sHDCount++;

  000d4	66 ff 87 80 0c
	00 00		 inc	 WORD PTR [edi+3200]
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 271  : 	}
; 272  : }

  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN3@gObjMonste@4:

; 267  : 	}
; 268  : 	else
; 269  : 	{
; 270  : 		LogAdd(LOG_BLACK, "error-L2 : Hit Damage Set error");

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MINPGEPL@error?9L2?5?3?5Hit?5Damage?5Set?5error?$AA@
  000e5	6a 00		 push	 0
  000e7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000ec	83 c4 08	 add	 esp, 8
$LN1@gObjMonste@4:
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx

; 271  : 	}
; 272  : }

  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
?gObjMonsterSetHitDamage@@YAXPAUOBJECTSTRUCT@@HH@Z ENDP	; gObjMonsterSetHitDamage
_TEXT	ENDS
PUBLIC	?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpMonObj$ = 8						; size = 4
?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z PROC ; gObjMonsterTopHitDamageUser, COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 284  : 	int MaxHitDamage = 0;

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpMonObj$[ebp]
  00006	53		 push	 ebx
  00007	33 c9		 xor	 ecx, ecx
  00009	56		 push	 esi

; 285  : 	int MaxHitDamageUser = -1;

  0000a	83 c8 ff	 or	 eax, -1
  0000d	57		 push	 edi
  0000e	81 c2 a0 0a 00
	00		 add	 edx, 2720		; 00000aa0H
  00014	8d 59 08	 lea	 ebx, DWORD PTR [ecx+8]
$LL20@gObjMonste@5:

; 288  : 	{
; 289  : 		if ( lpMonObj->sHD[n].number >= 0 )

  00017	0f b7 3a	 movzx	 edi, WORD PTR [edx]
  0001a	66 85 ff	 test	 di, di
  0001d	78 0c		 js	 SHORT $LN4@gObjMonste@5

; 290  : 		{
; 291  : 			if ( lpMonObj->sHD[n].HitDamage > MaxHitDamage )

  0001f	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00022	3b f1		 cmp	 esi, ecx
  00024	7e 05		 jle	 SHORT $LN4@gObjMonste@5

; 292  : 			{
; 293  : 				MaxHitDamage = lpMonObj->sHD[n].HitDamage;

  00026	8b ce		 mov	 ecx, esi

; 294  : 				MaxHitDamageUser = lpMonObj->sHD[n].number;

  00028	0f bf c7	 movsx	 eax, di
$LN4@gObjMonste@5:

; 288  : 	{
; 289  : 		if ( lpMonObj->sHD[n].number >= 0 )

  0002b	0f b7 7a 0c	 movzx	 edi, WORD PTR [edx+12]
  0002f	66 85 ff	 test	 di, di
  00032	78 0c		 js	 SHORT $LN16@gObjMonste@5

; 290  : 		{
; 291  : 			if ( lpMonObj->sHD[n].HitDamage > MaxHitDamage )

  00034	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00037	3b f1		 cmp	 esi, ecx
  00039	7e 05		 jle	 SHORT $LN16@gObjMonste@5

; 292  : 			{
; 293  : 				MaxHitDamage = lpMonObj->sHD[n].HitDamage;

  0003b	8b ce		 mov	 ecx, esi

; 294  : 				MaxHitDamageUser = lpMonObj->sHD[n].number;

  0003d	0f bf c7	 movsx	 eax, di
$LN16@gObjMonste@5:

; 288  : 	{
; 289  : 		if ( lpMonObj->sHD[n].number >= 0 )

  00040	0f b7 7a 18	 movzx	 edi, WORD PTR [edx+24]
  00044	66 85 ff	 test	 di, di
  00047	78 0c		 js	 SHORT $LN17@gObjMonste@5

; 290  : 		{
; 291  : 			if ( lpMonObj->sHD[n].HitDamage > MaxHitDamage )

  00049	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  0004c	3b f1		 cmp	 esi, ecx
  0004e	7e 05		 jle	 SHORT $LN17@gObjMonste@5

; 292  : 			{
; 293  : 				MaxHitDamage = lpMonObj->sHD[n].HitDamage;

  00050	8b ce		 mov	 ecx, esi

; 294  : 				MaxHitDamageUser = lpMonObj->sHD[n].number;

  00052	0f bf c7	 movsx	 eax, di
$LN17@gObjMonste@5:

; 288  : 	{
; 289  : 		if ( lpMonObj->sHD[n].number >= 0 )

  00055	0f b7 7a 24	 movzx	 edi, WORD PTR [edx+36]
  00059	66 85 ff	 test	 di, di
  0005c	78 0c		 js	 SHORT $LN18@gObjMonste@5

; 290  : 		{
; 291  : 			if ( lpMonObj->sHD[n].HitDamage > MaxHitDamage )

  0005e	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  00061	3b f1		 cmp	 esi, ecx
  00063	7e 05		 jle	 SHORT $LN18@gObjMonste@5

; 292  : 			{
; 293  : 				MaxHitDamage = lpMonObj->sHD[n].HitDamage;

  00065	8b ce		 mov	 ecx, esi

; 294  : 				MaxHitDamageUser = lpMonObj->sHD[n].number;

  00067	0f bf c7	 movsx	 eax, di
$LN18@gObjMonste@5:

; 288  : 	{
; 289  : 		if ( lpMonObj->sHD[n].number >= 0 )

  0006a	0f b7 7a 30	 movzx	 edi, WORD PTR [edx+48]
  0006e	66 85 ff	 test	 di, di
  00071	78 0c		 js	 SHORT $LN19@gObjMonste@5

; 290  : 		{
; 291  : 			if ( lpMonObj->sHD[n].HitDamage > MaxHitDamage )

  00073	8b 72 34	 mov	 esi, DWORD PTR [edx+52]
  00076	3b f1		 cmp	 esi, ecx
  00078	7e 05		 jle	 SHORT $LN19@gObjMonste@5

; 292  : 			{
; 293  : 				MaxHitDamage = lpMonObj->sHD[n].HitDamage;

  0007a	8b ce		 mov	 ecx, esi

; 294  : 				MaxHitDamageUser = lpMonObj->sHD[n].number;

  0007c	0f bf c7	 movsx	 eax, di
$LN19@gObjMonste@5:

; 286  : 
; 287  : 	for ( int n=0;n<MAX_ST_HIT_DAMAGE;n++)

  0007f	83 c2 3c	 add	 edx, 60			; 0000003cH
  00082	4b		 dec	 ebx
  00083	75 92		 jne	 SHORT $LL20@gObjMonste@5
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx

; 295  : 			}
; 296  : 		}
; 297  : 	}
; 298  : 
; 299  : 	return MaxHitDamageUser;
; 300  : }

  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ENDP ; gObjMonsterTopHitDamageUser
_TEXT	ENDS
PUBLIC	?gObjMonsterLastHitDamageUser@@YAHPAUOBJECTSTRUCT@@AAH@Z ; gObjMonsterLastHitDamageUser
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterLastHitDamageUser@@YAHPAUOBJECTSTRUCT@@AAH@Z
_TEXT	SEGMENT
_lpMonObj$ = 8						; size = 4
_hitindex$ = 12						; size = 4
?gObjMonsterLastHitDamageUser@@YAHPAUOBJECTSTRUCT@@AAH@Z PROC ; gObjMonsterLastHitDamageUser, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 313  : 	int LastHitTime = 0;

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpMonObj$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _hitindex$[ebp]

; 314  : 	int LastHitUser = -1;

  0000e	83 c8 ff	 or	 eax, -1
  00011	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  00014	81 c6 a0 0a 00
	00		 add	 esi, 2720		; 00000aa0H
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL5@gObjMonste@6:

; 317  : 	{
; 318  : 		if ( lpMonObj->sHD[n].number >= 0 )

  00020	0f b7 1e	 movzx	 ebx, WORD PTR [esi]
  00023	66 85 db	 test	 bx, bx
  00026	78 12		 js	 SHORT $LN4@gObjMonste@6

; 319  : 		{
; 320  : 			if ( lpMonObj->sHD[n].LastHitTime > LastHitTime )

  00028	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0002b	3b d9		 cmp	 ebx, ecx
  0002d	76 0b		 jbe	 SHORT $LN4@gObjMonste@6

; 321  : 			{
; 322  : 				LastHitTime = lpMonObj->sHD[n].LastHitTime;
; 323  : 				LastHitUser = lpMonObj->sHD[n].number;

  0002f	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00032	8b cb		 mov	 ecx, ebx

; 324  : 				hitindex = n;

  00034	8d 5a fe	 lea	 ebx, DWORD PTR [edx-2]
  00037	98		 cwde
  00038	89 1f		 mov	 DWORD PTR [edi], ebx
$LN4@gObjMonste@6:

; 317  : 	{
; 318  : 		if ( lpMonObj->sHD[n].number >= 0 )

  0003a	0f b7 5e 0c	 movzx	 ebx, WORD PTR [esi+12]
  0003e	66 85 db	 test	 bx, bx
  00041	78 13		 js	 SHORT $LN11@gObjMonste@6

; 319  : 		{
; 320  : 			if ( lpMonObj->sHD[n].LastHitTime > LastHitTime )

  00043	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00046	3b d9		 cmp	 ebx, ecx
  00048	76 0c		 jbe	 SHORT $LN11@gObjMonste@6

; 321  : 			{
; 322  : 				LastHitTime = lpMonObj->sHD[n].LastHitTime;
; 323  : 				LastHitUser = lpMonObj->sHD[n].number;

  0004a	0f b7 46 0c	 movzx	 eax, WORD PTR [esi+12]
  0004e	8b cb		 mov	 ecx, ebx

; 324  : 				hitindex = n;

  00050	8d 5a ff	 lea	 ebx, DWORD PTR [edx-1]
  00053	98		 cwde
  00054	89 1f		 mov	 DWORD PTR [edi], ebx
$LN11@gObjMonste@6:

; 317  : 	{
; 318  : 		if ( lpMonObj->sHD[n].number >= 0 )

  00056	0f b7 5e 18	 movzx	 ebx, WORD PTR [esi+24]
  0005a	66 85 db	 test	 bx, bx
  0005d	78 10		 js	 SHORT $LN12@gObjMonste@6

; 319  : 		{
; 320  : 			if ( lpMonObj->sHD[n].LastHitTime > LastHitTime )

  0005f	8b 5e 20	 mov	 ebx, DWORD PTR [esi+32]
  00062	3b d9		 cmp	 ebx, ecx
  00064	76 09		 jbe	 SHORT $LN12@gObjMonste@6

; 321  : 			{
; 322  : 				LastHitTime = lpMonObj->sHD[n].LastHitTime;
; 323  : 				LastHitUser = lpMonObj->sHD[n].number;

  00066	0f b7 46 18	 movzx	 eax, WORD PTR [esi+24]
  0006a	8b cb		 mov	 ecx, ebx
  0006c	98		 cwde

; 324  : 				hitindex = n;

  0006d	89 17		 mov	 DWORD PTR [edi], edx
$LN12@gObjMonste@6:

; 317  : 	{
; 318  : 		if ( lpMonObj->sHD[n].number >= 0 )

  0006f	0f b7 5e 24	 movzx	 ebx, WORD PTR [esi+36]
  00073	66 85 db	 test	 bx, bx
  00076	78 13		 js	 SHORT $LN13@gObjMonste@6

; 319  : 		{
; 320  : 			if ( lpMonObj->sHD[n].LastHitTime > LastHitTime )

  00078	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
  0007b	3b d9		 cmp	 ebx, ecx
  0007d	76 0c		 jbe	 SHORT $LN13@gObjMonste@6

; 321  : 			{
; 322  : 				LastHitTime = lpMonObj->sHD[n].LastHitTime;
; 323  : 				LastHitUser = lpMonObj->sHD[n].number;

  0007f	0f b7 46 24	 movzx	 eax, WORD PTR [esi+36]
  00083	8b cb		 mov	 ecx, ebx

; 324  : 				hitindex = n;

  00085	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  00088	98		 cwde
  00089	89 1f		 mov	 DWORD PTR [edi], ebx
$LN13@gObjMonste@6:

; 317  : 	{
; 318  : 		if ( lpMonObj->sHD[n].number >= 0 )

  0008b	0f b7 5e 30	 movzx	 ebx, WORD PTR [esi+48]
  0008f	66 85 db	 test	 bx, bx
  00092	78 13		 js	 SHORT $LN14@gObjMonste@6

; 319  : 		{
; 320  : 			if ( lpMonObj->sHD[n].LastHitTime > LastHitTime )

  00094	8b 5e 38	 mov	 ebx, DWORD PTR [esi+56]
  00097	3b d9		 cmp	 ebx, ecx
  00099	76 0c		 jbe	 SHORT $LN14@gObjMonste@6

; 321  : 			{
; 322  : 				LastHitTime = lpMonObj->sHD[n].LastHitTime;
; 323  : 				LastHitUser = lpMonObj->sHD[n].number;

  0009b	0f b7 46 30	 movzx	 eax, WORD PTR [esi+48]
  0009f	8b cb		 mov	 ecx, ebx

; 324  : 				hitindex = n;

  000a1	8d 5a 02	 lea	 ebx, DWORD PTR [edx+2]
  000a4	98		 cwde
  000a5	89 1f		 mov	 DWORD PTR [edi], ebx
$LN14@gObjMonste@6:

; 315  : 
; 316  : 	for ( int n=0;n<MAX_ST_HIT_DAMAGE;n++)

  000a7	83 c2 05	 add	 edx, 5
  000aa	8d 5a fe	 lea	 ebx, DWORD PTR [edx-2]
  000ad	83 c6 3c	 add	 esi, 60			; 0000003cH
  000b0	83 fb 28	 cmp	 ebx, 40			; 00000028H
  000b3	0f 8c 67 ff ff
	ff		 jl	 $LL5@gObjMonste@6
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx

; 325  : 			}
; 326  : 		}
; 327  : 	}
; 328  : 
; 329  : 	return LastHitUser;
; 330  : }

  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?gObjMonsterLastHitDamageUser@@YAHPAUOBJECTSTRUCT@@AAH@Z ENDP ; gObjMonsterLastHitDamageUser
_TEXT	ENDS
PUBLIC	?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z	; gObjMonsterMoveCheck
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
tv170 = 8						; size = 4
tv168 = 8						; size = 4
_lpObj$ = 8						; size = 4
_tx$ = 12						; size = 4
_ty$ = 16						; size = 4
?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z PROC	; gObjMonsterMoveCheck, COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 343  : 	if ( lpObj->m_ActState.Emotion  == 1 )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 88 b4 01 00
	00		 mov	 ecx, DWORD PTR [eax+436]
  0000c	80 e1 f0	 and	 cl, 240			; 000000f0H
  0000f	80 f9 10	 cmp	 cl, 16			; 00000010H
  00012	75 07		 jne	 SHORT $LN3@gObjMonste@7

; 344  : 	{
; 345  : 		return TRUE;

  00014	b8 01 00 00 00	 mov	 eax, 1

; 361  : 	{
; 362  : 		return FALSE;
; 363  : 	}	
; 364  : 
; 365  : 	return TRUE;
; 366  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN3@gObjMonste@7:

; 346  : 	}
; 347  : 
; 348  : 	LPMONSTER_POSITION lpPos = &gMSetBase.m_Mp[lpObj->m_PosNum];

  0001b	0f bf 88 10 02
	00 00		 movsx	 ecx, WORD PTR [eax+528]
  00022	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00025	8d 0c 8d 04 00
	00 00		 lea	 ecx, DWORD PTR ?gMSetBase@@3VCMonsterSetBase@@A[ecx*4+4]
  0002c	53		 push	 ebx

; 349  : 
; 350  : 	if ( lpPos->m_Dis < 1 )

  0002d	8a 59 05	 mov	 bl, BYTE PTR [ecx+5]
  00030	80 fb 01	 cmp	 bl, 1
  00033	73 05		 jae	 SHORT $LN2@gObjMonste@7

; 351  : 	{
; 352  : 		return FALSE;

  00035	33 c0		 xor	 eax, eax
  00037	5b		 pop	 ebx

; 361  : 	{
; 362  : 		return FALSE;
; 363  : 	}	
; 364  : 
; 365  : 	return TRUE;
; 366  : }

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
$LN2@gObjMonste@7:

; 353  : 	}
; 354  : 
; 355  : 	tx -= lpObj->StartX;

  0003a	0f b6 90 1a 01
	00 00		 movzx	 edx, BYTE PTR [eax+282]
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _tx$[ebp]
  00044	2b ca		 sub	 ecx, edx

; 356  : 	ty -= lpObj->StartY;

  00046	0f b6 90 1b 01
	00 00		 movzx	 edx, BYTE PTR [eax+283]

; 357  : 
; 358  : 	int dis = sqrt((double)(tx*tx) + (ty*ty));

  0004d	0f af c9	 imul	 ecx, ecx
  00050	8b 45 10	 mov	 eax, DWORD PTR _ty$[ebp]
  00053	2b c2		 sub	 eax, edx
  00055	0f af c0	 imul	 eax, eax

; 359  : 
; 360  : 	if ( dis > lpPos->m_Dis)

  00058	89 4d 08	 mov	 DWORD PTR tv170[ebp], ecx
  0005b	db 45 08	 fild	 DWORD PTR tv170[ebp]
  0005e	89 45 08	 mov	 DWORD PTR tv168[ebp], eax
  00061	db 45 08	 fild	 DWORD PTR tv168[ebp]
  00064	de c1		 faddp	 ST(1), ST(0)
  00066	e8 00 00 00 00	 call	 __CIsqrt
  0006b	e8 00 00 00 00	 call	 __ftol2_sse
  00070	0f b6 cb	 movzx	 ecx, bl
  00073	33 d2		 xor	 edx, edx
  00075	3b c1		 cmp	 eax, ecx
  00077	0f 9e c2	 setle	 dl
  0007a	5b		 pop	 ebx
  0007b	8b c2		 mov	 eax, edx

; 361  : 	{
; 362  : 		return FALSE;
; 363  : 	}	
; 364  : 
; 365  : 	return TRUE;
; 366  : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z ENDP	; gObjMonsterMoveCheck
_TEXT	ENDS
PUBLIC	?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterGetTargetPos
EXTRN	?RoadPathTable@@3PAFA:BYTE			; RoadPathTable
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?GetStandAttr@MapClass@@QAEHHH@Z:PROC		; MapClass::GetStandAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?GetPathPacketDirPos@@YAEHH@Z:PROC		; GetPathPacketDirPos
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_mtx$ = -20						; size = 4
_mty$ = -16						; size = 4
_lpTargetObj$ = -12					; size = 4
_searchcount$ = -8					; size = 4
_dis$ = -4						; size = 4
_searchp$ = -4						; size = 4
_tpx$ = 8						; size = 4
_lpObj$ = 8						; size = 4
_attr$ = 11						; size = 1
?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterGetTargetPos, COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 371  : 	int tpx;	// Target Player X
; 372  : 	int tpy;
; 373  : 	int mtx;	// Monster Target X
; 374  : 	int mty;
; 375  : 	int searchp = 0;
; 376  : 	int sn = 0;
; 377  : 	int searchcount = MAX_ROAD_PATH_TABLE/2-1;
; 378  : 	BYTE attr;
; 379  : 	BOOL result;
; 380  : 	LPOBJ lpTargetObj;
; 381  : 
; 382  : 	if ( lpObj->m_MoveRange == 0 && lpObj->m_SkillHarden != 0 && lpObj->m_iSkillStunTime > 0 )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	66 83 be 1e 03
	00 00 00	 cmp	 WORD PTR [esi+798], 0
  00012	c7 45 f8 07 00
	00 00		 mov	 DWORD PTR _searchcount$[ebp], 7
  00019	75 19		 jne	 SHORT $LN22@gObjMonste@8
  0001b	83 be 98 02 00
	00 00		 cmp	 DWORD PTR [esi+664], 0
  00022	74 10		 je	 SHORT $LN22@gObjMonste@8
  00024	83 be dc 14 00
	00 00		 cmp	 DWORD PTR [esi+5340], 0
  0002b	7e 07		 jle	 SHORT $LN22@gObjMonste@8
$LN31@gObjMonste@8:

; 383  : 	{
; 384  : 		return FALSE;

  0002d	33 c0		 xor	 eax, eax
  0002f	5e		 pop	 esi

; 499  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN22@gObjMonste@8:

; 385  : 	}
; 386  : 
; 387  : 	if ( OBJMAX_RANGE(lpObj->TargetNumber) == FALSE )

  00034	0f b7 86 d4 02
	00 00		 movzx	 eax, WORD PTR [esi+724]
  0003b	66 85 c0	 test	 ax, ax
  0003e	78 ed		 js	 SHORT $LN31@gObjMonste@8
  00040	33 d2		 xor	 edx, edx
  00042	b9 e7 1c 00 00	 mov	 ecx, 7399		; 00001ce7H
  00047	66 3b c1	 cmp	 ax, cx
  0004a	0f 9e c2	 setle	 dl
  0004d	8b ca		 mov	 ecx, edx
  0004f	85 c9		 test	 ecx, ecx

; 388  : 	{
; 389  : 		return FALSE;

  00051	74 da		 je	 SHORT $LN31@gObjMonste@8

; 390  : 	}
; 391  : 
; 392  : 	lpTargetObj = &gObj[lpObj->TargetNumber];

  00053	57		 push	 edi
  00054	0f bf f8	 movsx	 edi, ax
  00057	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0005d	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 393  : 
; 394  : 	if ( lpTargetObj->Teleport != 0 )

  00063	80 bf 00 02 00
	00 00		 cmp	 BYTE PTR [edi+512], 0
  0006a	89 7d f4	 mov	 DWORD PTR _lpTargetObj$[ebp], edi

; 395  : 	{
; 396  : 		return FALSE;

  0006d	75 0d		 jne	 SHORT $LN40@gObjMonste@8

; 397  : 	}
; 398  : 
; 399  : 	int vpn = gObjMonsterViewportIsCharacter(lpObj);

  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 ?gObjMonsterViewportIsCharacter@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterViewportIsCharacter
  00075	83 c4 04	 add	 esp, 4

; 400  : 
; 401  : 	if ( vpn < 0 )

  00078	85 c0		 test	 eax, eax
  0007a	79 08		 jns	 SHORT $LN19@gObjMonste@8
$LN40@gObjMonste@8:
  0007c	5f		 pop	 edi

; 402  : 	{
; 403  : 		return FALSE;

  0007d	33 c0		 xor	 eax, eax
  0007f	5e		 pop	 esi

; 499  : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN19@gObjMonste@8:

; 404  : 	}
; 405  : 	
; 406  : 	tpx = lpTargetObj->X;
; 407  : 	mtx = tpx;
; 408  : 	tpy = lpTargetObj->Y;
; 409  : 	mty = tpy;
; 410  : 	int dis;
; 411  : 
; 412  : 	if ( lpObj->m_AttackType >= 100 )

  00084	66 83 be 22 03
	00 00 64	 cmp	 WORD PTR [esi+802], 100	; 00000064H
  0008c	0f bf 87 04 01
	00 00		 movsx	 eax, WORD PTR [edi+260]
  00093	0f bf 8f 06 01
	00 00		 movsx	 ecx, WORD PTR [edi+262]
  0009a	8b d0		 mov	 edx, eax
  0009c	8b f9		 mov	 edi, ecx
  0009e	53		 push	 ebx

; 413  : 	{
; 414  : 		dis = lpObj->m_AttackRange + 2;

  0009f	0f bf 9e 20 03
	00 00		 movsx	 ebx, WORD PTR [esi+800]
  000a6	89 55 08	 mov	 DWORD PTR _tpx$[ebp], edx
  000a9	89 55 ec	 mov	 DWORD PTR _mtx$[ebp], edx
  000ac	89 7d f0	 mov	 DWORD PTR _mty$[ebp], edi
  000af	7c 03		 jl	 SHORT $LN18@gObjMonste@8
  000b1	83 c3 02	 add	 ebx, 2
$LN18@gObjMonste@8:

; 415  : 	}
; 416  : 	else
; 417  : 	{
; 418  : 		dis = lpObj->m_AttackRange;

  000b4	89 5d fc	 mov	 DWORD PTR _dis$[ebp], ebx

; 419  : 	}
; 420  : 
; 421  : 	if ( lpObj->X < mtx )

  000b7	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]
  000be	3b da		 cmp	 ebx, edx
  000c0	7d 06		 jge	 SHORT $LN16@gObjMonste@8

; 422  : 	{
; 423  : 		tpx -= dis;

  000c2	2b 55 fc	 sub	 edx, DWORD PTR _dis$[ebp]
  000c5	89 55 08	 mov	 DWORD PTR _tpx$[ebp], edx
$LN16@gObjMonste@8:

; 424  : 	}
; 425  : 
; 426  : 	if ( lpObj->X > mtx )

  000c8	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  000cf	3b 55 ec	 cmp	 edx, DWORD PTR _mtx$[ebp]
  000d2	7e 06		 jle	 SHORT $LN36@gObjMonste@8

; 427  : 	{
; 428  : 		tpx += dis;

  000d4	8b 55 fc	 mov	 edx, DWORD PTR _dis$[ebp]
  000d7	01 55 08	 add	 DWORD PTR _tpx$[ebp], edx
$LN36@gObjMonste@8:

; 429  : 	}
; 430  : 
; 431  : 	if ( lpObj->Y < mty )

  000da	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  000e1	3b d7		 cmp	 edx, edi
  000e3	7d 03		 jge	 SHORT $LN14@gObjMonste@8

; 432  : 	{
; 433  : 		tpy -= dis;

  000e5	2b 7d fc	 sub	 edi, DWORD PTR _dis$[ebp]
$LN14@gObjMonste@8:

; 434  : 	}
; 435  : 
; 436  : 	if ( lpObj->Y > mty )

  000e8	3b 55 f0	 cmp	 edx, DWORD PTR _mty$[ebp]
  000eb	7e 03		 jle	 SHORT $LN13@gObjMonste@8

; 437  : 	{
; 438  : 		tpy += dis;

  000ed	03 7d fc	 add	 edi, DWORD PTR _dis$[ebp]
$LN13@gObjMonste@8:

; 439  : 	}
; 440  : 
; 441  : 	searchp = GetPathPacketDirPos( (lpTargetObj->X - tpx), (lpTargetObj->Y - tpy) ) * 2;

  000f0	2b 45 08	 sub	 eax, DWORD PTR _tpx$[ebp]
  000f3	2b cf		 sub	 ecx, edi
  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 442  : 
; 443  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tpx, tpy) == 0 )

  000fc	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00103	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00109	0f b6 d8	 movzx	 ebx, al
  0010c	8b 45 08	 mov	 eax, DWORD PTR _tpx$[ebp]
  0010f	83 c4 08	 add	 esp, 8
  00112	57		 push	 edi
  00113	03 db		 add	 ebx, ebx
  00115	50		 push	 eax
  00116	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0011c	89 5d fc	 mov	 DWORD PTR _searchp$[ebp], ebx
  0011f	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  00124	85 c0		 test	 eax, eax
  00126	74 7b		 je	 SHORT $LN11@gObjMonste@8

; 473  : 			}
; 474  : 		}
; 475  : 
; 476  : 		return FALSE;
; 477  : 	}
; 478  : 
; 479  : 	attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  00128	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0012f	8b 45 08	 mov	 eax, DWORD PTR _tpx$[ebp]
  00132	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00138	57		 push	 edi
  00139	50		 push	 eax
  0013a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00140	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 480  : 	result = gObjMonsterMoveCheck(lpObj, mtx, mty);

  00145	8b 4d f0	 mov	 ecx, DWORD PTR _mty$[ebp]
  00148	8b 55 ec	 mov	 edx, DWORD PTR _mtx$[ebp]
  0014b	51		 push	 ecx
  0014c	52		 push	 edx
  0014d	56		 push	 esi
  0014e	8a d8		 mov	 bl, al
  00150	e8 00 00 00 00	 call	 ?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjMonsterMoveCheck

; 481  : 
; 482  : 	if ( lpObj->Class == 249 )

  00155	b9 f9 00 00 00	 mov	 ecx, 249		; 000000f9H
  0015a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015d	66 39 8e 98 00
	00 00		 cmp	 WORD PTR [esi+152], cx
  00164	0f 85 06 01 00
	00		 jne	 $LN4@gObjMonste@8

; 483  : 	{
; 484  : 		if ( (attr&2)!=2 && result == TRUE )

  0016a	f6 c3 02	 test	 bl, 2
  0016d	0f 85 da 00 00
	00		 jne	 $LN1@gObjMonste@8
  00173	83 f8 01	 cmp	 eax, 1
  00176	0f 85 d1 00 00
	00		 jne	 $LN1@gObjMonste@8

; 485  : 		{
; 486  : 			lpObj->MTX = tpx;

  0017c	66 8b 55 08	 mov	 dx, WORD PTR _tpx$[ebp]
  00180	5b		 pop	 ebx

; 487  : 			lpObj->MTY = tpy;

  00181	66 89 be 26 01
	00 00		 mov	 WORD PTR [esi+294], di
  00188	5f		 pop	 edi
  00189	66 89 96 24 01
	00 00		 mov	 WORD PTR [esi+292], dx
  00190	5e		 pop	 esi

; 499  : }

  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c3		 ret	 0
  00195	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL34@gObjMonste@8:

; 442  : 
; 443  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tpx, tpy) == 0 )

  001a0	8b 5d fc	 mov	 ebx, DWORD PTR _searchp$[ebp]
$LN11@gObjMonste@8:

; 446  : 		{
; 447  : 			mtx = lpTargetObj->X + RoadPathTable[searchp];

  001a3	8b 4d f4	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001a6	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  001ad	0f bf 3c 5d 00
	00 00 00	 movsx	 edi, WORD PTR ?RoadPathTable@@3PAFA[ebx*2]

; 448  : 			mty = lpTargetObj->Y + RoadPathTable[1+searchp];

  001b5	0f bf 1c 5d 02
	00 00 00	 movsx	 ebx, WORD PTR ?RoadPathTable@@3PAFA[ebx*2+2]
  001bd	ff 4d f8	 dec	 DWORD PTR _searchcount$[ebp]
  001c0	8b c1		 mov	 eax, ecx
  001c2	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  001c9	03 d9		 add	 ebx, ecx

; 449  : 			attr = MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  001cb	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  001d2	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  001d8	03 fa		 add	 edi, edx
  001da	53		 push	 ebx
  001db	57		 push	 edi
  001dc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  001e2	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 450  : 			result = gObjMonsterMoveCheck(lpObj, mtx, mty);

  001e7	53		 push	 ebx
  001e8	57		 push	 edi
  001e9	56		 push	 esi
  001ea	88 45 0b	 mov	 BYTE PTR _attr$[ebp], al
  001ed	e8 00 00 00 00	 call	 ?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjMonsterMoveCheck

; 451  : 
; 452  : 			if ( lpObj->Class == 249 )

  001f2	ba f9 00 00 00	 mov	 edx, 249		; 000000f9H
  001f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fa	66 39 96 98 00
	00 00		 cmp	 WORD PTR [esi+152], dx
  00201	75 20		 jne	 SHORT $LN9@gObjMonste@8

; 453  : 			{
; 454  : 				if ( (attr&2)!=2 && result == TRUE )

  00203	f6 45 0b 02	 test	 BYTE PTR _attr$[ebp], 2
  00207	75 25		 jne	 SHORT $LN6@gObjMonste@8
  00209	83 f8 01	 cmp	 eax, 1
  0020c	75 20		 jne	 SHORT $LN6@gObjMonste@8

; 455  : 				{
; 456  : 					lpObj->MTX = mtx;
; 457  : 					lpObj->MTY = mty;

  0020e	66 89 9e 26 01
	00 00		 mov	 WORD PTR [esi+294], bx
  00215	5b		 pop	 ebx
  00216	66 89 be 24 01
	00 00		 mov	 WORD PTR [esi+292], di
  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi

; 499  : }

  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
$LN9@gObjMonste@8:

; 458  : 					return TRUE;
; 459  : 				}
; 460  : 			}
; 461  : 			else if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8 && result == TRUE )

  00223	f6 45 0b 0f	 test	 BYTE PTR _attr$[ebp], 15 ; 0000000fH
  00227	75 05		 jne	 SHORT $LN6@gObjMonste@8
  00229	83 f8 01	 cmp	 eax, 1
  0022c	74 28		 je	 SHORT $LN29@gObjMonste@8
$LN6@gObjMonste@8:

; 465  : 				return TRUE;
; 466  : 			}
; 467  : 
; 468  : 			searchp += 2;

  0022e	8b 45 fc	 mov	 eax, DWORD PTR _searchp$[ebp]
  00231	83 c0 02	 add	 eax, 2
  00234	89 45 fc	 mov	 DWORD PTR _searchp$[ebp], eax

; 469  : 
; 470  : 			if ( searchp > MAX_ROAD_PATH_TABLE-1 )

  00237	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0023a	7e 07		 jle	 SHORT $LN35@gObjMonste@8

; 471  : 			{
; 472  : 				searchp = 0;

  0023c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _searchp$[ebp], 0
$LN35@gObjMonste@8:

; 444  : 	{
; 445  : 		while ( searchcount-- )

  00243	83 7d f8 00	 cmp	 DWORD PTR _searchcount$[ebp], 0
  00247	0f 85 53 ff ff
	ff		 jne	 $LL34@gObjMonste@8
$LN1@gObjMonste@8:
  0024d	5b		 pop	 ebx
  0024e	5f		 pop	 edi

; 496  : 	}
; 497  : 
; 498  : 	return FALSE;

  0024f	33 c0		 xor	 eax, eax
  00251	5e		 pop	 esi

; 499  : }

  00252	8b e5		 mov	 esp, ebp
  00254	5d		 pop	 ebp
  00255	c3		 ret	 0
$LN29@gObjMonste@8:

; 462  : 			{
; 463  : 				lpObj->MTX = mtx;
; 464  : 				lpObj->MTY = mty;

  00256	66 89 9e 26 01
	00 00		 mov	 WORD PTR [esi+294], bx
  0025d	5b		 pop	 ebx
  0025e	66 89 be 24 01
	00 00		 mov	 WORD PTR [esi+292], di
  00265	5f		 pop	 edi

; 495  : 		return TRUE;

  00266	b8 01 00 00 00	 mov	 eax, 1
  0026b	5e		 pop	 esi

; 499  : }

  0026c	8b e5		 mov	 esp, ebp
  0026e	5d		 pop	 ebp
  0026f	c3		 ret	 0
$LN4@gObjMonste@8:

; 488  : 			return TRUE;
; 489  : 		}
; 490  : 	}
; 491  : 	else if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8 && result == TRUE )

  00270	f6 c3 0f	 test	 bl, 15			; 0000000fH
  00273	75 d8		 jne	 SHORT $LN1@gObjMonste@8
  00275	83 f8 01	 cmp	 eax, 1
  00278	75 d3		 jne	 SHORT $LN1@gObjMonste@8

; 492  : 	{
; 493  : 		lpObj->MTX = tpx;

  0027a	66 8b 45 08	 mov	 ax, WORD PTR _tpx$[ebp]
  0027e	5b		 pop	 ebx

; 494  : 		lpObj->MTY = tpy;

  0027f	66 89 be 26 01
	00 00		 mov	 WORD PTR [esi+294], di
  00286	66 89 86 24 01
	00 00		 mov	 WORD PTR [esi+292], ax
  0028d	5f		 pop	 edi

; 495  : 		return TRUE;

  0028e	b8 01 00 00 00	 mov	 eax, 1
  00293	5e		 pop	 esi

; 499  : }

  00294	8b e5		 mov	 esp, ebp
  00296	5d		 pop	 ebp
  00297	c3		 ret	 0
?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterGetTargetPos
_TEXT	ENDS
PUBLIC	?gObjGetTargetPos@@YAHPAUOBJECTSTRUCT@@HHAAH1@Z	; gObjGetTargetPos
; Function compile flags: /Ogtp
;	COMDAT ?gObjGetTargetPos@@YAHPAUOBJECTSTRUCT@@HHAAH1@Z
_TEXT	SEGMENT
_searchcount$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_tx$ = 20						; size = 4
_ty$ = 24						; size = 4
?gObjGetTargetPos@@YAHPAUOBJECTSTRUCT@@HHAAH1@Z PROC	; gObjGetTargetPos, COMDAT

; 503  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 504  : 	int tpx;	// Target Player X
; 505  : 	int tpy;
; 506  : 	int mtx;	// Monster Target X
; 507  : 	int mty;
; 508  : 	int searchp = 0;
; 509  : 	int sn = 0;
; 510  : 	int searchcount = MAX_ROAD_PATH_TABLE/2-1;
; 511  : 	BYTE attr;
; 512  : 	int dis;
; 513  : 
; 514  : 	tpx = sx;
; 515  : 	mtx = tpx;
; 516  : 	tpy = sy;
; 517  : 	mty = tpy;
; 518  : 
; 519  : 	if ( lpObj->m_AttackType >= 100 )

  00004	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00007	66 83 ba 22 03
	00 00 64	 cmp	 WORD PTR [edx+802], 100	; 00000064H
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR _sy$[ebp]

; 520  : 	{
; 521  : 		dis = lpObj->m_AttackRange + 2;

  00012	0f bf 82 20 03
	00 00		 movsx	 eax, WORD PTR [edx+800]
  00019	53		 push	 ebx
  0001a	8b 5d 0c	 mov	 ebx, DWORD PTR _sx$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR _searchcount$[ebp], 7
  00026	8b fb		 mov	 edi, ebx
  00028	8b f1		 mov	 esi, ecx
  0002a	7c 03		 jl	 SHORT $LN14@gObjGetTar
  0002c	83 c0 02	 add	 eax, 2
$LN14@gObjGetTar:

; 522  : 	}
; 523  : 	else
; 524  : 	{
; 525  : 		dis = lpObj->m_AttackRange;
; 526  : 	}
; 527  : 
; 528  : 	if ( lpObj->X < mtx )

  0002f	0f bf 92 04 01
	00 00		 movsx	 edx, WORD PTR [edx+260]
  00036	3b d3		 cmp	 edx, ebx
  00038	7d 04		 jge	 SHORT $LN25@gObjGetTar

; 529  : 	{
; 530  : 		tpx -= dis;

  0003a	2b f8		 sub	 edi, eax

; 531  : 	}
; 532  : 
; 533  : 	if ( lpObj->X > mtx )

  0003c	3b d3		 cmp	 edx, ebx
$LN25@gObjGetTar:
  0003e	7e 02		 jle	 SHORT $LN12@gObjGetTar

; 534  : 	{
; 535  : 		tpx += dis;

  00040	03 f8		 add	 edi, eax
$LN12@gObjGetTar:

; 536  : 	}
; 537  : 
; 538  : 	if ( lpObj->Y < mty )

  00042	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00045	0f bf 92 06 01
	00 00		 movsx	 edx, WORD PTR [edx+262]
  0004c	3b d1		 cmp	 edx, ecx
  0004e	7d 04		 jge	 SHORT $LN26@gObjGetTar

; 539  : 	{
; 540  : 		tpy -= dis;

  00050	2b f0		 sub	 esi, eax

; 541  : 	}
; 542  : 
; 543  : 	if ( lpObj->Y > mty )

  00052	3b d1		 cmp	 edx, ecx
$LN26@gObjGetTar:
  00054	7e 02		 jle	 SHORT $LN10@gObjGetTar

; 544  : 	{
; 545  : 		tpy += dis;

  00056	03 f0		 add	 esi, eax
$LN10@gObjGetTar:

; 546  : 	}
; 547  : 
; 548  : 	searchp = GetPathPacketDirPos( sx - tpx, sy - tpy ) * 2;

  00058	2b ce		 sub	 ecx, esi
  0005a	51		 push	 ecx
  0005b	2b df		 sub	 ebx, edi
  0005d	53		 push	 ebx
  0005e	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00063	0f b6 d8	 movzx	 ebx, al

; 549  : 
; 550  : 	if ( MapC[lpObj->MapNumber].GetStandAttr(tpx, tpy) == 0 )

  00066	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00069	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00070	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00076	83 c4 08	 add	 esp, 8
  00079	56		 push	 esi
  0007a	57		 push	 edi
  0007b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00081	03 db		 add	 ebx, ebx
  00083	e8 00 00 00 00	 call	 ?GetStandAttr@MapClass@@QAEHHH@Z ; MapClass::GetStandAttr
  00088	85 c0		 test	 eax, eax
  0008a	75 6d		 jne	 SHORT $LN9@gObjGetTar
  0008c	8d 64 24 00	 npad	 4
$LL8@gObjGetTar:

; 553  : 		{
; 554  : 			mtx = sx + RoadPathTable[searchp];
; 555  : 			mty = sy + RoadPathTable[1+searchp];
; 556  : 			attr = MapC[lpObj->MapNumber].GetAttr(mtx, mty);

  00090	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00093	0f b6 89 09 01
	00 00		 movzx	 ecx, BYTE PTR [ecx+265]
  0009a	0f bf 3c 5d 02
	00 00 00	 movsx	 edi, WORD PTR ?RoadPathTable@@3PAFA[ebx*2+2]
  000a2	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000a8	0f bf 34 5d 00
	00 00 00	 movsx	 esi, WORD PTR ?RoadPathTable@@3PAFA[ebx*2]
  000b0	03 7d 10	 add	 edi, DWORD PTR _sy$[ebp]
  000b3	03 75 0c	 add	 esi, DWORD PTR _sx$[ebp]
  000b6	ff 4d fc	 dec	 DWORD PTR _searchcount$[ebp]
  000b9	57		 push	 edi
  000ba	56		 push	 esi
  000bb	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000c1	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 557  : 			
; 558  : 			if ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8 )

  000c6	a8 0f		 test	 al, 15			; 0000000fH
  000c8	74 19		 je	 SHORT $LN19@gObjGetTar

; 562  : 				return TRUE;
; 563  : 			}
; 564  : 
; 565  : 			searchp += 2;

  000ca	83 c3 02	 add	 ebx, 2

; 566  : 
; 567  : 			if ( searchp > MAX_ROAD_PATH_TABLE-1 )

  000cd	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  000d0	7e 02		 jle	 SHORT $LN24@gObjGetTar

; 568  : 			{
; 569  : 				searchp = 0;

  000d2	33 db		 xor	 ebx, ebx
$LN24@gObjGetTar:

; 551  : 	{
; 552  : 		while ( searchcount-- )

  000d4	83 7d fc 00	 cmp	 DWORD PTR _searchcount$[ebp], 0
  000d8	75 b6		 jne	 SHORT $LL8@gObjGetTar
$LN1@gObjGetTar:
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi

; 592  : 	}
; 593  : 
; 594  : 	return FALSE;

  000dc	33 c0		 xor	 eax, eax
  000de	5b		 pop	 ebx

; 595  : }

  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
$LN19@gObjGetTar:

; 559  : 			{
; 560  : 				tx = mtx;

  000e3	8b 55 14	 mov	 edx, DWORD PTR _tx$[ebp]

; 561  : 				ty = mty;

  000e6	8b 45 18	 mov	 eax, DWORD PTR _ty$[ebp]
  000e9	89 32		 mov	 DWORD PTR [edx], esi
  000eb	89 38		 mov	 DWORD PTR [eax], edi
  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi

; 591  : 		return TRUE;

  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	5b		 pop	 ebx

; 595  : }

  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
$LN9@gObjGetTar:

; 570  : 			}
; 571  : 		}
; 572  : 
; 573  : 		return FALSE;
; 574  : 	}
; 575  : 
; 576  : 	attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  000f9	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  000fc	0f b6 8b 09 01
	00 00		 movzx	 ecx, BYTE PTR [ebx+265]
  00103	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00109	56		 push	 esi
  0010a	57		 push	 edi
  0010b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00111	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 577  : 
; 578  : 	if ( lpObj->m_Attribute >= 100 )

  00116	66 83 bb 26 03
	00 00 64	 cmp	 WORD PTR [ebx+806], 100	; 00000064H
  0011e	7c 1a		 jl	 SHORT $LN4@gObjGetTar

; 579  : 	{
; 580  : 		if (  (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8 )

  00120	a8 0e		 test	 al, 14			; 0000000eH
  00122	75 b6		 jne	 SHORT $LN1@gObjGetTar

; 581  : 		{
; 582  : 			tx = tpx;

  00124	8b 4d 14	 mov	 ecx, DWORD PTR _tx$[ebp]

; 583  : 			ty = tpy;

  00127	8b 55 18	 mov	 edx, DWORD PTR _ty$[ebp]
  0012a	89 39		 mov	 DWORD PTR [ecx], edi
  0012c	5f		 pop	 edi
  0012d	89 32		 mov	 DWORD PTR [edx], esi
  0012f	5e		 pop	 esi

; 584  : 			return TRUE;

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	5b		 pop	 ebx

; 595  : }

  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c3		 ret	 0
$LN4@gObjGetTar:

; 585  : 		}
; 586  : 	}
; 587  : 	else if  ( (attr&1) != 1 && (attr&2) != 2 && (attr&4) != 4 && (attr&8) != 8 )

  0013a	a8 0f		 test	 al, 15			; 0000000fH
  0013c	75 9c		 jne	 SHORT $LN1@gObjGetTar

; 588  : 	{
; 589  : 		tx = tpx;

  0013e	8b 45 14	 mov	 eax, DWORD PTR _tx$[ebp]

; 590  : 		ty = tpy;

  00141	8b 4d 18	 mov	 ecx, DWORD PTR _ty$[ebp]
  00144	89 38		 mov	 DWORD PTR [eax], edi
  00146	5f		 pop	 edi
  00147	89 31		 mov	 DWORD PTR [ecx], esi
  00149	5e		 pop	 esi

; 591  : 		return TRUE;

  0014a	b8 01 00 00 00	 mov	 eax, 1
  0014f	5b		 pop	 ebx

; 595  : }

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
?gObjGetTargetPos@@YAHPAUOBJECTSTRUCT@@HHAAH1@Z ENDP	; gObjGetTargetPos
_TEXT	ENDS
PUBLIC	?gObjCallMonsterSetEnemy@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjCallMonsterSetEnemy
; Function compile flags: /Ogtp
;	COMDAT ?gObjCallMonsterSetEnemy@@YAHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_Target$ = 12						; size = 4
?gObjCallMonsterSetEnemy@@YAHPAUOBJECTSTRUCT@@H@Z PROC	; gObjCallMonsterSetEnemy, COMDAT

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 614  : 	if ( lpObj->Type != OBJ_USER )

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	66 83 78 60 01	 cmp	 WORD PTR [eax+96], 1

; 615  : 	{
; 616  : 		return -1;

  0000b	75 4a		 jne	 SHORT $LN1@gObjCallMo

; 617  : 	}
; 618  : 
; 619  : 	LPOBJ lpCallObj = &gObj[lpObj->m_RecallMon];

  0000d	8b 80 cc 02 00
	00		 mov	 eax, DWORD PTR [eax+716]
  00013	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00019	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 620  : 
; 621  : 	if ( lpCallObj->TargetNumber >= 0 )

  0001e	0f b7 88 d4 02
	00 00		 movzx	 ecx, WORD PTR [eax+724]
  00025	66 85 c9	 test	 cx, cx

; 622  : 	{
; 623  : 		return -1;

  00028	79 2d		 jns	 SHORT $LN1@gObjCallMo

; 624  : 	}
; 625  : 
; 626  : 	if ( lpCallObj->TargetNumber != Target )

  0002a	0f bf d1	 movsx	 edx, cx
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _Target$[ebp]
  00030	3b d1		 cmp	 edx, ecx
  00032	74 23		 je	 SHORT $LN1@gObjCallMo

; 627  : 	{
; 628  : 		lpCallObj->TargetNumber = Target;

  00034	66 89 88 d4 02
	00 00		 mov	 WORD PTR [eax+724], cx

; 629  : 		lpCallObj->m_ActState.EmotionCount = 30;

  0003b	c6 80 b5 01 00
	00 1e		 mov	 BYTE PTR [eax+437], 30	; 0000001eH

; 630  : 		lpCallObj->m_ActState.Emotion = 1;

  00042	8b 88 b4 01 00
	00		 mov	 ecx, DWORD PTR [eax+436]
  00048	81 e1 1f ff ff
	ff		 and	 ecx, -225		; ffffff1fH
  0004e	83 c9 10	 or	 ecx, 16			; 00000010H
  00051	89 88 b4 01 00
	00		 mov	 DWORD PTR [eax+436], ecx
$LN1@gObjCallMo:

; 631  : 	}
; 632  : 
; 633  : 	return -1;

  00057	83 c8 ff	 or	 eax, -1

; 634  : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?gObjCallMonsterSetEnemy@@YAHPAUOBJECTSTRUCT@@H@Z ENDP	; gObjCallMonsterSetEnemy
_TEXT	ENDS
PUBLIC	?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z ; gObjMonsterSearchEnemy
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
tv366 = -16						; size = 4
tv364 = -16						; size = 4
_searchtarget$ = -12					; size = 4
tv133 = -8						; size = 4
_mindis$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_objtype$ = 12						; size = 1
?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z PROC	; gObjMonsterSearchEnemy, COMDAT

; 649  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 650  : 	int n;
; 651  : 	int tx;
; 652  : 	int ty;
; 653  : 	int dis;
; 654  : 	int mindis = lpObj->m_ViewRange;

  00009	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 87 24 03
	00 00		 movsx	 eax, WORD PTR [edi+804]
  00013	89 45 fc	 mov	 DWORD PTR _mindis$[ebp], eax

; 655  : 	int searchtarget = -1;

  00016	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _searchtarget$[ebp], -1
  0001d	81 c7 1c 07 00
	00		 add	 edi, 1820		; 0000071cH
  00023	c7 45 f8 14 00
	00 00		 mov	 DWORD PTR tv133[ebp], 20 ; 00000014H
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL21@gObjMonste@9:

; 662  : 	{
; 663  : 		tObjNum = lpObj->VpPlayer2[n].number;

  00030	0f bf 77 fa	 movsx	 esi, WORD PTR [edi-6]

; 664  : 
; 665  : 		if ( tObjNum >= 0 )

  00034	85 f6		 test	 esi, esi
  00036	0f 88 a5 00 00
	00		 js	 $LN11@gObjMonste@9

; 666  : 		{
; 667  : 			if ( (gObj[tObjNum].Type == t1 || gObj[tObjNum].Type == t2) && (gObj[tObjNum].Live != FALSE) )

  0003c	0f b6 5d 0c	 movzx	 ebx, BYTE PTR _objtype$[ebp]
  00040	8b c6		 mov	 eax, esi
  00042	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00048	0f b7 90 60 00
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96]
  0004f	8b ca		 mov	 ecx, edx
  00051	3b cb		 cmp	 ecx, ebx
  00053	0f 85 88 00 00
	00		 jne	 $LN11@gObjMonste@9
  00059	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  00060	74 7f		 je	 SHORT $LN11@gObjMonste@9

; 668  : 			{
; 669  : 				if ( (gObj[tObjNum].Class >= 100 && gObj[tObjNum].Class < 110 ) || (gObj[tObjNum].Type == OBJ_MONSTER && gObj[tObjNum].m_RecallMon >= 0) )

  00062	0f b7 88 98 00
	00 00		 movzx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+152]
  00069	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0006c	72 05		 jb	 SHORT $LN4@gObjMonste@9
  0006e	83 f9 6e	 cmp	 ecx, 110		; 0000006eH
  00071	72 6e		 jb	 SHORT $LN11@gObjMonste@9
$LN4@gObjMonste@9:
  00073	83 fa 02	 cmp	 edx, 2
  00076	75 09		 jne	 SHORT $LN6@gObjMonste@9
  00078	83 b8 cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+716], 0

; 670  : 				{
; 671  : 
; 672  : 				}
; 673  : 				else if ( (gObj[tObjNum].Authority &2) != 2 && gObj[tObjNum].Teleport == 0 ) // Check if this is teleport #error

  0007f	7d 60		 jge	 SHORT $LN11@gObjMonste@9
$LN6@gObjMonste@9:
  00081	f6 80 a4 01 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+420], 2
  00088	75 57		 jne	 SHORT $LN11@gObjMonste@9
  0008a	80 b8 00 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+512], 0
  00091	75 4e		 jne	 SHORT $LN11@gObjMonste@9

; 674  : 				{
; 675  : 					tx = lpObj->X - gObj[tObjNum].X;

  00093	0f bf 98 04 01
	00 00		 movsx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0009a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009d	0f bf 8a 04 01
	00 00		 movsx	 ecx, WORD PTR [edx+260]
  000a4	2b cb		 sub	 ecx, ebx

; 676  : 					ty = lpObj->Y - gObj[tObjNum].Y;

  000a6	0f bf 98 06 01
	00 00		 movsx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]

; 677  : 					dis = sqrt((double)(tx*tx)+(ty*ty));

  000ad	0f af c9	 imul	 ecx, ecx
  000b0	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  000b7	2b c3		 sub	 eax, ebx
  000b9	0f af c0	 imul	 eax, eax
  000bc	89 45 f0	 mov	 DWORD PTR tv366[ebp], eax
  000bf	db 45 f0	 fild	 DWORD PTR tv366[ebp]
  000c2	89 4d f0	 mov	 DWORD PTR tv364[ebp], ecx
  000c5	db 45 f0	 fild	 DWORD PTR tv364[ebp]
  000c8	de c1		 faddp	 ST(1), ST(0)
  000ca	e8 00 00 00 00	 call	 __CIsqrt
  000cf	e8 00 00 00 00	 call	 __ftol2_sse

; 678  : 					lpObj->VpPlayer2[n].dis = dis;

  000d4	89 07		 mov	 DWORD PTR [edi], eax

; 679  : 
; 680  : 					if ( dis < mindis )

  000d6	3b 45 fc	 cmp	 eax, DWORD PTR _mindis$[ebp]
  000d9	7d 06		 jge	 SHORT $LN11@gObjMonste@9

; 681  : 					{
; 682  : 						searchtarget = tObjNum;

  000db	89 75 f4	 mov	 DWORD PTR _searchtarget$[ebp], esi

; 683  : 						mindis = dis;

  000de	89 45 fc	 mov	 DWORD PTR _mindis$[ebp], eax
$LN11@gObjMonste@9:

; 656  : 	int tObjNum;
; 657  : 	int count = 3;
; 658  : 	int t1 = objtype;
; 659  : 	int t2 = objtype;
; 660  : 
; 661  : 	for (n=0;n<MAX_VIEWPORT_MONSTER;n++)

  000e1	83 c7 0c	 add	 edi, 12			; 0000000cH
  000e4	ff 4d f8	 dec	 DWORD PTR tv133[ebp]
  000e7	0f 85 43 ff ff
	ff		 jne	 $LL21@gObjMonste@9

; 684  : 					}
; 685  : 				}
; 686  : 			}
; 687  : 		}
; 688  : 	}
; 689  : 
; 690  : 	return searchtarget;

  000ed	8b 45 f4	 mov	 eax, DWORD PTR _searchtarget$[ebp]
  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx

; 691  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z ENDP	; gObjMonsterSearchEnemy
_TEXT	ENDS
PUBLIC	?gObjGuardSearchEnemy@@YAHPAUOBJECTSTRUCT@@@Z	; gObjGuardSearchEnemy
; Function compile flags: /Ogtp
;	COMDAT ?gObjGuardSearchEnemy@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_tObjNum$ = -16						; size = 4
tv319 = -12						; size = 4
tv317 = -12						; size = 4
_searchtarget$ = -8					; size = 4
tv95 = -4						; size = 4
_mindis$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjGuardSearchEnemy@@YAHPAUOBJECTSTRUCT@@@Z PROC	; gObjGuardSearchEnemy, COMDAT

; 695  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 696  : 	int n;
; 697  : 	int tx;
; 698  : 	int ty;
; 699  : 	int dis;
; 700  : 	int mindis = lpObj->m_ViewRange;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0000a	0f bf 83 24 03
	00 00		 movsx	 eax, WORD PTR [ebx+804]
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 45 08	 mov	 DWORD PTR _mindis$[ebp], eax

; 701  : 	int searchtarget = -1;

  00016	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _searchtarget$[ebp], -1
  0001d	8d bb 1c 07 00
	00		 lea	 edi, DWORD PTR [ebx+1820]
  00023	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR tv95[ebp], 20	; 00000014H
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL7@gObjGuardS:

; 706  : 	{
; 707  : 		tObjNum = lpObj->VpPlayer2[n].number;

  00030	0f bf 77 fa	 movsx	 esi, WORD PTR [edi-6]
  00034	89 75 f0	 mov	 DWORD PTR _tObjNum$[ebp], esi

; 708  : 
; 709  : 		if ( tObjNum >= 0 )

  00037	85 f6		 test	 esi, esi
  00039	0f 88 97 00 00
	00		 js	 $LN6@gObjGuardS

; 710  : 		{
; 711  : 			if ( gObj[tObjNum].Type == OBJ_USER && gObj[tObjNum].m_PK_Level > 4 )

  0003f	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00045	66 83 be 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], 1
  0004d	0f 85 83 00 00
	00		 jne	 $LN6@gObjGuardS
  00053	80 be fd 00 00
	00 04		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+253], 4
  0005a	7e 7a		 jle	 SHORT $LN6@gObjGuardS

; 712  : 			{
; 713  : 				attr = MapC[gObj[tObjNum].MapNumber].GetAttr(gObj[tObjNum].X, gObj[tObjNum].Y);
; 714  : 
; 715  : 				if ( (attr&1) != 1 )

  0005c	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00063	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  0006a	51		 push	 ecx
  0006b	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265]
  00072	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00078	52		 push	 edx
  00079	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0007f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00084	a8 01		 test	 al, 1
  00086	75 4e		 jne	 SHORT $LN6@gObjGuardS

; 716  : 				{
; 717  : 					tx = lpObj->X - gObj[tObjNum].X;

  00088	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]
  0008f	0f bf 83 04 01
	00 00		 movsx	 eax, WORD PTR [ebx+260]

; 718  : 					ty = lpObj->Y - gObj[tObjNum].Y;

  00096	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  0009d	2b c1		 sub	 eax, ecx
  0009f	0f bf 8b 06 01
	00 00		 movsx	 ecx, WORD PTR [ebx+262]

; 719  : 					dis = sqrt((double)(tx*tx)+(ty*ty));

  000a6	0f af c0	 imul	 eax, eax
  000a9	2b ca		 sub	 ecx, edx
  000ab	0f af c9	 imul	 ecx, ecx
  000ae	89 4d f4	 mov	 DWORD PTR tv319[ebp], ecx
  000b1	db 45 f4	 fild	 DWORD PTR tv319[ebp]
  000b4	89 45 f4	 mov	 DWORD PTR tv317[ebp], eax
  000b7	db 45 f4	 fild	 DWORD PTR tv317[ebp]
  000ba	de c1		 faddp	 ST(1), ST(0)
  000bc	e8 00 00 00 00	 call	 __CIsqrt
  000c1	e8 00 00 00 00	 call	 __ftol2_sse

; 720  : 					lpObj->VpPlayer2[n].dis = dis;

  000c6	89 07		 mov	 DWORD PTR [edi], eax

; 721  : 
; 722  : 					if ( dis < mindis )

  000c8	3b 45 08	 cmp	 eax, DWORD PTR _mindis$[ebp]
  000cb	7d 09		 jge	 SHORT $LN6@gObjGuardS

; 723  : 					{
; 724  : 						searchtarget = tObjNum;

  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  000d0	89 4d f8	 mov	 DWORD PTR _searchtarget$[ebp], ecx

; 725  : 						mindis = dis;

  000d3	89 45 08	 mov	 DWORD PTR _mindis$[ebp], eax
$LN6@gObjGuardS:

; 702  : 	int tObjNum;
; 703  : 	BYTE attr;
; 704  : 
; 705  : 	for (n=0;n<MAX_VIEWPORT_MONSTER;n++)

  000d6	83 c7 0c	 add	 edi, 12			; 0000000cH
  000d9	ff 4d fc	 dec	 DWORD PTR tv95[ebp]
  000dc	0f 85 4e ff ff
	ff		 jne	 $LL7@gObjGuardS

; 726  : 					}
; 727  : 				}
; 728  : 			}
; 729  : 		}
; 730  : 	}
; 731  : 
; 732  : 	return searchtarget;

  000e2	8b 45 f8	 mov	 eax, DWORD PTR _searchtarget$[ebp]
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx

; 733  : }

  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
?gObjGuardSearchEnemy@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; gObjGuardSearchEnemy
_TEXT	ENDS
PUBLIC	__real@4014000000000000
PUBLIC	__real@4039000000000000
PUBLIC	?gObjUseMonsterSpecialAbillity@@YAXPAUOBJECTSTRUCT@@@Z ; gObjUseMonsterSpecialAbillity
EXTRN	?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z:PROC ; CGMagicAttack
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjUseMonsterSpecialAbillity@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pAttackMsg$158283 = -8					; size = 7
_lpMonsterObj$ = 8					; size = 4
?gObjUseMonsterSpecialAbillity@@YAXPAUOBJECTSTRUCT@@@Z PROC ; gObjUseMonsterSpecialAbillity, COMDAT

; 1409 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1410 : 	if ( lpMonsterObj->Class == 275 )	// Kundun

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpMonsterObj$[ebp]
  0000a	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  0000f	66 39 86 98 00
	00 00		 cmp	 WORD PTR [esi+152], ax
  00016	0f 85 83 00 00
	00		 jne	 $LN1@gObjUseMon

; 1411 : 	{
; 1412 : 		PMSG_MAGICATTACK pAttackMsg;
; 1413 : 
; 1414 : 		pAttackMsg.MagicNumber = 1;
; 1415 : 		pAttackMsg.NumberH = SET_NUMBERH(lpMonsterObj->TargetNumber);
; 1416 : 		pAttackMsg.NumberL = SET_NUMBERL(lpMonsterObj->TargetNumber);
; 1417 : 		pAttackMsg.Dis = 0;
; 1418 : 
; 1419 : 		if ( (lpMonsterObj->MaxLife / 25.0f) > lpMonsterObj->Life  )

  0001c	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  00022	0f bf 8e d4 02
	00 00		 movsx	 ecx, WORD PTR [esi+724]
  00029	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4039000000000000
  0002f	8a 96 d4 02 00
	00		 mov	 dl, BYTE PTR [esi+724]
  00035	c1 e9 08	 shr	 ecx, 8
  00038	c6 45 fb 01	 mov	 BYTE PTR _pAttackMsg$158283[ebp+3], 1
  0003c	88 4d fc	 mov	 BYTE PTR _pAttackMsg$158283[ebp+4], cl
  0003f	88 55 fd	 mov	 BYTE PTR _pAttackMsg$158283[ebp+5], dl
  00042	c6 45 fe 00	 mov	 BYTE PTR _pAttackMsg$158283[ebp+6], 0
  00046	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0004c	de d9		 fcompp
  0004e	df e0		 fnstsw	 ax
  00050	f6 c4 05	 test	 ah, 5
  00053	7a 20		 jp	 SHORT $LN3@gObjUseMon

; 1420 : 		{
; 1421 : 			CGMagicAttack(&pAttackMsg, lpMonsterObj->m_Index);

  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	50		 push	 eax
  00058	8d 4d f8	 lea	 ecx, DWORD PTR _pAttackMsg$158283[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack

; 1422 : 			CGMagicAttack(&pAttackMsg, lpMonsterObj->m_Index);

  00061	8b 16		 mov	 edx, DWORD PTR [esi]
  00063	52		 push	 edx
  00064	8d 45 f8	 lea	 eax, DWORD PTR _pAttackMsg$158283[ebp]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  0006d	83 c4 10	 add	 esp, 16			; 00000010H
  00070	5e		 pop	 esi

; 1427 : 		}
; 1428 : 	}
; 1429 : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN3@gObjUseMon:

; 1423 : 		}
; 1424 : 		else if ( (lpMonsterObj->MaxLife / 5.0f) > lpMonsterObj->Life  )

  00075	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  0007b	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4014000000000000
  00081	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  00087	de d9		 fcompp
  00089	df e0		 fnstsw	 ax
  0008b	f6 c4 05	 test	 ah, 5
  0008e	7a 0f		 jp	 SHORT $LN1@gObjUseMon

; 1425 : 		{
; 1426 : 			CGMagicAttack(&pAttackMsg, lpMonsterObj->m_Index);

  00090	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00092	51		 push	 ecx
  00093	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$158283[ebp]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  0009c	83 c4 08	 add	 esp, 8
$LN1@gObjUseMon:
  0009f	5e		 pop	 esi

; 1427 : 		}
; 1428 : 	}
; 1429 : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?gObjUseMonsterSpecialAbillity@@YAXPAUOBJECTSTRUCT@@@Z ENDP ; gObjUseMonsterSpecialAbillity
_TEXT	ENDS
PUBLIC	??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BA@OAKCBJLL@gObjMonster?4cpp?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjMonsterBeattackRecv@@YAXPAEH@Z		; gObjMonsterBeattackRecv
EXTRN	?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z:PROC ; gObjAttack
EXTRN	?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetMagic
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@ DB 'error-L3 %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OAKCBJLL@gObjMonster?4cpp?$AA@
CONST	SEGMENT
??_C@_0BA@OAKCBJLL@gObjMonster?4cpp?$AA@ DB 'gObjMonster.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterBeattackRecv@@YAXPAEH@Z
_TEXT	SEGMENT
_lpMagic$ = -524					; size = 4
tv229 = -520						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpRecv$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?gObjMonsterBeattackRecv@@YAXPAEH@Z PROC		; gObjMonsterBeattackRecv, COMDAT

; 1434 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 1435 : 	
; 1436 : 	// Get Packet Pointer
; 1437 : 	PMSG_BEATTACK_COUNT * lpCount = (PMSG_BEATTACK_COUNT *)lpRecv;
; 1438 : 
; 1439 : 	// Set Offset
; 1440 : 	int lOfs = sizeof(PMSG_BEATTACK_COUNT);
; 1441 : 
; 1442 : 	int tNumber;	// Target Index Number
; 1443 : 
; 1444 : 	// Get Current Magic
; 1445 : 	CMagicInf * lpMagic = gObjGetMagic(&gObj[aIndex], lpCount->MagicNumber);

  00016	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0001c	53		 push	 ebx
  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _lpRecv$[ebp]
  00020	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00024	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  0002a	51		 push	 ecx
  0002b	50		 push	 eax
  0002c	89 85 f8 fd ff
	ff		 mov	 DWORD PTR tv229[ebp], eax
  00032	e8 00 00 00 00	 call	 ?gObjGetMagic@@YAPAVCMagicInf@@PAUOBJECTSTRUCT@@H@Z ; gObjGetMagic
  00037	83 c4 08	 add	 esp, 8
  0003a	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _lpMagic$[ebp], eax

; 1446 : 
; 1447 : 	if ( lpMagic == NULL )

  00040	85 c0		 test	 eax, eax
  00042	75 27		 jne	 SHORT $LN7@gObjMonste@10

; 1448 : 	{
; 1449 : 		LogAdd(LOG_BLACK, "error-L3 %s %d", __FILE__, __LINE__);

  00044	68 a9 05 00 00	 push	 1449			; 000005a9H
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@OAKCBJLL@gObjMonster?4cpp?$AA@
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEHIDPGB@error?9L3?5?$CFs?5?$CFd?$AA@
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00059	83 c4 10	 add	 esp, 16			; 00000010H
  0005c	5b		 pop	 ebx

; 1470 : 	}
; 1471 : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN7@gObjMonste@10:
  0006b	56		 push	 esi

; 1455 : 	int pTargetNumber[128]={0};
; 1456 : 
; 1457 : 	for (int i=0;i<lpCount->Count;i++)

  0006c	0f b6 73 07	 movzx	 esi, BYTE PTR [ebx+7]
  00070	33 c0		 xor	 eax, eax
  00072	57		 push	 edi
  00073	85 f6		 test	 esi, esi
  00075	7e 11		 jle	 SHORT $LN4@gObjMonste@10

; 1450 : 		return;
; 1451 : 	}
; 1452 : 
; 1453 : 	PMSG_BEATTACK * lpMsg;
; 1454 : 	int lOfs2 = lOfs;

  00077	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL6@gObjMonste@10:

; 1455 : 	int pTargetNumber[128]={0};
; 1456 : 
; 1457 : 	for (int i=0;i<lpCount->Count;i++)

  00080	40		 inc	 eax

; 1458 : 	{
; 1459 : 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs2];
; 1460 : 		pTargetNumber[i] = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 1461 : 		lOfs2+= sizeof(PMSG_BEATTACK);

  00081	83 c1 03	 add	 ecx, 3
  00084	3b c6		 cmp	 eax, esi
  00086	7c f8		 jl	 SHORT $LL6@gObjMonste@10
$LN4@gObjMonste@10:

; 1462 : 	}
; 1463 : 	
; 1464 : 	for (int n=0;n<lpCount->Count;n++)

  00088	33 ff		 xor	 edi, edi
  0008a	85 f6		 test	 esi, esi
  0008c	7e 4a		 jle	 SHORT $LN15@gObjMonste@10
  0008e	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
$LL14@gObjMonste@10:

; 1465 : 	{
; 1466 : 		lpMsg = (PMSG_BEATTACK *)&lpRecv[lOfs];
; 1467 : 		tNumber = MAKE_NUMBERW(lpMsg->NumberH, lpMsg->NumberL);
; 1468 : 		gObjAttack(&gObj[aIndex], &gObj[tNumber], lpMagic, 1, 1, 0 ,0);

  00091	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00094	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0009a	6a 00		 push	 0
  0009c	6a 00		 push	 0
  0009e	6a 01		 push	 1
  000a0	6a 01		 push	 1
  000a2	50		 push	 eax
  000a3	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  000a7	66 c1 e1 08	 shl	 cx, 8
  000ab	0f b7 d1	 movzx	 edx, cx
  000ae	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR tv229[ebp]
  000b4	0b d0		 or	 edx, eax
  000b6	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  000bc	81 c2 00 00 00
	00		 add	 edx, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000c2	52		 push	 edx
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  000c9	0f b6 53 07	 movzx	 edx, BYTE PTR [ebx+7]
  000cd	47		 inc	 edi
  000ce	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1469 : 		lOfs+= sizeof(PMSG_BEATTACK);

  000d1	83 c6 03	 add	 esi, 3
  000d4	3b fa		 cmp	 edi, edx
  000d6	7c b9		 jl	 SHORT $LL14@gObjMonste@10
$LN15@gObjMonste@10:

; 1470 : 	}
; 1471 : }

  000d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	33 cd		 xor	 ecx, ebp
  000df	5b		 pop	 ebx
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?gObjMonsterBeattackRecv@@YAXPAEH@Z ENDP		; gObjMonsterBeattackRecv
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?PathFindMoveMsgSend@@YAHPAUOBJECTSTRUCT@@@Z	; PathFindMoveMsgSend
EXTRN	?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z:PROC		; PMoveProc
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding2
EXTRN	?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z:PROC ; MapClass::PathFinding3
; Function compile flags: /Ogtp
;	COMDAT ?PathFindMoveMsgSend@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv513 = -180						; size = 4
tv592 = -176						; size = 4
_sy$158438 = -172					; size = 4
tv569 = -168						; size = 4
_sx$158437 = -164					; size = 4
_pos$158439 = -157					; size = 1
_path$ = -156						; size = 128
_pMove$ = -28						; size = 13
_bPath$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?PathFindMoveMsgSend@@YAHPAUOBJECTSTRUCT@@@Z PROC	; PathFindMoveMsgSend, COMDAT

; 1681 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 1682 : 	if ( lpObj->m_SkillHarden )

  00017	83 be 98 02 00
	00 00		 cmp	 DWORD PTR [esi+664], 0

; 1683 : 		return FALSE;

  0001e	0f 85 e2 02 00
	00		 jne	 $LN7@PathFindMo

; 1684 : 
; 1685 : 	if ( lpObj->m_iSkillStunTime > 0 )

  00024	83 be dc 14 00
	00 00		 cmp	 DWORD PTR [esi+5340], 0

; 1686 : 		return FALSE;

  0002b	0f 8f d5 02 00
	00		 jg	 $LN7@PathFindMo

; 1687 : 
; 1688 : 	PATH_t path;
; 1689 : 	PMSG_MOVE pMove;
; 1690 : 	unsigned char bPath[8];
; 1691 : 	
; 1692 : 
; 1693 : 	pMove.h.c = 0xC1;
; 1694 : 	pMove.h.headcode = PROTOCOL_MOVE;
; 1695 : 	pMove.h.size = sizeof(pMove);
; 1696 : 	pMove.X = lpObj->X;
; 1697 : 	pMove.Y = lpObj->Y;
; 1698 : 
; 1699 : 	BOOL bPathFound = FALSE;
; 1700 : 
; 1701 : 	if ( lpObj->Type == OBJ_MONSTER && lpObj->m_bIsInMonsterHerd != FALSE )

  00031	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  00036	8a 86 04 01 00
	00		 mov	 al, BYTE PTR [esi+260]
  0003c	8a 8e 06 01 00
	00		 mov	 cl, BYTE PTR [esi+262]
  00042	c6 45 e4 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H
  00046	66 c7 45 e5 0d
	d3		 mov	 WORD PTR _pMove$[ebp+1], 54029 ; 0000d30dH
  0004c	88 45 e7	 mov	 BYTE PTR _pMove$[ebp+3], al
  0004f	88 4d e8	 mov	 BYTE PTR _pMove$[ebp+4], cl
  00052	75 4a		 jne	 SHORT $LN9@PathFindMo
  00054	83 be 24 0f 00
	00 00		 cmp	 DWORD PTR [esi+3876], 0
  0005b	74 41		 je	 SHORT $LN9@PathFindMo

; 1702 : 	{
; 1703 : 		bPathFound = MapC[lpObj->MapNumber].PathFinding3(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY, &path);

  0005d	0f bf 86 26 01
	00 00		 movsx	 eax, WORD PTR [esi+294]
  00064	0f bf 8e 24 01
	00 00		 movsx	 ecx, WORD PTR [esi+292]
  0006b	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  00071	52		 push	 edx
  00072	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00079	50		 push	 eax
  0007a	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  00081	51		 push	 ecx
  00082	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00089	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0008f	52		 push	 edx
  00090	50		 push	 eax
  00091	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00097	e8 00 00 00 00	 call	 ?PathFinding3@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding3

; 1704 : 	}
; 1705 : 	else

  0009c	eb 3f		 jmp	 SHORT $LN19@PathFindMo
$LN9@PathFindMo:

; 1706 : 	{
; 1707 : 		bPathFound = MapC[lpObj->MapNumber].PathFinding2(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY, &path);

  0009e	0f bf 96 26 01
	00 00		 movsx	 edx, WORD PTR [esi+294]
  000a5	0f bf 86 24 01
	00 00		 movsx	 eax, WORD PTR [esi+292]
  000ac	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  000b2	51		 push	 ecx
  000b3	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  000ba	52		 push	 edx
  000bb	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  000c2	50		 push	 eax
  000c3	51		 push	 ecx
  000c4	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000cb	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000d1	52		 push	 edx
  000d2	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000d8	e8 00 00 00 00	 call	 ?PathFinding2@MapClass@@QAE_NHHHHPAUPATH_t@@@Z ; MapClass::PathFinding2
$LN19@PathFindMo:
  000dd	0f b6 c0	 movzx	 eax, al

; 1708 : 	}
; 1709 : 
; 1710 : 	if ( bPathFound )

  000e0	85 c0		 test	 eax, eax
  000e2	0f 84 1e 02 00
	00		 je	 $LN7@PathFindMo

; 1717 : 
; 1718 : 		memset(bPath, 0, sizeof(bPath));

  000e8	33 c0		 xor	 eax, eax
  000ea	53		 push	 ebx

; 1719 : 		bPath[0] = (lpObj->Dir *16) + ((path.PathNum-1)&0x0F);

  000eb	8a 9d 64 ff ff
	ff		 mov	 bl, BYTE PTR _path$[ebp]
  000f1	89 45 f4	 mov	 DWORD PTR _bPath$[ebp], eax
  000f4	89 45 f8	 mov	 DWORD PTR _bPath$[ebp+4], eax
  000f7	8a 86 08 01 00
	00		 mov	 al, BYTE PTR [esi+264]
  000fd	fe cb		 dec	 bl
  000ff	8a c8		 mov	 cl, al
  00101	c0 e1 04	 shl	 cl, 4
  00104	80 e3 0f	 and	 bl, 15			; 0000000fH
  00107	02 d9		 add	 bl, cl

; 1720 : 		sx = lpObj->X;
; 1721 : 		sy = lpObj->Y;
; 1722 : 		lpObj->PathX[0] = lpObj->X;
; 1723 : 		lpObj->PathY[0] = lpObj->Y;
; 1724 : 		lpObj->PathDir[0] = lpObj->Dir;
; 1725 : 
; 1726 : 		for (int n=1;n<path.PathNum;n++)

  00109	83 bd 64 ff ff
	ff 01		 cmp	 DWORD PTR _path$[ebp], 1
  00110	0f b7 8e 04 01
	00 00		 movzx	 ecx, WORD PTR [esi+260]
  00117	0f bf d1	 movsx	 edx, cx
  0011a	89 95 5c ff ff
	ff		 mov	 DWORD PTR _sx$158437[ebp], edx
  00120	0f b7 96 06 01
	00 00		 movzx	 edx, WORD PTR [esi+262]
  00127	57		 push	 edi
  00128	0f bf fa	 movsx	 edi, dx
  0012b	c6 85 63 ff ff
	ff 00		 mov	 BYTE PTR _pos$158439[ebp], 0
  00132	88 5d f4	 mov	 BYTE PTR _bPath$[ebp], bl
  00135	89 bd 54 ff ff
	ff		 mov	 DWORD PTR _sy$158438[ebp], edi
  0013b	66 89 8e 50 01
	00 00		 mov	 WORD PTR [esi+336], cx
  00142	66 89 96 6e 01
	00 00		 mov	 WORD PTR [esi+366], dx
  00149	88 86 8c 01 00
	00		 mov	 BYTE PTR [esi+396], al
  0014f	0f 8e e3 00 00
	00		 jle	 $LN17@PathFindMo

; 1711 : 	{
; 1712 : 		int tx;
; 1713 : 		int ty;
; 1714 : 		int sx;
; 1715 : 		int sy;
; 1716 : 		BYTE pos = 0;

  00155	8d 45 a8	 lea	 eax, DWORD PTR _path$[ebp+68]
  00158	8d 8e 70 01 00
	00		 lea	 ecx, DWORD PTR [esi+368]
  0015e	c7 85 4c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR tv513[ebp], 2
  00168	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv569[ebp], eax
  0016e	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv592[ebp], ecx
  00174	eb 10		 jmp	 SHORT $LN6@PathFindMo
  00176	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL16@PathFindMo:
  00180	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv569[ebp]
$LN6@PathFindMo:

; 1727 : 		{
; 1728 : 			tx = path.PathX[n];
; 1729 : 			ty = path.PathY[n];

  00186	8b 38		 mov	 edi, DWORD PTR [eax]
  00188	8b 58 c4	 mov	 ebx, DWORD PTR [eax-60]

; 1730 : 			pos = GetPathPacketDirPos(tx-sx, ty-sy);

  0018b	8b d7		 mov	 edx, edi
  0018d	2b 95 54 ff ff
	ff		 sub	 edx, DWORD PTR _sy$158438[ebp]
  00193	8b c3		 mov	 eax, ebx
  00195	2b 85 5c ff ff
	ff		 sub	 eax, DWORD PTR _sx$158437[ebp]
  0019b	52		 push	 edx
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 1731 : 			lpObj->PathX[n] = tx;

  001a2	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv592[ebp]
  001a8	66 89 59 e2	 mov	 WORD PTR [ecx-30], bx

; 1732 : 			lpObj->PathY[n] = ty;

  001ac	66 89 39	 mov	 WORD PTR [ecx], di

; 1733 : 			lpObj->PathDir[n] = pos;

  001af	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv513[ebp]

; 1734 : 			sx = tx;
; 1735 : 			sy = ty;
; 1736 : 
; 1737 : 			if ( (n%2)==1 )

  001b5	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  001b8	83 c4 08	 add	 esp, 8
  001bb	81 e2 01 00 00
	80		 and	 edx, -2147483647	; 80000001H
  001c1	88 85 63 ff ff
	ff		 mov	 BYTE PTR _pos$158439[ebp], al
  001c7	88 84 0e 8b 01
	00 00		 mov	 BYTE PTR [esi+ecx+395], al
  001ce	89 9d 5c ff ff
	ff		 mov	 DWORD PTR _sx$158437[ebp], ebx
  001d4	89 bd 54 ff ff
	ff		 mov	 DWORD PTR _sy$158438[ebp], edi
  001da	79 05		 jns	 SHORT $LN18@PathFindMo
  001dc	4a		 dec	 edx
  001dd	83 ca fe	 or	 edx, -2			; fffffffeH
  001e0	42		 inc	 edx
$LN18@PathFindMo:
  001e1	83 fa 01	 cmp	 edx, 1
  001e4	75 12		 jne	 SHORT $LN3@PathFindMo

; 1738 : 			{
; 1739 : 				bPath[(n+1)/2] = (pos * 16);

  001e6	8a d8		 mov	 bl, al
  001e8	8b c1		 mov	 eax, ecx
  001ea	99		 cdq
  001eb	c0 e3 04	 shl	 bl, 4
  001ee	2b c2		 sub	 eax, edx
  001f0	d1 f8		 sar	 eax, 1
  001f2	88 5c 05 f4	 mov	 BYTE PTR _bPath$[ebp+eax], bl

; 1740 : 			}
; 1741 : 			else

  001f6	eb 15		 jmp	 SHORT $LN5@PathFindMo
$LN3@PathFindMo:

; 1742 : 			{
; 1743 : 				bPath[(n+1)/2] |= pos;

  001f8	8b c1		 mov	 eax, ecx
  001fa	99		 cdq
  001fb	2b c2		 sub	 eax, edx
  001fd	8a 95 63 ff ff
	ff		 mov	 dl, BYTE PTR _pos$158439[ebp]
  00203	d1 f8		 sar	 eax, 1
  00205	08 54 05 f4	 or	 BYTE PTR _bPath$[ebp+eax], dl
  00209	8d 44 05 f4	 lea	 eax, DWORD PTR _bPath$[ebp+eax]
$LN5@PathFindMo:

; 1720 : 		sx = lpObj->X;
; 1721 : 		sy = lpObj->Y;
; 1722 : 		lpObj->PathX[0] = lpObj->X;
; 1723 : 		lpObj->PathY[0] = lpObj->Y;
; 1724 : 		lpObj->PathDir[0] = lpObj->Dir;
; 1725 : 
; 1726 : 		for (int n=1;n<path.PathNum;n++)

  0020d	83 85 50 ff ff
	ff 02		 add	 DWORD PTR tv592[ebp], 2
  00214	83 85 58 ff ff
	ff 04		 add	 DWORD PTR tv569[ebp], 4
  0021b	41		 inc	 ecx
  0021c	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv513[ebp], ecx
  00222	49		 dec	 ecx
  00223	3b 8d 64 ff ff
	ff		 cmp	 ecx, DWORD PTR _path$[ebp]
  00229	0f 8c 51 ff ff
	ff		 jl	 $LL16@PathFindMo
  0022f	8a 5d f4	 mov	 bl, BYTE PTR _bPath$[ebp]
  00232	8b bd 54 ff ff
	ff		 mov	 edi, DWORD PTR _sy$158438[ebp]
$LN17@PathFindMo:

; 1744 : 			}
; 1745 : 		}
; 1746 : 
; 1747 : 		lpObj->Dir = bPath[0] >> 4;
; 1748 : 		lpObj->PathCount = bPath[0] & 0x0F;

  00238	0f b6 cb	 movzx	 ecx, bl
  0023b	8a c3		 mov	 al, bl
  0023d	c0 e8 04	 shr	 al, 4
  00240	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00243	88 86 08 01 00
	00		 mov	 BYTE PTR [esi+264], al
  00249	89 8e 28 01 00
	00		 mov	 DWORD PTR [esi+296], ecx

; 1749 : 		lpObj->PathCur = 1;

  0024f	c7 86 2c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+300], 1

; 1750 : 		lpObj->PathTime = GetTickCount();

  00259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0025f	89 86 9c 01 00
	00		 mov	 DWORD PTR [esi+412], eax

; 1751 : 		bPath[0] &= 0x0F;
; 1752 : 		bPath[0] |= pos*16;

  00265	8a 85 63 ff ff
	ff		 mov	 al, BYTE PTR _pos$158439[ebp]
  0026b	c0 e0 04	 shl	 al, 4
  0026e	80 e3 0f	 and	 bl, 15			; 0000000fH
  00271	0a d8		 or	 bl, al

; 1753 : 		memcpy(pMove.Path, bPath, sizeof(pMove.Path));
; 1754 : 
; 1755 : 		if ( lpObj->PathCount > 0 )

  00273	83 be 28 01 00
	00 00		 cmp	 DWORD PTR [esi+296], 0
  0027a	8b 45 f8	 mov	 eax, DWORD PTR _bPath$[ebp+4]
  0027d	88 5d f4	 mov	 BYTE PTR _bPath$[ebp], bl
  00280	8b 55 f4	 mov	 edx, DWORD PTR _bPath$[ebp]
  00283	89 55 e9	 mov	 DWORD PTR _pMove$[ebp+5], edx
  00286	89 45 ed	 mov	 DWORD PTR _pMove$[ebp+9], eax
  00289	7e 56		 jle	 SHORT $LN1@PathFindMo

; 1756 : 		{
; 1757 : 			MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  0028b	0f bf 8e 1e 01
	00 00		 movsx	 ecx, WORD PTR [esi+286]
  00292	0f bf 96 1c 01
	00 00		 movsx	 edx, WORD PTR [esi+284]
  00299	51		 push	 ecx
  0029a	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  002a1	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  002a7	52		 push	 edx
  002a8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  002ae	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 1758 : 			MapC[lpObj->MapNumber].SetStandAttr(sx, sy);

  002b3	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  002ba	8b 9d 5c ff ff
	ff		 mov	 ebx, DWORD PTR _sx$158437[ebp]
  002c0	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  002c6	57		 push	 edi
  002c7	53		 push	 ebx
  002c8	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  002ce	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 1759 : 			lpObj->m_OldX = sx;

  002d3	66 89 9e 1c 01
	00 00		 mov	 WORD PTR [esi+284], bx

; 1760 : 			lpObj->m_OldY = sy;

  002da	66 89 be 1e 01
	00 00		 mov	 WORD PTR [esi+286], di
$LN1@PathFindMo:

; 1761 : 		}
; 1762 : 
; 1763 : 		PMoveProc(&pMove, lpObj->m_Index);

  002e1	8b 06		 mov	 eax, DWORD PTR [esi]
  002e3	50		 push	 eax
  002e4	8d 4d e4	 lea	 ecx, DWORD PTR _pMove$[ebp]
  002e7	51		 push	 ecx
  002e8	e8 00 00 00 00	 call	 ?PMoveProc@@YAXPAUPMSG_MOVE@@H@Z ; PMoveProc
  002ed	83 c4 08	 add	 esp, 8
  002f0	5f		 pop	 edi
  002f1	5b		 pop	 ebx

; 1764 : 		return TRUE;

  002f2	b8 01 00 00 00	 mov	 eax, 1
  002f7	5e		 pop	 esi

; 1765 : 	}
; 1766 : 
; 1767 : 	return FALSE;
; 1768 : }

  002f8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fb	33 cd		 xor	 ecx, ebp
  002fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c3		 ret	 0
$LN7@PathFindMo:
  00306	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00309	33 cd		 xor	 ecx, ebp
  0030b	33 c0		 xor	 eax, eax
  0030d	5e		 pop	 esi
  0030e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00313	8b e5		 mov	 esp, ebp
  00315	5d		 pop	 ebp
  00316	c3		 ret	 0
?PathFindMoveMsgSend@@YAHPAUOBJECTSTRUCT@@@Z ENDP	; PathFindMoveMsgSend
_TEXT	ENDS
PUBLIC	?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z	; gObjMonsterMoveAction
EXTRN	_rand:PROC
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc8H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN14@gObjMonste@11
	DD	FLAT:$LN15@gObjMonste@11
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_searchc$ = -40						; size = 4
_mchk$158460 = -36					; size = 4
_maxmoverange$ = -32					; size = 4
_tpy$ = -26						; size = 1
_tpx$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterMoveAction, COMDAT

; 1773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 18	 sub	 esp, 24			; 00000018H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 1774 : 	if ( lpObj->m_SkillHarden )

  00033	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00036	83 be 98 02 00
	00 00		 cmp	 DWORD PTR [esi+664], 0
  0003d	0f 85 61 01 00
	00		 jne	 $LN7@gObjMonste@11

; 1775 : 		return;
; 1776 : 
; 1777 : 	if ( lpObj->m_iSkillStunTime >0 )

  00043	83 be dc 14 00
	00 00		 cmp	 DWORD PTR [esi+5340], 0
  0004a	0f 8f 54 01 00
	00		 jg	 $LN7@gObjMonste@11

; 1778 : 		return;
; 1779 : 
; 1780 : 	int maxmoverange = lpObj->m_MoveRange*2+1;

  00050	0f bf 86 1e 03
	00 00		 movsx	 eax, WORD PTR [esi+798]
  00057	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  0005b	89 4d e0	 mov	 DWORD PTR _maxmoverange$[ebp], ecx

; 1781 : 	int searchc=10;

  0005e	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH

; 1782 : 	lpObj->NextActionTime = 1000;

  00063	c7 86 1c 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+540], 1000 ; 000003e8H
  0006d	eb 04		 jmp	 SHORT $LN8@gObjMonste@11
  0006f	90		 npad	 1
$LL19@gObjMonste@11:
  00070	8b 45 d8	 mov	 eax, DWORD PTR _searchc$[ebp]
$LN8@gObjMonste@11:

; 1783 : 	BYTE tpx;
; 1784 : 	BYTE tpy;
; 1785 : 
; 1786 : 	while ( searchc-- != 0 )

  00073	8b d0		 mov	 edx, eax
  00075	48		 dec	 eax
  00076	89 45 d8	 mov	 DWORD PTR _searchc$[ebp], eax
  00079	85 d2		 test	 edx, edx
  0007b	0f 84 23 01 00
	00		 je	 $LN7@gObjMonste@11

; 1787 : 	{
; 1788 : 		__try

  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 1789 : 		{
; 1790 : 			tpx = (lpObj->X - lpObj->m_MoveRange) + (rand()%maxmoverange);

  00088	e8 00 00 00 00	 call	 _rand
  0008d	8b 4d e0	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  00090	99		 cdq
  00091	f7 f9		 idiv	 ecx
  00093	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  0009a	03 d0		 add	 edx, eax
  0009c	0f bf 8e 1e 03
	00 00		 movsx	 ecx, WORD PTR [esi+798]
  000a3	2b d1		 sub	 edx, ecx
  000a5	88 55 e7	 mov	 BYTE PTR _tpx$[ebp], dl

; 1791 : 			tpy = (lpObj->Y - lpObj->m_MoveRange) + (rand()%maxmoverange);

  000a8	e8 00 00 00 00	 call	 _rand
  000ad	8b 4d e0	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  000b0	99		 cdq
  000b1	f7 f9		 idiv	 ecx
  000b3	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  000ba	03 d0		 add	 edx, eax
  000bc	0f bf 8e 1e 03
	00 00		 movsx	 ecx, WORD PTR [esi+798]
  000c3	2b d1		 sub	 edx, ecx
  000c5	88 55 e6	 mov	 BYTE PTR _tpy$[ebp], dl

; 1792 : 		}

  000c8	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000cf	eb 16		 jmp	 SHORT $LN17@gObjMonste@11
$LN14@gObjMonste@11:
$LN23@gObjMonste@11:

; 1793 : 		__except(maxmoverange=1, 1)

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	89 45 e0	 mov	 DWORD PTR _maxmoverange$[ebp], eax
$LN21@gObjMonste@11:
$LN16@gObjMonste@11:
  000d9	c3		 ret	 0
$LN15@gObjMonste@11:
  000da	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1794 : 		{
; 1795 : 
; 1796 : 		}

  000dd	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000e4	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
$LN17@gObjMonste@11:

; 1797 : 
; 1798 : 		int mchk = gObjMonsterMoveCheck(lpObj, tpx, tpy);

  000e7	0f b6 7d e6	 movzx	 edi, BYTE PTR _tpy$[ebp]
  000eb	0f b6 5d e7	 movzx	 ebx, BYTE PTR _tpx$[ebp]
  000ef	57		 push	 edi
  000f0	53		 push	 ebx
  000f1	56		 push	 esi
  000f2	e8 00 00 00 00	 call	 ?gObjMonsterMoveCheck@@YAHPAUOBJECTSTRUCT@@HH@Z ; gObjMonsterMoveCheck
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fa	89 45 dc	 mov	 DWORD PTR _mchk$158460[ebp], eax

; 1799 : 		BYTE attr = MapC[lpObj->MapNumber].GetAttr(tpx, tpy);

  000fd	57		 push	 edi
  000fe	53		 push	 ebx
  000ff	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00106	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0010c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00112	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 1800 : 
; 1801 : 		if ( (lpObj->Class ==249 || lpObj->Class == 247) && mchk )	// Guard

  00117	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  0011e	ba f9 00 00 00	 mov	 edx, 249		; 000000f9H
  00123	66 3b ca	 cmp	 cx, dx
  00126	74 0a		 je	 SHORT $LN4@gObjMonste@11
  00128	ba f7 00 00 00	 mov	 edx, 247		; 000000f7H
  0012d	66 3b ca	 cmp	 cx, dx
  00130	75 21		 jne	 SHORT $LN5@gObjMonste@11
$LN4@gObjMonste@11:
  00132	83 7d dc 00	 cmp	 DWORD PTR _mchk$158460[ebp], 0
  00136	74 1b		 je	 SHORT $LN5@gObjMonste@11

; 1802 : 		{
; 1803 : 			if ( (attr&2)!=2)

  00138	a8 02		 test	 al, 2
  0013a	0f 85 30 ff ff
	ff		 jne	 $LL19@gObjMonste@11

; 1804 : 			{
; 1805 : 				lpObj->MTX = tpx;
; 1806 : 				lpObj->MTY = tpy;
; 1807 : 				lpObj->m_ActState.Move = 1;

  00140	83 8e b4 01 00
	00 04		 or	 DWORD PTR [esi+436], 4

; 1808 : 				lpObj->NextActionTime = 3000;

  00147	c7 86 1c 02 00
	00 b8 0b 00 00	 mov	 DWORD PTR [esi+540], 3000 ; 00000bb8H

; 1809 : 				return;

  00151	eb 3b		 jmp	 SHORT $LN22@gObjMonste@11
$LN5@gObjMonste@11:

; 1810 : 			}
; 1811 : 		}
; 1812 : 		else
; 1813 : 		{
; 1814 : 			if ( (attr&1)!=1 && (attr&2)!=2 && (attr&4)!=4 && (attr&8)!= 8 && mchk )

  00153	a8 0f		 test	 al, 15			; 0000000fH
  00155	0f 85 15 ff ff
	ff		 jne	 $LL19@gObjMonste@11
  0015b	83 7d dc 00	 cmp	 DWORD PTR _mchk$158460[ebp], 0
  0015f	0f 84 0b ff ff
	ff		 je	 $LL19@gObjMonste@11

; 1815 : 			{
; 1816 : 				lpObj->TargetNumber = -1;

  00165	83 ca ff	 or	 edx, -1
  00168	66 89 96 d4 02
	00 00		 mov	 WORD PTR [esi+724], dx

; 1817 : 				lpObj->m_ActState.Attack = 0;
; 1818 : 				lpObj->NextActionTime = 500;

  0016f	c7 86 1c 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [esi+540], 500 ; 000001f4H

; 1819 : 				lpObj->m_ActState.Emotion = 0;

  00179	8b 96 b4 01 00
	00		 mov	 edx, DWORD PTR [esi+436]
  0017f	81 e2 0d ff ff
	ff		 and	 edx, -243		; ffffff0dH

; 1822 : 				lpObj->m_ActState.Move = 1;

  00185	83 ca 04	 or	 edx, 4
  00188	89 96 b4 01 00
	00		 mov	 DWORD PTR [esi+436], edx
$LN22@gObjMonste@11:

; 1821 : 				lpObj->MTY = tpy;

  0018e	0f b6 4d e6	 movzx	 ecx, BYTE PTR _tpy$[ebp]

; 1820 : 				lpObj->MTX = tpx;

  00192	0f b6 45 e7	 movzx	 eax, BYTE PTR _tpx$[ebp]

; 1821 : 				lpObj->MTY = tpy;

  00196	66 89 8e 26 01
	00 00		 mov	 WORD PTR [esi+294], cx

; 1820 : 				lpObj->MTX = tpx;

  0019d	66 89 86 24 01
	00 00		 mov	 WORD PTR [esi+292], ax
$LN7@gObjMonste@11:

; 1823 : 				return;
; 1824 : 			}
; 1825 : 		}
; 1826 : 	}
; 1827 : }

  001a4	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ae	59		 pop	 ecx
  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c3		 ret	 0
?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterMoveAction
_TEXT	ENDS
PUBLIC	?gObjMonsterBaseAct@@YAXPAUOBJECTSTRUCT@@@Z	; gObjMonsterBaseAct
EXTRN	?CheckWall@MapClass@@QAEHHHHH@Z:PROC		; MapClass::CheckWall
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z:PROC	; ChatSend
EXTRN	?gServerInfo@@3VCServerInfo@@A:BYTE		; gServerInfo
EXTRN	?gEvent1@@3HA:DWORD				; gEvent1
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterBaseAct@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ty$158484 = -4						; size = 4
_lpTargetObj$ = -4					; size = 4
_tx$158483 = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterBaseAct@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterBaseAct, COMDAT

; 1830 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1831 : 	LPOBJ lpTargetObj = NULL;
; 1832 : 
; 1833 : 	if ( lpObj->TargetNumber >= 0 )

  00006	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00009	0f b7 96 d4 02
	00 00		 movzx	 edx, WORD PTR [esi+724]
  00010	57		 push	 edi
  00011	33 db		 xor	 ebx, ebx
  00013	33 ff		 xor	 edi, edi
  00015	89 7d fc	 mov	 DWORD PTR _lpTargetObj$[ebp], edi
  00018	66 3b d3	 cmp	 dx, bx
  0001b	7c 15		 jl	 SHORT $LN56@gObjMonste@12

; 1834 : 		lpTargetObj = &gObj[lpObj->TargetNumber];

  0001d	0f bf c2	 movsx	 eax, dx
  00020	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00026	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002b	89 45 fc	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 1835 : 	else

  0002e	8b f8		 mov	 edi, eax
  00030	eb 0a		 jmp	 SHORT $LN55@gObjMonste@12
$LN56@gObjMonste@12:

; 1836 : 		lpObj->m_ActState.Emotion = 0;

  00032	81 a6 b4 01 00
	00 0f ff ff ff	 and	 DWORD PTR [esi+436], -241 ; ffffff0fH
$LN55@gObjMonste@12:

; 1837 : 
; 1838 : 	if ( lpObj->m_ActState.Emotion == 0 )

  0003c	8b 86 b4 01 00
	00		 mov	 eax, DWORD PTR [esi+436]
  00042	8b c8		 mov	 ecx, eax
  00044	c1 e9 04	 shr	 ecx, 4
  00047	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0004a	0f 85 e5 01 00
	00		 jne	 $LN54@gObjMonste@12

; 1839 : 	{
; 1840 : 		if ( lpObj->m_Attribute )

  00050	66 39 9e 26 03
	00 00		 cmp	 WORD PTR [esi+806], bx
  00057	0f 84 57 05 00
	00		 je	 $LN3@gObjMonste@12

; 1841 : 		{
; 1842 : 			if ( lpObj->m_ActState.Attack )

  0005d	bf f4 01 00 00	 mov	 edi, 500		; 000001f4H
  00062	a8 02		 test	 al, 2
  00064	74 19		 je	 SHORT $LN61@gObjMonste@12

; 1843 : 			{
; 1844 : 				lpObj->m_ActState.Attack = 0;

  00066	83 e0 fd	 and	 eax, -3			; fffffffdH
  00069	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax

; 1845 : 				lpObj->TargetNumber = -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax

; 1846 : 				lpObj->NextActionTime = 500;

  00079	89 be 1c 02 00
	00		 mov	 DWORD PTR [esi+540], edi
$LN61@gObjMonste@12:

; 1847 : 			}
; 1848 : 
; 1849 : 			int actcode1 = rand()%2;

  0007f	e8 00 00 00 00	 call	 _rand
  00084	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00089	79 05		 jns	 SHORT $LN65@gObjMonste@12
  0008b	48		 dec	 eax
  0008c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0008f	40		 inc	 eax
$LN65@gObjMonste@12:

; 1850 : 
; 1851 : 			if ( lpObj->m_Attribute == 100 )

  00090	0f b7 8e 26 03
	00 00		 movzx	 ecx, WORD PTR [esi+806]
  00097	66 83 f9 64	 cmp	 cx, 100			; 00000064H

; 1852 : 				actcode1 = 1;
; 1853 : 			
; 1854 : 			if ( actcode1 == 0 )

  0009b	74 16		 je	 SHORT $LN50@gObjMonste@12
  0009d	3b c3		 cmp	 eax, ebx
  0009f	75 12		 jne	 SHORT $LN50@gObjMonste@12

; 1855 : 			{
; 1856 : 				lpObj->m_ActState.Rest = 1;

  000a1	83 8e b4 01 00
	00 01		 or	 DWORD PTR [esi+436], 1

; 1857 : 				lpObj->NextActionTime = 500;

  000a8	89 be 1c 02 00
	00		 mov	 DWORD PTR [esi+540], edi
  000ae	e9 aa 00 00 00	 jmp	 $LN63@gObjMonste@12
$LN50@gObjMonste@12:

; 1858 : 			}
; 1859 : 			else if ( lpObj->m_MoveRange > 0 && !lpObj->m_SkillHarden && !lpObj->m_iSkillStunTime )

  000b3	66 39 9e 1e 03
	00 00		 cmp	 WORD PTR [esi+798], bx
  000ba	0f 8e 9d 00 00
	00		 jle	 $LN63@gObjMonste@12
  000c0	39 9e 98 02 00
	00		 cmp	 DWORD PTR [esi+664], ebx
  000c6	0f 85 91 00 00
	00		 jne	 $LN63@gObjMonste@12
  000cc	39 9e dc 14 00
	00		 cmp	 DWORD PTR [esi+5340], ebx
  000d2	0f 85 85 00 00
	00		 jne	 $LN63@gObjMonste@12

; 1860 : 			{
; 1861 : 				if ( lpObj->m_Attribute != 100 )

  000d8	66 83 f9 64	 cmp	 cx, 100			; 00000064H
  000dc	74 0b		 je	 SHORT $LN47@gObjMonste@12

; 1862 : 				{
; 1863 : 					gObjMonsterMoveAction(lpObj);

  000de	56		 push	 esi
  000df	e8 00 00 00 00	 call	 ?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterMoveAction
  000e4	83 c4 04	 add	 esp, 4

; 1864 : 				}
; 1865 : 				else

  000e7	eb 74		 jmp	 SHORT $LN63@gObjMonste@12
$LN47@gObjMonste@12:

; 1866 : 				{
; 1867 : 					int tx=0;
; 1868 : 					int ty=0;
; 1869 : 
; 1870 : 					if ( lpObj->m_RecallMon >= 0 )

  000e9	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR [esi+716]
  000ef	89 5d 08	 mov	 DWORD PTR _tx$158483[ebp], ebx
  000f2	89 5d fc	 mov	 DWORD PTR _ty$158484[ebp], ebx
  000f5	3b c3		 cmp	 eax, ebx
  000f7	7c 64		 jl	 SHORT $LN63@gObjMonste@12

; 1871 : 					{
; 1872 : 						if ( gObj[lpObj->m_RecallMon].Connected > PLAYER_LOGGED )

  000f9	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000ff	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00106	76 55		 jbe	 SHORT $LN63@gObjMonste@12

; 1873 : 						{
; 1874 : 							LPOBJ lpRecallObj = &gObj[lpObj->m_RecallMon];
; 1875 : 
; 1876 : 							if ( lpRecallObj->m_Rest == FALSE )

  00108	38 98 c1 01 00
	00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+449], bl
  0010e	75 4d		 jne	 SHORT $LN63@gObjMonste@12

; 1877 : 							{
; 1878 : 								if ( gObjGetTargetPos(lpObj, lpRecallObj->X, lpRecallObj->Y, tx, ty) == TRUE )

  00110	8d 4d fc	 lea	 ecx, DWORD PTR _ty$158484[ebp]
  00113	51		 push	 ecx
  00114	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  0011b	8d 55 08	 lea	 edx, DWORD PTR _tx$158483[ebp]
  0011e	52		 push	 edx
  0011f	0f bf 90 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00126	51		 push	 ecx
  00127	52		 push	 edx
  00128	56		 push	 esi
  00129	e8 00 00 00 00	 call	 ?gObjGetTargetPos@@YAHPAUOBJECTSTRUCT@@HHAAH1@Z ; gObjGetTargetPos
  0012e	83 c4 14	 add	 esp, 20			; 00000014H
  00131	83 f8 01	 cmp	 eax, 1
  00134	75 27		 jne	 SHORT $LN63@gObjMonste@12

; 1879 : 								{
; 1880 : 									lpObj->MTX = tx;

  00136	66 8b 45 08	 mov	 ax, WORD PTR _tx$158483[ebp]

; 1881 : 									lpObj->MTY = ty;

  0013a	66 8b 4d fc	 mov	 cx, WORD PTR _ty$158484[ebp]

; 1882 : 									lpObj->m_ActState.Move = 1;

  0013e	83 8e b4 01 00
	00 04		 or	 DWORD PTR [esi+436], 4
  00145	66 89 86 24 01
	00 00		 mov	 WORD PTR [esi+292], ax
  0014c	66 89 8e 26 01
	00 00		 mov	 WORD PTR [esi+294], cx

; 1883 : 									lpObj->NextActionTime = 1000;

  00153	c7 86 1c 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+540], 1000 ; 000003e8H
$LN63@gObjMonste@12:

; 1884 : 								}
; 1885 : 							}
; 1886 : 						}
; 1887 : 					}
; 1888 : 				}
; 1889 : 			}
; 1890 : 
; 1891 : 			if (lpObj->Class == 249 || lpObj->Class == 247 )	// Guard

  0015d	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00164	ba f9 00 00 00	 mov	 edx, 249		; 000000f9H
  00169	66 3b c2	 cmp	 ax, dx
  0016c	74 2c		 je	 SHORT $LN40@gObjMonste@12
  0016e	b9 f7 00 00 00	 mov	 ecx, 247		; 000000f7H
  00173	66 3b c1	 cmp	 ax, cx
  00176	74 22		 je	 SHORT $LN40@gObjMonste@12

; 1912 : 					}
; 1913 : 				}
; 1914 : 			}
; 1915 : 			else 
; 1916 : 			{
; 1917 : 				if ( lpObj->m_Attribute == 100 )

  00178	66 83 be 26 03
	00 00 64	 cmp	 WORD PTR [esi+806], 100	; 00000064H
  00180	75 04		 jne	 SHORT $LN33@gObjMonste@12

; 1918 : 					lpObj->TargetNumber = gObjMonsterSearchEnemy(lpObj, OBJ_MONSTER);

  00182	6a 02		 push	 2

; 1919 : 				else

  00184	eb 02		 jmp	 SHORT $LN66@gObjMonste@12
$LN33@gObjMonste@12:

; 1920 : 					lpObj->TargetNumber = gObjMonsterSearchEnemy(lpObj, OBJ_USER);

  00186	6a 01		 push	 1
$LN66@gObjMonste@12:
  00188	56		 push	 esi
  00189	e8 00 00 00 00	 call	 ?gObjMonsterSearchEnemy@@YAHPAUOBJECTSTRUCT@@E@Z ; gObjMonsterSearchEnemy
  0018e	83 c4 08	 add	 esp, 8
  00191	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax
  00198	eb 6b		 jmp	 SHORT $LN35@gObjMonste@12
$LN40@gObjMonste@12:

; 1892 : 			{
; 1893 : 				if ( gEvent1 )

  0019a	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?gEvent1@@3HA, ebx ; gEvent1
  001a0	74 2d		 je	 SHORT $LN37@gObjMonste@12

; 1894 : 				{
; 1895 : 					if ( !(rand()%30) )

  001a2	e8 00 00 00 00	 call	 _rand
  001a7	99		 cdq
  001a8	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  001ad	f7 f9		 idiv	 ecx
  001af	85 d2		 test	 edx, edx
  001b1	75 1c		 jne	 SHORT $LN37@gObjMonste@12

; 1896 : 					{
; 1897 : 						if ( lpObj->m_PK_Count == 0 )

  001b3	38 9e fc 00 00
	00		 cmp	 BYTE PTR [esi+252], bl
  001b9	75 14		 jne	 SHORT $LN37@gObjMonste@12

; 1898 : 						{
; 1899 : 							ChatSend(lpObj, gServerInfo.m_Data.szGuardTalk);

  001bb	68 32 00 00 00	 push	 OFFSET ?gServerInfo@@3VCServerInfo@@A+50
  001c0	56		 push	 esi
  001c1	e8 00 00 00 00	 call	 ?ChatSend@@YAXPAUOBJECTSTRUCT@@PAD@Z ; ChatSend
  001c6	83 c4 08	 add	 esp, 8

; 1900 : 							lpObj->m_PK_Count = 0;

  001c9	88 9e fc 00 00
	00		 mov	 BYTE PTR [esi+252], bl
$LN37@gObjMonste@12:

; 1901 : 						}
; 1902 : 					}
; 1903 : 				}
; 1904 : 
; 1905 : 				lpObj->TargetNumber = gObjGuardSearchEnemy(lpObj);

  001cf	56		 push	 esi
  001d0	e8 00 00 00 00	 call	 ?gObjGuardSearchEnemy@@YAHPAUOBJECTSTRUCT@@@Z ; gObjGuardSearchEnemy
  001d5	83 c4 04	 add	 esp, 4
  001d8	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax

; 1906 : 
; 1907 : 				if ( lpObj->TargetNumber >= 0 )

  001df	66 3b c3	 cmp	 ax, bx
  001e2	7c 21		 jl	 SHORT $LN35@gObjMonste@12

; 1908 : 				{
; 1909 : 					if ( gObj[lpObj->TargetNumber].Class >= 248 )

  001e4	0f bf d0	 movsx	 edx, ax
  001e7	69 d2 64 15 00
	00		 imul	 edx, 5476		; 00001564H
  001ed	b8 f8 00 00 00	 mov	 eax, 248		; 000000f8H
  001f2	66 39 82 98 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edx+152], ax
  001f9	72 0a		 jb	 SHORT $LN35@gObjMonste@12

; 1910 : 					{
; 1911 : 						lpObj->TargetNumber = -1;

  001fb	83 c9 ff	 or	 ecx, -1
  001fe	66 89 8e d4 02
	00 00		 mov	 WORD PTR [esi+724], cx
$LN35@gObjMonste@12:

; 1921 : 			}
; 1922 : 
; 1923 : 			if ( lpObj->TargetNumber >= 0 )

  00205	66 39 9e d4 02
	00 00		 cmp	 WORD PTR [esi+724], bx
  0020c	0f 8c a2 03 00
	00		 jl	 $LN3@gObjMonste@12

; 1924 : 			{
; 1925 : 				lpObj->m_ActState.EmotionCount = 30;

  00212	c6 86 b5 01 00
	00 1e		 mov	 BYTE PTR [esi+437], 30	; 0000001eH

; 1926 : 				lpObj->m_ActState.Emotion = 1;

  00219	8b 96 b4 01 00
	00		 mov	 edx, DWORD PTR [esi+436]
  0021f	81 e2 1f ff ff
	ff		 and	 edx, -225		; ffffff1fH
  00225	83 ca 10	 or	 edx, 16			; 00000010H
  00228	5f		 pop	 edi
  00229	89 96 b4 01 00
	00		 mov	 DWORD PTR [esi+436], edx
  0022f	5e		 pop	 esi
  00230	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c3		 ret	 0
$LN54@gObjMonste@12:

; 1927 : 			}
; 1928 : 		}
; 1929 : 	}
; 1930 : 	else if ( lpObj->m_ActState.Emotion == 1 )

  00235	83 f9 01	 cmp	 ecx, 1
  00238	0f 85 8e 02 00
	00		 jne	 $LN29@gObjMonste@12

; 1931 : 	{
; 1932 : 		if ( lpObj->m_ActState.EmotionCount > 0 )

  0023e	8a 8e b5 01 00
	00		 mov	 cl, BYTE PTR [esi+437]
  00244	3a cb		 cmp	 cl, bl
  00246	76 0a		 jbe	 SHORT $LN28@gObjMonste@12

; 1933 : 		{
; 1934 : 			lpObj->m_ActState.EmotionCount--;

  00248	fe c9		 dec	 cl
  0024a	88 8e b5 01 00
	00		 mov	 BYTE PTR [esi+437], cl

; 1935 : 		}
; 1936 : 		else

  00250	eb 0b		 jmp	 SHORT $LN27@gObjMonste@12
$LN28@gObjMonste@12:

; 1937 : 		{
; 1938 : 			lpObj->m_ActState.Emotion = 0;

  00252	25 0f ff ff ff	 and	 eax, -241		; ffffff0fH
  00257	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax
$LN27@gObjMonste@12:

; 1939 : 		}
; 1940 : 
; 1941 : 		if ( lpObj->TargetNumber >= 0 && lpObj->PathStartEnd == 0)

  0025d	66 3b d3	 cmp	 dx, bx
  00260	0f 8c 4e 03 00
	00		 jl	 $LN3@gObjMonste@12
  00266	38 9e 30 01 00
	00		 cmp	 BYTE PTR [esi+304], bl
  0026c	0f 85 42 03 00
	00		 jne	 $LN3@gObjMonste@12

; 1942 : 		{
; 1943 : 			if ( BC_MAP_RANGE(lpObj->MapNumber) )

  00272	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00279	3c 0b		 cmp	 al, 11			; 0000000bH
  0027b	72 76		 jb	 SHORT $LN64@gObjMonste@12
  0027d	b1 11		 mov	 cl, 17			; 00000011H
  0027f	3a c8		 cmp	 cl, al
  00281	1b c0		 sbb	 eax, eax
  00283	40		 inc	 eax
  00284	3b c3		 cmp	 eax, ebx
  00286	74 6b		 je	 SHORT $LN64@gObjMonste@12

; 1944 : 			{
; 1945 : 				int iRAND_CHANGE_TARGET = rand()%10;

  00288	e8 00 00 00 00	 call	 _rand
  0028d	99		 cdq
  0028e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00293	f7 f9		 idiv	 ecx

; 1946 : 
; 1947 : 				if ( iRAND_CHANGE_TARGET == 3 )

  00295	83 fa 03	 cmp	 edx, 3
  00298	75 0c		 jne	 SHORT $LN24@gObjMonste@12

; 1948 : 					lpObj->LastAttackerID = -1;

  0029a	83 ca ff	 or	 edx, -1
  0029d	66 89 96 da 02
	00 00		 mov	 WORD PTR [esi+730], dx

; 1949 : 
; 1950 : 				if ( iRAND_CHANGE_TARGET == 1 )

  002a4	eb 4d		 jmp	 SHORT $LN64@gObjMonste@12
$LN24@gObjMonste@12:
  002a6	83 fa 01	 cmp	 edx, 1
  002a9	75 48		 jne	 SHORT $LN64@gObjMonste@12

; 1951 : 				{
; 1952 : 					if ( lpObj->LastAttackerID != -1 && lpObj->LastAttackerID != lpObj->TargetNumber )

  002ab	0f b7 8e da 02
	00 00		 movzx	 ecx, WORD PTR [esi+730]
  002b2	66 83 f9 ff	 cmp	 cx, -1
  002b6	74 3b		 je	 SHORT $LN64@gObjMonste@12
  002b8	66 3b 8e d4 02
	00 00		 cmp	 cx, WORD PTR [esi+724]
  002bf	74 32		 je	 SHORT $LN64@gObjMonste@12

; 1953 : 					{
; 1954 : 						if ( gObj[lpObj->LastAttackerID].Connected > PLAYER_LOGGED &&
; 1955 : 							lpObj->MapNumber == gObj[lpObj->LastAttackerID].MapNumber )

  002c1	0f bf c1	 movsx	 eax, cx
  002c4	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  002ca	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  002d1	76 20		 jbe	 SHORT $LN64@gObjMonste@12
  002d3	8a 96 09 01 00
	00		 mov	 dl, BYTE PTR [esi+265]
  002d9	3a 90 09 01 00
	00		 cmp	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  002df	75 12		 jne	 SHORT $LN64@gObjMonste@12

; 1956 : 						{
; 1957 : 							lpObj->TargetNumber = lpObj->LastAttackerID;
; 1958 : 							lpTargetObj = &gObj[lpObj->LastAttackerID];

  002e1	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  002e7	66 89 8e d4 02
	00 00		 mov	 WORD PTR [esi+724], cx
  002ee	89 45 fc	 mov	 DWORD PTR _lpTargetObj$[ebp], eax
  002f1	8b f8		 mov	 edi, eax
$LN64@gObjMonste@12:

; 1959 : 						}
; 1960 : 					}
; 1961 : 				}
; 1962 : 			}
; 1963 : 
; 1964 : 			int dis = gObjCalDistance(lpObj, lpTargetObj);

  002f3	57		 push	 edi
  002f4	56		 push	 esi
  002f5	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance

; 1965 : 			int attackrange;
; 1966 : 
; 1967 : 			if ( lpObj->m_AttackType >= 100 )	// #warning Change this To Level
; 1968 : 				attackrange = lpObj->m_AttackRange+2;

  002fa	0f bf 8e 20 03
	00 00		 movsx	 ecx, WORD PTR [esi+800]
  00301	83 c4 08	 add	 esp, 8
  00304	66 83 be 22 03
	00 00 64	 cmp	 WORD PTR [esi+802], 100	; 00000064H
  0030c	7c 03		 jl	 SHORT $LN19@gObjMonste@12
  0030e	83 c1 02	 add	 ecx, 2
$LN19@gObjMonste@12:

; 1969 : 			else
; 1970 : 				attackrange = lpObj->m_AttackRange;
; 1971 : 
; 1972 : 			if ( dis <= attackrange )

  00311	3b c1		 cmp	 eax, ecx
  00313	0f 8f e0 00 00
	00		 jg	 $LN18@gObjMonste@12

; 1973 : 			{
; 1974 : 				int tuser = lpObj->TargetNumber;

  00319	0f bf be d4 02
	00 00		 movsx	 edi, WORD PTR [esi+724]

; 1975 : 				int map = gObj[tuser].MapNumber;

  00320	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00326	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]

; 1976 : 				BYTE attr;
; 1977 : 
; 1978 : 				if ( MapC[map].CheckWall(lpObj->X, lpObj->Y, gObj[tuser].X, gObj[tuser].Y) == TRUE )

  0032d	0f bf 8f 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00334	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  0033a	0f bf 97 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00341	51		 push	 ecx
  00342	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00349	8d 98 00 00 00
	00		 lea	 ebx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  0034f	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00356	52		 push	 edx
  00357	50		 push	 eax
  00358	51		 push	 ecx
  00359	8b cb		 mov	 ecx, ebx
  0035b	e8 00 00 00 00	 call	 ?CheckWall@MapClass@@QAEHHHHH@Z ; MapClass::CheckWall
  00360	83 f8 01	 cmp	 eax, 1
  00363	0f 85 4b 02 00
	00		 jne	 $LN3@gObjMonste@12

; 1979 : 				{
; 1980 : 					attr = MapC[map].GetAttr(gObj[tuser].X, gObj[tuser].Y);
; 1981 : 
; 1982 : 					if ( (attr&1) != 1 )

  00369	0f bf 97 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+262]
  00370	0f bf 87 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+260]
  00377	52		 push	 edx
  00378	50		 push	 eax
  00379	8b cb		 mov	 ecx, ebx
  0037b	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00380	a8 01		 test	 al, 1
  00382	75 09		 jne	 SHORT $LN16@gObjMonste@12

; 1983 : 					{
; 1984 : 						lpObj->m_ActState.Attack = 1;

  00384	83 8e b4 01 00
	00 02		 or	 DWORD PTR [esi+436], 2

; 1985 : 					}
; 1986 : 					else

  0038b	eb 26		 jmp	 SHORT $LN15@gObjMonste@12
$LN16@gObjMonste@12:

; 1987 : 					{
; 1988 : 						lpObj->TargetNumber = -1;
; 1989 : 						lpObj->m_ActState.EmotionCount = 30;

  0038d	c6 86 b5 01 00
	00 1e		 mov	 BYTE PTR [esi+437], 30	; 0000001eH

; 1990 : 						lpObj->m_ActState.Emotion = 1;

  00394	8b 96 b4 01 00
	00		 mov	 edx, DWORD PTR [esi+436]
  0039a	83 c9 ff	 or	 ecx, -1
  0039d	81 e2 1f ff ff
	ff		 and	 edx, -225		; ffffff1fH
  003a3	83 ca 10	 or	 edx, 16			; 00000010H
  003a6	66 89 8e d4 02
	00 00		 mov	 WORD PTR [esi+724], cx
  003ad	89 96 b4 01 00
	00		 mov	 DWORD PTR [esi+436], edx
$LN15@gObjMonste@12:

; 1991 : 					}
; 1992 : 
; 1993 : 					lpObj->Dir = GetPathPacketDirPos(lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y);

  003b3	8b 45 fc	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003b6	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  003bd	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  003c4	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR [eax+260]
  003cb	2b ca		 sub	 ecx, edx
  003cd	51		 push	 ecx
  003ce	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  003d5	2b c1		 sub	 eax, ecx
  003d7	50		 push	 eax
  003d8	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos

; 1994 : 					lpObj->NextActionTime = lpObj->m_AttackSpeed;

  003dd	8b 96 08 03 00
	00		 mov	 edx, DWORD PTR [esi+776]
  003e3	83 c4 08	 add	 esp, 8
  003e6	5f		 pop	 edi
  003e7	88 86 08 01 00
	00		 mov	 BYTE PTR [esi+264], al
  003ed	89 96 1c 02 00
	00		 mov	 DWORD PTR [esi+540], edx
  003f3	5e		 pop	 esi
  003f4	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  003f5	8b e5		 mov	 esp, ebp
  003f7	5d		 pop	 ebp
  003f8	c3		 ret	 0
$LN18@gObjMonste@12:

; 1995 : 				}
; 1996 : 			}
; 1997 : 			else
; 1998 : 			{
; 1999 : 				if ( gObjMonsterGetTargetPos(lpObj) == TRUE )

  003f9	56		 push	 esi
  003fa	e8 00 00 00 00	 call	 ?gObjMonsterGetTargetPos@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterGetTargetPos
  003ff	83 c4 04	 add	 esp, 4
  00402	83 f8 01	 cmp	 eax, 1
  00405	0f 85 b1 00 00
	00		 jne	 $LN13@gObjMonste@12

; 2000 : 				{
; 2001 : 					if ( MapC[lpObj->MapNumber].CheckWall(lpObj->X, lpObj->Y, lpObj->MTX, lpObj->MTY) == TRUE )

  0040b	0f bf 86 26 01
	00 00		 movsx	 eax, WORD PTR [esi+294]
  00412	0f bf 8e 24 01
	00 00		 movsx	 ecx, WORD PTR [esi+292]
  00419	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00420	50		 push	 eax
  00421	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  00428	51		 push	 ecx
  00429	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00430	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00436	52		 push	 edx
  00437	50		 push	 eax
  00438	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0043e	e8 00 00 00 00	 call	 ?CheckWall@MapClass@@QAEHHHHH@Z ; MapClass::CheckWall
  00443	83 f8 01	 cmp	 eax, 1
  00446	75 48		 jne	 SHORT $LN12@gObjMonste@12

; 2002 : 					{
; 2003 : 						lpObj->m_ActState.Move = 1;

  00448	83 8e b4 01 00
	00 04		 or	 DWORD PTR [esi+436], 4

; 2004 : 						lpObj->NextActionTime = 400;
; 2005 : 						lpObj->Dir = GetPathPacketDirPos(lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y);

  0044f	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00456	c7 86 1c 02 00
	00 90 01 00 00	 mov	 DWORD PTR [esi+540], 400 ; 00000190H
  00460	0f bf 8f 06 01
	00 00		 movsx	 ecx, WORD PTR [edi+262]
  00467	0f bf 87 04 01
	00 00		 movsx	 eax, WORD PTR [edi+260]
  0046e	2b ca		 sub	 ecx, edx
  00470	51		 push	 ecx
  00471	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  00478	2b c1		 sub	 eax, ecx
  0047a	50		 push	 eax
  0047b	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00480	83 c4 08	 add	 esp, 8
  00483	5f		 pop	 edi
  00484	88 86 08 01 00
	00		 mov	 BYTE PTR [esi+264], al
  0048a	5e		 pop	 esi
  0048b	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  0048c	8b e5		 mov	 esp, ebp
  0048e	5d		 pop	 ebp
  0048f	c3		 ret	 0
$LN12@gObjMonste@12:

; 2006 : 					}
; 2007 : 					else
; 2008 : 					{
; 2009 : 						gObjMonsterMoveAction(lpObj);

  00490	56		 push	 esi
  00491	e8 00 00 00 00	 call	 ?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterMoveAction

; 2010 : 						lpObj->m_ActState.Emotion = 3;

  00496	8b 96 b4 01 00
	00		 mov	 edx, DWORD PTR [esi+436]
  0049c	83 c4 04	 add	 esp, 4
  0049f	81 e2 3f ff ff
	ff		 and	 edx, -193		; ffffff3fH
  004a5	83 ca 30	 or	 edx, 48			; 00000030H
  004a8	89 96 b4 01 00
	00		 mov	 DWORD PTR [esi+436], edx
  004ae	5f		 pop	 edi

; 2011 : 						lpObj->m_ActState.EmotionCount = 10;

  004af	c6 86 b5 01 00
	00 0a		 mov	 BYTE PTR [esi+437], 10	; 0000000aH
  004b6	5e		 pop	 esi
  004b7	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  004b8	8b e5		 mov	 esp, ebp
  004ba	5d		 pop	 ebp
  004bb	c3		 ret	 0
$LN13@gObjMonste@12:

; 2012 : 
; 2013 : 					}
; 2014 : 				}
; 2015 : 				else
; 2016 : 				{
; 2017 : 					gObjMonsterMoveAction(lpObj);

  004bc	56		 push	 esi
  004bd	e8 00 00 00 00	 call	 ?gObjMonsterMoveAction@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterMoveAction
  004c2	83 c4 04	 add	 esp, 4
  004c5	5f		 pop	 edi
  004c6	5e		 pop	 esi
  004c7	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  004c8	8b e5		 mov	 esp, ebp
  004ca	5d		 pop	 ebp
  004cb	c3		 ret	 0
$LN29@gObjMonste@12:

; 2018 : 				}
; 2019 : 			}
; 2020 : 		}
; 2021 : 	}
; 2022 : 	else if ( lpObj->m_ActState.Emotion == 2 )

  004cc	83 f9 02	 cmp	 ecx, 2
  004cf	0f 85 aa 00 00
	00		 jne	 $LN8@gObjMonste@12

; 2023 : 	{
; 2024 : 		if ( lpObj->m_ActState.EmotionCount > 0 )

  004d5	8a 8e b5 01 00
	00		 mov	 cl, BYTE PTR [esi+437]
  004db	3a cb		 cmp	 cl, bl
  004dd	76 0a		 jbe	 SHORT $LN7@gObjMonste@12

; 2025 : 		{
; 2026 : 			lpObj->m_ActState.EmotionCount--;

  004df	fe c9		 dec	 cl
  004e1	88 8e b5 01 00
	00		 mov	 BYTE PTR [esi+437], cl

; 2027 : 		}
; 2028 : 		else

  004e7	eb 0b		 jmp	 SHORT $LN6@gObjMonste@12
$LN7@gObjMonste@12:

; 2029 : 		{
; 2030 : 			lpObj->m_ActState.Emotion = 0;

  004e9	25 0f ff ff ff	 and	 eax, -241		; ffffff0fH
  004ee	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax
$LN6@gObjMonste@12:

; 2031 : 		}
; 2032 : 
; 2033 : 		lpObj->m_ActState.Move = 1;

  004f4	83 8e b4 01 00
	00 04		 or	 DWORD PTR [esi+436], 4

; 2034 : 		lpObj->NextActionTime = 800;

  004fb	c7 86 1c 02 00
	00 20 03 00 00	 mov	 DWORD PTR [esi+540], 800 ; 00000320H

; 2035 : 
; 2036 : 		if ( lpTargetObj )

  00505	3b fb		 cmp	 edi, ebx
  00507	0f 84 a7 00 00
	00		 je	 $LN3@gObjMonste@12

; 2037 : 		{
; 2038 : 			int tdir = GetPathPacketDirPos(lpTargetObj->X-lpObj->X, lpTargetObj->Y-lpObj->Y)*2;

  0050d	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR [edi+262]
  00514	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  0051b	0f bf 97 04 01
	00 00		 movsx	 edx, WORD PTR [edi+260]
  00522	2b c1		 sub	 eax, ecx
  00524	50		 push	 eax
  00525	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  0052c	2b d0		 sub	 edx, eax
  0052e	52		 push	 edx
  0052f	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  00534	0f b6 c0	 movzx	 eax, al
  00537	03 c0		 add	 eax, eax

; 2039 : 			lpObj->MTX += RoadPathTable[tdir] * (-3);

  00539	66 8b 0c 45 00
	00 00 00	 mov	 cx, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  00541	66 8b d1	 mov	 dx, cx
  00544	66 03 d2	 add	 dx, dx
  00547	66 03 d2	 add	 dx, dx
  0054a	66 2b d1	 sub	 dx, cx
  0054d	66 f7 da	 neg	 dx
  00550	66 01 96 24 01
	00 00		 add	 WORD PTR [esi+292], dx

; 2040 : 			lpObj->MTY += RoadPathTable[tdir+1] * (-3);

  00557	66 8b 04 45 02
	00 00 00	 mov	 ax, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  0055f	66 8b c8	 mov	 cx, ax
  00562	66 03 c9	 add	 cx, cx
  00565	66 03 c9	 add	 cx, cx
  00568	83 c4 08	 add	 esp, 8
  0056b	66 2b c8	 sub	 cx, ax
  0056e	66 f7 d9	 neg	 cx
  00571	66 01 8e 26 01
	00 00		 add	 WORD PTR [esi+294], cx
  00578	5f		 pop	 edi
  00579	5e		 pop	 esi
  0057a	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  0057b	8b e5		 mov	 esp, ebp
  0057d	5d		 pop	 ebp
  0057e	c3		 ret	 0
$LN8@gObjMonste@12:

; 2041 : 		}
; 2042 : 	}
; 2043 : 	else if ( lpObj->m_ActState.Emotion == 3 )

  0057f	83 f9 03	 cmp	 ecx, 3
  00582	75 30		 jne	 SHORT $LN3@gObjMonste@12

; 2044 : 	{
; 2045 : 		if ( lpObj->m_ActState.EmotionCount > 0 )

  00584	8a 8e b5 01 00
	00		 mov	 cl, BYTE PTR [esi+437]
  0058a	3a cb		 cmp	 cl, bl
  0058c	76 0a		 jbe	 SHORT $LN2@gObjMonste@12

; 2046 : 		{
; 2047 : 			lpObj->m_ActState.EmotionCount--;

  0058e	fe c9		 dec	 cl
  00590	88 8e b5 01 00
	00		 mov	 BYTE PTR [esi+437], cl

; 2048 : 		}
; 2049 : 		else

  00596	eb 0b		 jmp	 SHORT $LN1@gObjMonste@12
$LN2@gObjMonste@12:

; 2050 : 		{
; 2051 : 			lpObj->m_ActState.Emotion = 0;

  00598	25 0f ff ff ff	 and	 eax, -241		; ffffff0fH
  0059d	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax
$LN1@gObjMonste@12:

; 2052 : 		}
; 2053 : 
; 2054 : 		lpObj->m_ActState.Move = 0;
; 2055 : 		lpObj->m_ActState.Attack = 0;

  005a3	83 a6 b4 01 00
	00 f9		 and	 DWORD PTR [esi+436], -7	; fffffff9H

; 2056 : 		lpObj->NextActionTime = 400;

  005aa	c7 86 1c 02 00
	00 90 01 00 00	 mov	 DWORD PTR [esi+540], 400 ; 00000190H
$LN3@gObjMonste@12:
  005b4	5f		 pop	 edi
  005b5	5e		 pop	 esi
  005b6	5b		 pop	 ebx

; 2057 : 	}
; 2058 : }

  005b7	8b e5		 mov	 esp, ebp
  005b9	5d		 pop	 ebp
  005ba	c3		 ret	 0
?gObjMonsterBaseAct@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterBaseAct
_TEXT	ENDS
PUBLIC	?gObjTrapAttackEnemySearchX@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchX
; Function compile flags: /Ogtp
;	COMDAT ?gObjTrapAttackEnemySearchX@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_y$ = -12						; size = 4
_n$158545 = -8						; size = 4
_pos$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_count$ = 12						; size = 4
?gObjTrapAttackEnemySearchX@@YAXPAUOBJECTSTRUCT@@H@Z PROC ; gObjTrapAttackEnemySearchX, COMDAT

; 2061 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2062 : 	lpObj->TargetNumber = -1;

  00006	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]

; 2063 : 	int tObjNum;
; 2064 : 	int pos = lpObj->X;

  00009	0f bf 8a 04 01
	00 00		 movsx	 ecx, WORD PTR [edx+260]
  00010	83 c8 ff	 or	 eax, -1

; 2065 : 	int y = lpObj->Y;
; 2066 : 
; 2067 : 	for(int n =0;n<count;n++)

  00013	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  00017	66 89 82 d4 02
	00 00		 mov	 WORD PTR [edx+724], ax
  0001e	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  00025	89 4d fc	 mov	 DWORD PTR _pos$[ebp], ecx
  00028	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$158545[ebp], 0
  00032	0f 8e 88 00 00
	00		 jle	 $LN10@gObjTrapAt
  00038	56		 push	 esi
  00039	57		 push	 edi
  0003a	bf 01 00 00 00	 mov	 edi, 1
  0003f	eb 03		 jmp	 SHORT $LN12@gObjTrapAt
$LL23@gObjTrapAt:
  00041	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
$LN12@gObjTrapAt:

; 2068 : 	{
; 2069 : 		pos++;

  00044	01 7d fc	 add	 DWORD PTR _pos$[ebp], edi

; 2070 : 		for(int i =0; i< MAX_VIEWPORT_MONSTER; i++)

  00047	33 c9		 xor	 ecx, ecx
  00049	81 c2 16 07 00
	00		 add	 edx, 1814		; 00000716H
  0004f	90		 npad	 1
$LL24@gObjTrapAt:

; 2071 : 		{
; 2072 : 			tObjNum = lpObj->VpPlayer2[i].number;

  00050	0f bf 32	 movsx	 esi, WORD PTR [edx]

; 2073 : 
; 2074 : 			if(tObjNum >= 0)

  00053	85 f6		 test	 esi, esi
  00055	78 3b		 js	 SHORT $LN8@gObjTrapAt

; 2075 : 			{
; 2076 : 				if(gObj[tObjNum].Type==OBJ_USER)

  00057	8b c6		 mov	 eax, esi
  00059	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005f	66 39 b8 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], di
  00066	75 2a		 jne	 SHORT $LN8@gObjTrapAt

; 2077 : 				{
; 2078 : 					if(gObj[tObjNum].Live)

  00068	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  0006f	74 21		 je	 SHORT $LN8@gObjTrapAt

; 2079 : 					{
; 2080 : 						if(y == gObj[tObjNum].Y)

  00071	0f bf b8 06 01
	00 00		 movsx	 edi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00078	39 7d f4	 cmp	 DWORD PTR _y$[ebp], edi
  0007b	75 15		 jne	 SHORT $LN8@gObjTrapAt

; 2081 : 						{
; 2082 : 							if(pos == gObj[tObjNum].X)

  0007d	0f bf b8 04 01
	00 00		 movsx	 edi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00084	39 7d fc	 cmp	 DWORD PTR _pos$[ebp], edi
  00087	75 09		 jne	 SHORT $LN8@gObjTrapAt

; 2083 : 							{
; 2084 : 								if((gObj[tObjNum].Authority&2)!=2)

  00089	f6 80 a4 01 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+420], 2
  00090	74 22		 je	 SHORT $LN17@gObjTrapAt
$LN8@gObjTrapAt:

; 2070 : 		for(int i =0; i< MAX_VIEWPORT_MONSTER; i++)

  00092	bf 01 00 00 00	 mov	 edi, 1
  00097	03 cf		 add	 ecx, edi
  00099	83 c2 0c	 add	 edx, 12			; 0000000cH
  0009c	83 f9 14	 cmp	 ecx, 20			; 00000014H
  0009f	7c af		 jl	 SHORT $LL24@gObjTrapAt

; 2065 : 	int y = lpObj->Y;
; 2066 : 
; 2067 : 	for(int n =0;n<count;n++)

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _n$158545[ebp]
  000a4	03 c7		 add	 eax, edi
  000a6	89 45 f8	 mov	 DWORD PTR _n$158545[ebp], eax
  000a9	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  000ac	7c 93		 jl	 SHORT $LL23@gObjTrapAt
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi

; 2087 : 									return;
; 2088 : 								}
; 2089 : 							}
; 2090 : 						}
; 2091 : 					}
; 2092 : 				}
; 2093 : 			}
; 2094 : 		}
; 2095 : 	}
; 2096 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN17@gObjTrapAt:

; 2085 : 								{
; 2086 : 									lpObj->TargetNumber = tObjNum;

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b7	5f		 pop	 edi
  000b8	66 89 b1 d4 02
	00 00		 mov	 WORD PTR [ecx+724], si
  000bf	5e		 pop	 esi
$LN10@gObjTrapAt:

; 2087 : 									return;
; 2088 : 								}
; 2089 : 							}
; 2090 : 						}
; 2091 : 					}
; 2092 : 				}
; 2093 : 			}
; 2094 : 		}
; 2095 : 	}
; 2096 : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?gObjTrapAttackEnemySearchX@@YAXPAUOBJECTSTRUCT@@H@Z ENDP ; gObjTrapAttackEnemySearchX
_TEXT	ENDS
PUBLIC	?gObjTrapAttackEnemySearchY@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchY
; Function compile flags: /Ogtp
;	COMDAT ?gObjTrapAttackEnemySearchY@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_x$ = -12						; size = 4
_n$158566 = -8						; size = 4
_pos$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_count$ = 12						; size = 4
?gObjTrapAttackEnemySearchY@@YAXPAUOBJECTSTRUCT@@H@Z PROC ; gObjTrapAttackEnemySearchY, COMDAT

; 2099 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2100 : 	lpObj->TargetNumber = -1;

  00006	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]

; 2101 : 	int tObjNum;
; 2102 : 	int pos = lpObj->Y;

  00009	0f bf 8a 06 01
	00 00		 movsx	 ecx, WORD PTR [edx+262]
  00010	83 c8 ff	 or	 eax, -1

; 2103 : 	int x = lpObj->X;
; 2104 : 
; 2105 : 	for(int n =0;n<count;n++)

  00013	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  00017	66 89 82 d4 02
	00 00		 mov	 WORD PTR [edx+724], ax
  0001e	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00025	89 4d fc	 mov	 DWORD PTR _pos$[ebp], ecx
  00028	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$158566[ebp], 0
  00032	0f 8e 88 00 00
	00		 jle	 $LN10@gObjTrapAt@2
  00038	56		 push	 esi
  00039	57		 push	 edi
  0003a	bf 01 00 00 00	 mov	 edi, 1
  0003f	eb 03		 jmp	 SHORT $LN12@gObjTrapAt@2
$LL23@gObjTrapAt@2:
  00041	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
$LN12@gObjTrapAt@2:

; 2106 : 	{
; 2107 : 		pos--;

  00044	29 7d fc	 sub	 DWORD PTR _pos$[ebp], edi

; 2108 : 		for(int i =0; i< MAX_VIEWPORT_MONSTER; i++)

  00047	33 c9		 xor	 ecx, ecx
  00049	81 c2 16 07 00
	00		 add	 edx, 1814		; 00000716H
  0004f	90		 npad	 1
$LL24@gObjTrapAt@2:

; 2109 : 		{
; 2110 : 			tObjNum = lpObj->VpPlayer2[i].number;

  00050	0f bf 32	 movsx	 esi, WORD PTR [edx]

; 2111 : 
; 2112 : 			if(tObjNum >= 0)

  00053	85 f6		 test	 esi, esi
  00055	78 3b		 js	 SHORT $LN8@gObjTrapAt@2

; 2113 : 			{
; 2114 : 				if(gObj[tObjNum].Type==1)

  00057	8b c6		 mov	 eax, esi
  00059	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0005f	66 39 b8 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], di
  00066	75 2a		 jne	 SHORT $LN8@gObjTrapAt@2

; 2115 : 				{
; 2116 : 					if(gObj[tObjNum].Live)

  00068	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  0006f	74 21		 je	 SHORT $LN8@gObjTrapAt@2

; 2117 : 					{
; 2118 : 						if(pos == gObj[tObjNum].Y)

  00071	0f bf b8 06 01
	00 00		 movsx	 edi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00078	39 7d fc	 cmp	 DWORD PTR _pos$[ebp], edi
  0007b	75 15		 jne	 SHORT $LN8@gObjTrapAt@2

; 2119 : 						{
; 2120 : 							if(x == gObj[tObjNum].X)

  0007d	0f bf b8 04 01
	00 00		 movsx	 edi, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00084	39 7d f4	 cmp	 DWORD PTR _x$[ebp], edi
  00087	75 09		 jne	 SHORT $LN8@gObjTrapAt@2

; 2121 : 							{
; 2122 : 								if((gObj[tObjNum].Authority&2)!=2)

  00089	f6 80 a4 01 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+420], 2
  00090	74 22		 je	 SHORT $LN17@gObjTrapAt@2
$LN8@gObjTrapAt@2:

; 2108 : 		for(int i =0; i< MAX_VIEWPORT_MONSTER; i++)

  00092	bf 01 00 00 00	 mov	 edi, 1
  00097	03 cf		 add	 ecx, edi
  00099	83 c2 0c	 add	 edx, 12			; 0000000cH
  0009c	83 f9 14	 cmp	 ecx, 20			; 00000014H
  0009f	7c af		 jl	 SHORT $LL24@gObjTrapAt@2

; 2103 : 	int x = lpObj->X;
; 2104 : 
; 2105 : 	for(int n =0;n<count;n++)

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _n$158566[ebp]
  000a4	03 c7		 add	 eax, edi
  000a6	89 45 f8	 mov	 DWORD PTR _n$158566[ebp], eax
  000a9	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  000ac	7c 93		 jl	 SHORT $LL23@gObjTrapAt@2
  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi

; 2125 : 									return;
; 2126 : 								}
; 2127 : 							}
; 2128 : 						}
; 2129 : 					}
; 2130 : 				}
; 2131 : 			}
; 2132 : 		}
; 2133 : 	}
; 2134 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
$LN17@gObjTrapAt@2:

; 2123 : 								{
; 2124 : 									lpObj->TargetNumber = tObjNum;

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b7	5f		 pop	 edi
  000b8	66 89 b1 d4 02
	00 00		 mov	 WORD PTR [ecx+724], si
  000bf	5e		 pop	 esi
$LN10@gObjTrapAt@2:

; 2125 : 									return;
; 2126 : 								}
; 2127 : 							}
; 2128 : 						}
; 2129 : 					}
; 2130 : 				}
; 2131 : 			}
; 2132 : 		}
; 2133 : 	}
; 2134 : }

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?gObjTrapAttackEnemySearchY@@YAXPAUOBJECTSTRUCT@@H@Z ENDP ; gObjTrapAttackEnemySearchY
_TEXT	ENDS
PUBLIC	?gObjTrapAttackEnemySearch@@YAXPAUOBJECTSTRUCT@@@Z ; gObjTrapAttackEnemySearch
; Function compile flags: /Ogtp
;	COMDAT ?gObjTrapAttackEnemySearch@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjTrapAttackEnemySearch@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjTrapAttackEnemySearch, COMDAT

; 2137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 2138 : 	int tObjNum;
; 2139 : 	lpObj->TargetNumber = -1;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	83 c8 ff	 or	 eax, -1
  0000c	66 89 87 d4 02
	00 00		 mov	 WORD PTR [edi+724], ax

; 2140 : 
; 2141 : 	for(int i = 0; i < MAX_VIEWPORT_MONSTER;i++)

  00013	33 d2		 xor	 edx, edx
  00015	8d b7 16 07 00
	00		 lea	 esi, DWORD PTR [edi+1814]
  0001b	eb 03 8d 49 00	 npad	 5
$LL16@gObjTrapAt@3:

; 2142 : 	{
; 2143 : 		tObjNum = lpObj->VpPlayer2[i].number;

  00020	0f bf 0e	 movsx	 ecx, WORD PTR [esi]

; 2144 : 
; 2145 : 		if(tObjNum >= 0)

  00023	85 c9		 test	 ecx, ecx
  00025	78 44		 js	 SHORT $LN8@gObjTrapAt@3

; 2146 : 		{
; 2147 : 			if(gObj[tObjNum].Type==1)

  00027	8b c1		 mov	 eax, ecx
  00029	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0002f	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  00037	75 32		 jne	 SHORT $LN8@gObjTrapAt@3

; 2148 : 			{
; 2149 : 				if(gObj[tObjNum].Live)

  00039	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  00040	74 29		 je	 SHORT $LN8@gObjTrapAt@3

; 2150 : 				{
; 2151 : 					if(lpObj->Y == gObj[tObjNum].Y)

  00042	66 8b 9f 06 01
	00 00		 mov	 bx, WORD PTR [edi+262]
  00049	66 3b 98 06 01
	00 00		 cmp	 bx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00050	75 19		 jne	 SHORT $LN8@gObjTrapAt@3

; 2152 : 					{
; 2153 : 						if(lpObj->X == gObj[tObjNum].X)

  00052	66 8b 9f 04 01
	00 00		 mov	 bx, WORD PTR [edi+260]
  00059	66 3b 98 04 01
	00 00		 cmp	 bx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  00060	75 09		 jne	 SHORT $LN8@gObjTrapAt@3

; 2154 : 						{
; 2155 : 							if((gObj[tObjNum].Authority&2)!=2)

  00062	f6 80 a4 01 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+420], 2
  00069	74 0e		 je	 SHORT $LN13@gObjTrapAt@3
$LN8@gObjTrapAt@3:

; 2140 : 
; 2141 : 	for(int i = 0; i < MAX_VIEWPORT_MONSTER;i++)

  0006b	42		 inc	 edx
  0006c	83 c6 0c	 add	 esi, 12			; 0000000cH
  0006f	83 fa 14	 cmp	 edx, 20			; 00000014H
  00072	7c ac		 jl	 SHORT $LL16@gObjTrapAt@3
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx

; 2158 : 								return;
; 2159 : 							}
; 2160 : 						}
; 2161 : 					}
; 2162 : 				}
; 2163 : 			}
; 2164 : 		}
; 2165 : 	}
; 2166 : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN13@gObjTrapAt@3:

; 2156 : 							{
; 2157 : 								lpObj->TargetNumber = tObjNum;

  00079	66 89 8f d4 02
	00 00		 mov	 WORD PTR [edi+724], cx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx

; 2158 : 								return;
; 2159 : 							}
; 2160 : 						}
; 2161 : 					}
; 2162 : 				}
; 2163 : 			}
; 2164 : 		}
; 2165 : 	}
; 2166 : }

  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?gObjTrapAttackEnemySearch@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjTrapAttackEnemySearch
_TEXT	ENDS
PUBLIC	?gObjTrapAttackEnemySearchRange@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchRange
; Function compile flags: /Ogtp
;	COMDAT ?gObjTrapAttackEnemySearchRange@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_iTargetingRate$ = -8					; size = 4
_i$158615 = -4						; size = 4
tv289 = 8						; size = 4
_lpObj$ = 8						; size = 4
_iRange$ = 12						; size = 4
?gObjTrapAttackEnemySearchRange@@YAXPAUOBJECTSTRUCT@@H@Z PROC ; gObjTrapAttackEnemySearchRange, COMDAT

; 2210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 2211 : 	int tObjNum = -1;
; 2212 : 	int iTargetingRate = 0;
; 2213 : 	int iSuccessRate = 0;
; 2214 : 
; 2215 : 	lpObj->TargetNumber = -1;

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 2216 : 
; 2217 : 	if(lpObj->VPCount <= 0)

  0000a	8b 8e 98 0a 00
	00		 mov	 ecx, DWORD PTR [esi+2712]
  00010	83 c8 ff	 or	 eax, -1
  00013	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax
  0001a	85 c9		 test	 ecx, ecx
  0001c	0f 8e b9 00 00
	00		 jle	 $LN15@gObjTrapAt@4

; 2218 : 	{
; 2219 : 		return;
; 2220 : 	}
; 2221 : 
; 2222 : 	iTargetingRate = 100 / lpObj->VPCount;

  00022	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00027	99		 cdq
  00028	f7 f9		 idiv	 ecx
  0002a	57		 push	 edi
  0002b	8b 7d 0c	 mov	 edi, DWORD PTR _iRange$[ebp]
  0002e	8d 8e 16 07 00
	00		 lea	 ecx, DWORD PTR [esi+1814]

; 2223 : 
; 2224 : 	for(int i = 0; i < MAX_VIEWPORT_MONSTER;i++)

  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$158615[ebp], 0
  0003b	89 4d 08	 mov	 DWORD PTR tv289[ebp], ecx
  0003e	53		 push	 ebx
  0003f	89 45 f8	 mov	 DWORD PTR _iTargetingRate$[ebp], eax
$LL19@gObjTrapAt@4:

; 2225 : 	{
; 2226 : 		tObjNum = lpObj->VpPlayer2[i].number;

  00042	8b 55 08	 mov	 edx, DWORD PTR tv289[ebp]
  00045	0f bf 02	 movsx	 eax, WORD PTR [edx]

; 2227 : 
; 2228 : 		if(tObjNum >= 0)

  00048	85 c0		 test	 eax, eax
  0004a	78 79		 js	 SHORT $LN9@gObjTrapAt@4

; 2229 : 		{
; 2230 : 			if(gObj[tObjNum].Type==1)

  0004c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00052	66 83 b8 60 00
	00 00 01	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+96], 1
  0005a	75 69		 jne	 SHORT $LN9@gObjTrapAt@4

; 2231 : 			{
; 2232 : 				if(gObj[tObjNum].Live)

  0005c	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  00063	74 60		 je	 SHORT $LN9@gObjTrapAt@4

; 2233 : 				{
; 2234 : 					if((lpObj->Y - iRange) <= gObj[tObjNum].Y && (lpObj->Y + iRange) >= gObj[tObjNum].Y)

  00065	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  0006c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00073	8b da		 mov	 ebx, edx
  00075	2b df		 sub	 ebx, edi
  00077	3b d9		 cmp	 ebx, ecx
  00079	7f 4a		 jg	 SHORT $LN9@gObjTrapAt@4
  0007b	03 d7		 add	 edx, edi
  0007d	3b d1		 cmp	 edx, ecx
  0007f	7c 44		 jl	 SHORT $LN9@gObjTrapAt@4

; 2235 : 					{
; 2236 : 						if((lpObj->X - iRange) <= gObj[tObjNum].X && (lpObj->X + iRange) >= gObj[tObjNum].X)

  00081	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00088	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0008f	8b da		 mov	 ebx, edx
  00091	2b df		 sub	 ebx, edi
  00093	3b d9		 cmp	 ebx, ecx
  00095	7f 2e		 jg	 SHORT $LN9@gObjTrapAt@4
  00097	03 d7		 add	 edx, edi
  00099	3b d1		 cmp	 edx, ecx
  0009b	7c 28		 jl	 SHORT $LN9@gObjTrapAt@4

; 2237 : 						{
; 2238 : 							if((gObj[tObjNum].Authority&2)!=2)

  0009d	f6 80 a4 01 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+420], 2
  000a4	75 1f		 jne	 SHORT $LN9@gObjTrapAt@4

; 2239 : 							{
; 2240 : 								lpObj->TargetNumber = tObjNum;

  000a6	8b 45 08	 mov	 eax, DWORD PTR tv289[ebp]
  000a9	0f bf 00	 movsx	 eax, WORD PTR [eax]
  000ac	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax

; 2241 : 								iSuccessRate = rand()%100;

  000b3	e8 00 00 00 00	 call	 _rand
  000b8	99		 cdq
  000b9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000be	f7 f9		 idiv	 ecx

; 2242 : 
; 2243 : 								if(iSuccessRate < iTargetingRate)

  000c0	3b 55 f8	 cmp	 edx, DWORD PTR _iTargetingRate$[ebp]
  000c3	7c 14		 jl	 SHORT $LN21@gObjTrapAt@4
$LN9@gObjTrapAt@4:

; 2223 : 
; 2224 : 	for(int i = 0; i < MAX_VIEWPORT_MONSTER;i++)

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _i$158615[ebp]
  000c8	83 45 08 0c	 add	 DWORD PTR tv289[ebp], 12 ; 0000000cH
  000cc	40		 inc	 eax
  000cd	89 45 fc	 mov	 DWORD PTR _i$158615[ebp], eax
  000d0	83 f8 14	 cmp	 eax, 20			; 00000014H
  000d3	0f 8c 69 ff ff
	ff		 jl	 $LL19@gObjTrapAt@4
$LN21@gObjTrapAt@4:
  000d9	5b		 pop	 ebx
  000da	5f		 pop	 edi
$LN15@gObjTrapAt@4:
  000db	5e		 pop	 esi

; 2244 : 								{
; 2245 : 									break;
; 2246 : 								}
; 2247 : 							}
; 2248 : 						}
; 2249 : 					}
; 2250 : 				}
; 2251 : 			}
; 2252 : 		}
; 2253 : 	}
; 2254 : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
?gObjTrapAttackEnemySearchRange@@YAXPAUOBJECTSTRUCT@@H@Z ENDP ; gObjTrapAttackEnemySearchRange
_TEXT	ENDS
PUBLIC	?NewOptionRand@@YAEH@Z				; NewOptionRand
; Function compile flags: /Ogtp
;	COMDAT ?NewOptionRand@@YAEH@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?NewOptionRand@@YAEH@Z PROC				; NewOptionRand, COMDAT

; 2259 : {

  00000	53		 push	 ebx

; 2260 : 	BYTE NOption = 0;
; 2261 : 	NOption = 1 << (rand() % 6);

  00001	e8 00 00 00 00	 call	 _rand
  00006	99		 cdq
  00007	b9 06 00 00 00	 mov	 ecx, 6
  0000c	f7 f9		 idiv	 ecx
  0000e	b3 01		 mov	 bl, 1
  00010	8b ca		 mov	 ecx, edx
  00012	d2 e3		 shl	 bl, cl

; 2262 : 
; 2263 : 	if ( (NOption &2) != 0 )

  00014	f6 c3 02	 test	 bl, 2
  00017	74 26		 je	 SHORT $LN2@NewOptionR

; 2264 : 	{
; 2265 : 		if ( (rand()%2) != 0 )

  00019	e8 00 00 00 00	 call	 _rand
  0001e	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00023	79 05		 jns	 SHORT $LN7@NewOptionR
  00025	48		 dec	 eax
  00026	83 c8 fe	 or	 eax, -2			; fffffffeH
  00029	40		 inc	 eax
$LN7@NewOptionR:
  0002a	74 13		 je	 SHORT $LN2@NewOptionR

; 2266 : 		{
; 2267 : 			NOption = 1 << (rand()%6);

  0002c	e8 00 00 00 00	 call	 _rand
  00031	99		 cdq
  00032	b9 06 00 00 00	 mov	 ecx, 6
  00037	f7 f9		 idiv	 ecx
  00039	b3 01		 mov	 bl, 1
  0003b	8b ca		 mov	 ecx, edx
  0003d	d2 e3		 shl	 bl, cl
$LN2@NewOptionR:

; 2268 : 		}
; 2269 : 	}
; 2270 : 
; 2271 : 	if ( (rand()% 4) == 0 )

  0003f	e8 00 00 00 00	 call	 _rand
  00044	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00049	79 05		 jns	 SHORT $LN8@NewOptionR
  0004b	48		 dec	 eax
  0004c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0004f	40		 inc	 eax
$LN8@NewOptionR:
  00050	75 17		 jne	 SHORT $LN6@NewOptionR

; 2272 : 	{
; 2273 : 		NOption |= 1 << (rand()%6);

  00052	e8 00 00 00 00	 call	 _rand
  00057	99		 cdq
  00058	b9 06 00 00 00	 mov	 ecx, 6
  0005d	f7 f9		 idiv	 ecx
  0005f	b0 01		 mov	 al, 1
  00061	8b ca		 mov	 ecx, edx
  00063	d2 e0		 shl	 al, cl
  00065	0a c3		 or	 al, bl
  00067	5b		 pop	 ebx

; 2277 : }

  00068	c3		 ret	 0
$LN6@NewOptionR:

; 2274 : 	}
; 2275 : 
; 2276 : 	return NOption;

  00069	8a c3		 mov	 al, bl
  0006b	5b		 pop	 ebx

; 2277 : }

  0006c	c3		 ret	 0
?NewOptionRand@@YAEH@Z ENDP				; NewOptionRand
_TEXT	ENDS
PUBLIC	?InventoryDropItem@@YAXPAUOBJECTSTRUCT@@H@Z	; InventoryDropItem
; Function compile flags: /Ogtp
;	COMDAT ?InventoryDropItem@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_DropItem$ = 12						; size = 4
?InventoryDropItem@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; InventoryDropItem, COMDAT

; 2281 : 	return;	// there is NO MACRO NOR CODE
; 2282 : }

  00000	c3		 ret	 0
?InventoryDropItem@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; InventoryDropItem
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?gObjSkylandBossSheildAttack@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSkylandBossSheildAttack
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjSkylandBossSheildAttack@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv95 = -4						; size = 4
tv308 = 8						; size = 4
_lpObj$ = 8						; size = 4
?gObjSkylandBossSheildAttack@@YAXPAUOBJECTSTRUCT@@@Z PROC ; gObjSkylandBossSheildAttack, COMDAT

; 2289 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 2290 : 	if ( lpObj->VPCount2 < 1 ) 

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	b9 01 00 00 00	 mov	 ecx, 1
  0000d	39 8f 9c 0a 00
	00		 cmp	 DWORD PTR [edi+2716], ecx
  00013	0f 8c f3 00 00
	00		 jl	 $LN1@gObjSkylan

; 2291 : 		return;
; 2292 : 
; 2293 : 	if ( lpObj->m_SkyBossMonSheildLinkIndex == -1 )

  00019	8b 87 f4 0e 00
	00		 mov	 eax, DWORD PTR [edi+3828]
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	0f 84 e4 00 00
	00		 je	 $LN1@gObjSkylan

; 2294 : 		return;
; 2295 : 
; 2296 : 	if ( lpObj->m_SkyBossMonSheild == 0 )

  00028	83 bf f8 0e 00
	00 00		 cmp	 DWORD PTR [edi+3832], 0
  0002f	0f 84 d7 00 00
	00		 je	 $LN1@gObjSkylan

; 2297 : 		return;
; 2298 : 
; 2299 : 	lpObj->TargetNumber = -1;
; 2300 : 
; 2301 : 	int tObjNum;
; 2302 : 	int shieldindex = lpObj->m_SkyBossMonSheildLinkIndex;
; 2303 : 
; 2304 : 	if ( gObj[shieldindex].Life < 0.0f )

  00035	d9 ee		 fldz
  00037	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0003d	83 ca ff	 or	 edx, -1
  00040	66 89 97 d4 02
	00 00		 mov	 WORD PTR [edi+724], dx
  00047	d8 98 bc 00 00
	00		 fcomp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+188]
  0004d	df e0		 fnstsw	 ax
  0004f	f6 c4 41	 test	 ah, 65			; 00000041H
  00052	0f 84 b4 00 00
	00		 je	 $LN1@gObjSkylan

; 2305 : 		return;
; 2306 : 
; 2307 : 	if ( lpObj->m_AttackRange > 0 )

  00058	66 83 bf 20 03
	00 00 00	 cmp	 WORD PTR [edi+800], 0
  00060	7e 7b		 jle	 SHORT $LN8@gObjSkylan

; 2308 : 	{
; 2309 : 		for (int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  00062	8d 87 16 07 00
	00		 lea	 eax, DWORD PTR [edi+1814]
  00068	53		 push	 ebx
  00069	89 45 08	 mov	 DWORD PTR tv308[ebp], eax
  0006c	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR tv95[ebp], 20	; 00000014H
  00073	56		 push	 esi
$LL21@gObjSkylan:

; 2310 : 		{
; 2311 : 			tObjNum = lpObj->VpPlayer2[i].number;

  00074	8b 55 08	 mov	 edx, DWORD PTR tv308[ebp]
  00077	0f bf 1a	 movsx	 ebx, WORD PTR [edx]

; 2312 : 
; 2313 : 			if ( tObjNum >= 0 )

  0007a	85 db		 test	 ebx, ebx
  0007c	78 4f		 js	 SHORT $LN9@gObjSkylan

; 2314 : 			{
; 2315 : 				if ( gObj[tObjNum].Type == OBJ_USER )

  0007e	8b f3		 mov	 esi, ebx
  00080	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00086	66 39 8e 60 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+96], cx
  0008d	75 3e		 jne	 SHORT $LN9@gObjSkylan

; 2316 : 				{
; 2317 : 					if ( gObj[tObjNum].Live )

  0008f	80 be 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+98], 0
  00096	74 35		 je	 SHORT $LN9@gObjSkylan

; 2318 : 					{
; 2319 : 						if ( gObjCheckTileArea(gObj[tObjNum].m_Index, lpObj->X, lpObj->Y, 2) )

  00098	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR [edi+262]
  0009f	0f bf 8f 04 01
	00 00		 movsx	 ecx, WORD PTR [edi+260]
  000a6	8b 96 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  000ac	6a 02		 push	 2
  000ae	50		 push	 eax
  000af	51		 push	 ecx
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 ?gObjCheckTileArea@@YAHHHHH@Z ; gObjCheckTileArea
  000b6	83 c4 10	 add	 esp, 16			; 00000010H
  000b9	85 c0		 test	 eax, eax
  000bb	74 10		 je	 SHORT $LN9@gObjSkylan

; 2320 : 						{
; 2321 : 							if ( (gObj[tObjNum].Authority&2) != 2 )

  000bd	f6 86 a4 01 00
	00 02		 test	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+420], 2
  000c4	75 07		 jne	 SHORT $LN9@gObjSkylan

; 2322 : 							{
; 2323 : 								lpObj->TargetNumber = tObjNum;

  000c6	66 89 9f d4 02
	00 00		 mov	 WORD PTR [edi+724], bx
$LN9@gObjSkylan:

; 2308 : 	{
; 2309 : 		for (int i=0;i<MAX_VIEWPORT_MONSTER;i++)

  000cd	83 45 08 0c	 add	 DWORD PTR tv308[ebp], 12 ; 0000000cH
  000d1	b9 01 00 00 00	 mov	 ecx, 1
  000d6	29 4d fc	 sub	 DWORD PTR tv95[ebp], ecx
  000d9	75 99		 jne	 SHORT $LL21@gObjSkylan
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
$LN8@gObjSkylan:

; 2324 : 							}
; 2325 : 						}
; 2326 : 					}
; 2327 : 				}
; 2328 : 			}
; 2329 : 		}
; 2330 : 	}
; 2331 : 	
; 2332 : 	if ( lpObj->TargetNumber >= 0 )

  000dd	66 83 bf d4 02
	00 00 00	 cmp	 WORD PTR [edi+724], 0
  000e5	7c 18		 jl	 SHORT $LN2@gObjSkylan

; 2333 : 	{
; 2334 : 		lpObj->m_ActState.Attack = 1;
; 2335 : 		lpObj->NextActionTime = lpObj->m_AttackSpeed;

  000e7	8b 87 08 03 00
	00		 mov	 eax, DWORD PTR [edi+776]
  000ed	83 8f b4 01 00
	00 02		 or	 DWORD PTR [edi+436], 2
  000f4	89 87 1c 02 00
	00		 mov	 DWORD PTR [edi+540], eax
  000fa	5f		 pop	 edi

; 2340 : 	}
; 2341 : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
$LN2@gObjSkylan:

; 2336 : 	}
; 2337 : 	else
; 2338 : 	{
; 2339 : 		lpObj->NextActionTime = lpObj->m_MoveSpeed;

  000ff	0f bf 8f 1c 03
	00 00		 movsx	 ecx, WORD PTR [edi+796]
  00106	89 8f 1c 02 00
	00		 mov	 DWORD PTR [edi+540], ecx
$LN1@gObjSkylan:
  0010c	5f		 pop	 edi

; 2340 : 	}
; 2341 : }

  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
?gObjSkylandBossSheildAttack@@YAXPAUOBJECTSTRUCT@@@Z ENDP ; gObjSkylandBossSheildAttack
_TEXT	ENDS
PUBLIC	?IsCanNotItemDtopInDevilSquare@@YAHH@Z		; IsCanNotItemDtopInDevilSquare
; Function compile flags: /Ogtp
;	COMDAT ?IsCanNotItemDtopInDevilSquare@@YAHH@Z
_TEXT	SEGMENT
_ItemType$ = 8						; size = 4
?IsCanNotItemDtopInDevilSquare@@YAHH@Z PROC		; IsCanNotItemDtopInDevilSquare, COMDAT

; 2348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2349 : 	int checkitemtype = ItemType  /MAX_SUBTYPE_ITEMS;

  00004	8b 75 08	 mov	 esi, DWORD PTR _ItemType$[ebp]
  00007	8b c6		 mov	 eax, esi
  00009	99		 cdq
  0000a	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00010	03 c2		 add	 eax, edx

; 2350 : 	int checkitemindex = ItemType % MAX_SUBTYPE_ITEMS;

  00012	8b ce		 mov	 ecx, esi
  00014	c1 f8 09	 sar	 eax, 9
  00017	81 e1 ff 01 00
	80		 and	 ecx, -2147483137	; 800001ffH
  0001d	79 08		 jns	 SHORT $LN17@IsCanNotIt
  0001f	49		 dec	 ecx
  00020	81 c9 00 fe ff
	ff		 or	 ecx, -512		; fffffe00H
  00026	41		 inc	 ecx
$LN17@IsCanNotIt:

; 2351 : 
; 2352 : 	if ( checkitemtype >= 7 && checkitemtype <= 11 )

  00027	8d 50 f9	 lea	 edx, DWORD PTR [eax-7]
  0002a	83 fa 04	 cmp	 edx, 4

; 2353 : 	{
; 2354 : 		if (checkitemindex== 17 ||checkitemindex == 18||checkitemindex== 19 )
; 2355 : 		{
; 2356 : 			return FALSE;

  0002d	76 2b		 jbe	 SHORT $LN18@IsCanNotIt

; 2357 : 		}
; 2358 : 	}
; 2359 : 	else if ( checkitemtype == 0 )

  0002f	85 c0		 test	 eax, eax
  00031	75 0f		 jne	 SHORT $LN10@IsCanNotIt

; 2360 : 	{
; 2361 : 		if (checkitemindex == 17 || checkitemindex == 18)

  00033	83 f9 11	 cmp	 ecx, 17			; 00000011H
  00036	74 05		 je	 SHORT $LN1@IsCanNotIt
  00038	83 f9 12	 cmp	 ecx, 18			; 00000012H
$LN19@IsCanNotIt:

; 2367 : 	{
; 2368 : 		if (checkitemindex== 12 || checkitemindex == 13 || checkitemindex == 14||
; 2369 : 	checkitemindex == 16 || checkitemindex == 17 || checkitemindex == 18||
; 2370 : 	checkitemindex == 19)

  0003b	75 3c		 jne	 SHORT $LN2@IsCanNotIt
$LN1@IsCanNotIt:

; 2376 : 	{
; 2377 : 		return FALSE;

  0003d	33 c0		 xor	 eax, eax
  0003f	5e		 pop	 esi

; 2381 : 
; 2382 : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
$LN10@IsCanNotIt:

; 2362 : 		{
; 2363 : 			return FALSE;
; 2364 : 		}
; 2365 : 	}
; 2366 : 	else if (checkitemtype == 12 )

  00042	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00045	75 22		 jne	 SHORT $LN6@IsCanNotIt

; 2367 : 	{
; 2368 : 		if (checkitemindex== 12 || checkitemindex == 13 || checkitemindex == 14||
; 2369 : 	checkitemindex == 16 || checkitemindex == 17 || checkitemindex == 18||
; 2370 : 	checkitemindex == 19)

  00047	3b c8		 cmp	 ecx, eax
  00049	74 f2		 je	 SHORT $LN1@IsCanNotIt
  0004b	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0004e	74 ed		 je	 SHORT $LN1@IsCanNotIt
  00050	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  00053	74 e8		 je	 SHORT $LN1@IsCanNotIt
  00055	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00058	74 e3		 je	 SHORT $LN1@IsCanNotIt
$LN18@IsCanNotIt:
  0005a	83 f9 11	 cmp	 ecx, 17			; 00000011H
  0005d	74 de		 je	 SHORT $LN1@IsCanNotIt
  0005f	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00062	74 d9		 je	 SHORT $LN1@IsCanNotIt
  00064	83 f9 13	 cmp	 ecx, 19			; 00000013H

; 2371 : 		{
; 2372 : 			return FALSE;

  00067	eb d2		 jmp	 SHORT $LN19@IsCanNotIt
$LN6@IsCanNotIt:

; 2373 : 		}
; 2374 : 	}
; 2375 : 	else if ( ItemType == ITEMGET(4,17) || ItemType ==ITEMGET(5,9)  )

  00069	81 fe 11 08 00
	00		 cmp	 esi, 2065		; 00000811H
  0006f	74 cc		 je	 SHORT $LN1@IsCanNotIt
  00071	81 fe 09 0a 00
	00		 cmp	 esi, 2569		; 00000a09H
  00077	74 c4		 je	 SHORT $LN1@IsCanNotIt
$LN2@IsCanNotIt:

; 2378 : 	}
; 2379 : 
; 2380 : 	return TRUE;

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	5e		 pop	 esi

; 2381 : 
; 2382 : }

  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?IsCanNotItemDtopInDevilSquare@@YAHH@Z ENDP		; IsCanNotItemDtopInDevilSquare
_TEXT	ENDS
PUBLIC	??_C@_0DH@PKHNCCG@?$FLKUNDUN?$FN?$FLAttacker?5Info?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0DI@BCGOHKAP@?$FLKUNDUN?$FN?$FLStatus?5Log?$FN?5HP?3?$CFd?5Refil@ ; `string'
PUBLIC	??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CFd@ ; `string'
PUBLIC	?gObjRefillMonsterHP@@YAXPAUOBJECTSTRUCT@@H@Z	; gObjRefillMonsterHP
EXTRN	?giKundunHPLogSaveTime@@3HA:DWORD		; giKundunHPLogSaveTime
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	?giKundunRefillHP@@3HA:DWORD			; giKundunRefillHP
EXTRN	?giKundunRefillHPTime@@3HA:DWORD		; giKundunRefillHPTime
;	COMDAT ??_C@_0DH@PKHNCCG@?$FLKUNDUN?$FN?$FLAttacker?5Info?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0DH@PKHNCCG@?$FLKUNDUN?$FN?$FLAttacker?5Info?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'KUNDUN][Attacker Info] [%s][%s] HP:%d MP:%d X:%d Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BCGOHKAP@?$FLKUNDUN?$FN?$FLStatus?5Log?$FN?5HP?3?$CFd?5Refil@
CONST	SEGMENT
??_C@_0DI@BCGOHKAP@?$FLKUNDUN?$FN?$FLStatus?5Log?$FN?5HP?3?$CFd?5Refil@ DB '['
	DB	'KUNDUN][Status Log] HP:%d RefillHP:%d Map:%d X:%d Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CFd@
CONST	SEGMENT
??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CFd@ DB '['
	DB	'KUNDUN] HP Log -> [%d]', 0c8H, 0b8H, 0baH, 0b9H, '  [%d]', 0c8H
	DB	0b8H, 0baH, 0b9H, 0bdH, 0c3H, 0b0H, 0a3H, '  [%7.0f]', 0c7H, 0f6H
	DB	0c0H, 0e7H, 'HP', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjRefillMonsterHP@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv289 = 8						; size = 4
_iMonsterHP$ = 8					; size = 4
_lpMonsterObj$ = 8					; size = 4
_iRefillHPSec$ = 12					; size = 4
?gObjRefillMonsterHP@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; gObjRefillMonsterHP, COMDAT

; 2386 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 2387 : 	int iMonsterHP = lpMonsterObj->Life;

  00005	8b 75 08	 mov	 esi, DWORD PTR _lpMonsterObj$[ebp]
  00008	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 __ftol2_sse

; 2388 : 	int iRefillHP = 0;

  00014	33 ff		 xor	 edi, edi

; 2389 : 
; 2390 : 	if(lpMonsterObj->Live==0)

  00016	80 7e 62 00	 cmp	 BYTE PTR [esi+98], 0
  0001a	89 45 08	 mov	 DWORD PTR _iMonsterHP$[ebp], eax
  0001d	0f 84 48 01 00
	00		 je	 $LN1@gObjRefill

; 2391 : 	{
; 2392 : 		return;
; 2393 : 	}
; 2394 : 
; 2395 : 	if(lpMonsterObj->Class == 275)

  00023	b8 13 01 00 00	 mov	 eax, 275		; 00000113H
  00028	66 39 86 98 00
	00 00		 cmp	 WORD PTR [esi+152], ax
  0002f	0f 85 08 01 00
	00		 jne	 $LN13@gObjRefill

; 2396 : 	{
; 2397 : 	LPOBJ lpObj;
; 2398 : 		if(lpMonsterObj->iObjectSecTimer > giKundunRefillHPTime)

  00035	8b 86 c0 14 00
	00		 mov	 eax, DWORD PTR [esi+5312]
  0003b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?giKundunRefillHPTime@@3HA ; giKundunRefillHPTime
  00041	7e 55		 jle	 SHORT $LN6@gObjRefill

; 2399 : 		{
; 2400 : 			iRefillHP = rand() % ((giKundunRefillHP > 0)? giKundunRefillHP : 1) ;

  00043	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?giKundunRefillHP@@3HA ; giKundunRefillHP
  00049	85 ff		 test	 edi, edi
  0004b	7f 05		 jg	 SHORT $LN12@gObjRefill
  0004d	bf 01 00 00 00	 mov	 edi, 1
$LN12@gObjRefill:
  00052	e8 00 00 00 00	 call	 _rand

; 2401 : 
; 2402 : 			lpMonsterObj->iObjectSecTimer = 0;
; 2403 : 
; 2404 : 			KUNDUN_EVENT_LOG.Output("[KUNDUN] HP Log -> [%d]  [%d]  [%7.0f]HP",
; 2405 : 				iRefillHP, giKundunRefillHPTime, lpMonsterObj->Life);	// Deathway Translation

  00057	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  0005d	99		 cdq
  0005e	f7 ff		 idiv	 edi
  00060	83 ec 08	 sub	 esp, 8
  00063	c7 86 c0 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5312], 0
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?giKundunRefillHPTime@@3HA ; giKundunRefillHPTime
  00073	dd 1c 24	 fstp	 QWORD PTR [esp]
  00076	51		 push	 ecx
  00077	8b fa		 mov	 edi, edx
  00079	57		 push	 edi
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@LBLCMLBJ@?$FLKUNDUN?$FN?5HP?5Log?5?9?$DO?5?$FL?$CFd?$FN?H?$LI?$LK?$LJ?5?5?$FL?$CFd@
  0007f	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  00084	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00089	83 c4 18	 add	 esp, 24			; 00000018H

; 2406 : 			lpMonsterObj->iObjectSecTimer = 0;

  0008c	c7 86 c0 14 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+5312], 0

; 2407 : 		}
; 2408 : 		else

  00096	eb 07		 jmp	 SHORT $LN5@gObjRefill
$LN6@gObjRefill:

; 2409 : 		{
; 2410 : 			lpMonsterObj->iObjectSecTimer++;

  00098	40		 inc	 eax
  00099	89 86 c0 14 00
	00		 mov	 DWORD PTR [esi+5312], eax
$LN5@gObjRefill:

; 2411 : 		}
; 2412 : 
; 2413 : 		if(lpMonsterObj->iObjectSecTimer % giKundunHPLogSaveTime == 0)

  0009f	8b 86 c0 14 00
	00		 mov	 eax, DWORD PTR [esi+5312]
  000a5	99		 cdq
  000a6	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?giKundunHPLogSaveTime@@3HA ; giKundunHPLogSaveTime
  000ac	85 d2		 test	 edx, edx
  000ae	0f 85 89 00 00
	00		 jne	 $LN13@gObjRefill

; 2414 : 		{
; 2415 : 			LogAdd(LOG_BLACK, "[KUNDUN][Status Log] HP:%d RefillHP:%d Map:%d X:%d Y:%d",
; 2416 : 				iMonsterHP,iRefillHP,lpMonsterObj->MapNumber,lpMonsterObj->X,lpMonsterObj->Y);

  000b4	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  000bb	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  000c2	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000c9	52		 push	 edx
  000ca	8b 55 08	 mov	 edx, DWORD PTR _iMonsterHP$[ebp]
  000cd	50		 push	 eax
  000ce	51		 push	 ecx
  000cf	57		 push	 edi
  000d0	52		 push	 edx
  000d1	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@BCGOHKAP@?$FLKUNDUN?$FN?$FLStatus?5Log?$FN?5HP?3?$CFd?5Refil@
  000d6	6a 00		 push	 0
  000d8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2417 : 			if(gObjIsConnected(lpMonsterObj->LastAttackerID))

  000dd	0f bf 86 da 02
	00 00		 movsx	 eax, WORD PTR [esi+730]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000ea	83 c4 20	 add	 esp, 32			; 00000020H
  000ed	85 c0		 test	 eax, eax
  000ef	74 4c		 je	 SHORT $LN13@gObjRefill

; 2418 : 			{
; 2419 : 				lpObj = &gObj[lpMonsterObj->LastAttackerID];

  000f1	0f bf 86 da 02
	00 00		 movsx	 eax, WORD PTR [esi+730]
  000f8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  000fe	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 2420 : 				LogAdd(LOG_BLACK, "[KUNDUN][Attacker Info] [%s][%s] HP:%d MP:%d X:%d Y:%d",
; 2421 : 					lpObj->AccountID,lpObj->Name,lpObj->Life,lpObj->Mana,lpObj->X,lpObj->Y);

  00103	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0010a	d9 80 d0 00 00
	00		 fld	 DWORD PTR [eax+208]
  00110	0f bf 90 04 01
	00 00		 movsx	 edx, WORD PTR [eax+260]
  00117	51		 push	 ecx
  00118	52		 push	 edx
  00119	83 ec 10	 sub	 esp, 16			; 00000010H
  0011c	8d 48 6f	 lea	 ecx, DWORD PTR [eax+111]
  0011f	83 c0 64	 add	 eax, 100		; 00000064H
  00122	dd 5c 24 08	 fstp	 QWORD PTR [esp+8]
  00126	d9 40 58	 fld	 DWORD PTR [eax+88]
  00129	dd 1c 24	 fstp	 QWORD PTR [esp]
  0012c	51		 push	 ecx
  0012d	50		 push	 eax
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PKHNCCG@?$FLKUNDUN?$FN?$FLAttacker?5Info?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  00133	6a 00		 push	 0
  00135	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0013a	83 c4 28	 add	 esp, 40			; 00000028H
$LN13@gObjRefill:

; 2422 : 			}
; 2423 : 		}
; 2424 : 	}
; 2425 : 
; 2426 : 	iMonsterHP = iMonsterHP + iRefillHP + iRefillHPSec;

  0013d	03 7d 0c	 add	 edi, DWORD PTR _iRefillHPSec$[ebp]
  00140	01 7d 08	 add	 DWORD PTR _iMonsterHP$[ebp], edi

; 2427 : 
; 2428 : 	if(lpMonsterObj->MaxLife < iMonsterHP)

  00143	db 45 08	 fild	 DWORD PTR _iMonsterHP$[ebp]
  00146	d9 5d 08	 fstp	 DWORD PTR tv289[ebp]
  00149	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  0014f	d9 45 08	 fld	 DWORD PTR tv289[ebp]
  00152	d8 d1		 fcom	 ST(1)
  00154	df e0		 fnstsw	 ax
  00156	dd d9		 fstp	 ST(1)
  00158	f6 c4 41	 test	 ah, 65			; 00000041H
  0015b	75 08		 jne	 SHORT $LN2@gObjRefill
  0015d	dd d8		 fstp	 ST(0)

; 2429 : 	{
; 2430 : 		lpMonsterObj->Life = lpMonsterObj->MaxLife;

  0015f	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
$LN2@gObjRefill:

; 2431 : 	}
; 2432 : 	else
; 2433 : 	{
; 2434 : 		lpMonsterObj->Life = iMonsterHP;

  00165	d9 9e bc 00 00
	00		 fstp	 DWORD PTR [esi+188]
$LN1@gObjRefill:
  0016b	5f		 pop	 edi
  0016c	5e		 pop	 esi
  0016d	5b		 pop	 ebx

; 2435 : 	}
; 2436 : }

  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
?gObjRefillMonsterHP@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; gObjRefillMonsterHP
_TEXT	ENDS
PUBLIC	?gObjMonsterDieRewardItems@@YAXPAUOBJECTSTRUCT@@0HHHHHHH@Z ; gObjMonsterDieRewardItems
EXTRN	?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKE@Z:PROC ; MapClass::MonsterItemDrop
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z:PROC	; ItemSerialCreateSend
EXTRN	?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z:PROC	; CMonsterItemMng::GetItem
EXTRN	?g_MonsterItemMng@@3VCMonsterItemMng@@A:BYTE	; g_MonsterItemMng
EXTRN	?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z:PROC ; gObjGetRandomItemDropLocation
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterDieRewardItems@@YAXPAUOBJECTSTRUCT@@0HHHHHHH@Z
_TEXT	SEGMENT
tv145 = -68						; size = 4
_type$ = -64						; size = 4
tv306 = -60						; size = 4
tv304 = -60						; size = 4
_dur$ = -60						; size = 4
_x$ = -56						; size = 4
_y$ = -52						; size = 4
_MaxHitUser$ = -48					; size = 4
_optionc$158742 = -44					; size = 4
_Option2$ = -40						; size = 4
_option2rand$158740 = -36				; size = 4
_Option1$ = -32						; size = 4
_NOption$ = -28						; size = 1
_exitem_drop$ = -24					; size = 4
_Option3$ = -20						; size = 4
_DropItem$ = -16					; size = 4
_item_drop$ = -12					; size = 4
_option3rand$158741 = -8				; size = 4
tv309 = -6						; size = 2
_cDropY$158729 = -1					; size = 1
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_iCount$ = 16						; size = 4
_cDropX$158728 = 19					; size = 1
_iDropRateCommonItem$ = 20				; size = 4
_iDropRateExcellentItem$ = 24				; size = 4
_iDropRateSetItem$ = 28					; size = 4
_bMustHaveSkill$ = 32					; size = 4
_bMustHaveLuck$ = 36					; size = 4
_bMustHaveAdditionalOption$ = 40			; size = 4
?gObjMonsterDieRewardItems@@YAXPAUOBJECTSTRUCT@@0HHHHHHH@Z PROC ; gObjMonsterDieRewardItems, COMDAT

; 2449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx

; 2450 : 	int store_count=0;
; 2451 : 	int DropItemNum=0;
; 2452 : 	int type;
; 2453 : 	int level;
; 2454 : 	int x;
; 2455 : 	int y;
; 2456 : 	float dur=0;
; 2457 : 	int Option1=0;

  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi

; 2458 : 	int Option2=0;
; 2459 : 	int Option3=0;
; 2460 : 	unsigned char NOption=0;
; 2461 : 	int item_drop=0;
; 2462 : 	int exitem_drop=0;
; 2463 : 	CItem * DropItem=NULL;
; 2464 : 	int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0000a	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000d	56		 push	 esi
  0000e	89 5d e0	 mov	 DWORD PTR _Option1$[ebp], ebx
  00011	89 5d d8	 mov	 DWORD PTR _Option2$[ebp], ebx
  00014	89 5d ec	 mov	 DWORD PTR _Option3$[ebp], ebx
  00017	89 5d f4	 mov	 DWORD PTR _item_drop$[ebp], ebx
  0001a	89 5d e8	 mov	 DWORD PTR _exitem_drop$[ebp], ebx
  0001d	89 5d f0	 mov	 DWORD PTR _DropItem$[ebp], ebx
  00020	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00025	89 45 d0	 mov	 DWORD PTR _MaxHitUser$[ebp], eax

; 2465 : 	int iSetDropPer=iDropRateSetItem;
; 2466 : 	int iExtDropPer=iDropRateExcellentItem;
; 2467 : 	int iCommonDropPer=iDropRateCommonItem;
; 2468 : 
; 2469 : 	for (int i=0;i<iCount;i++)

  00028	8b 45 10	 mov	 eax, DWORD PTR _iCount$[ebp]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b c3		 cmp	 eax, ebx
  00030	0f 8e 96 02 00
	00		 jle	 $LN24@gObjMonste@13

; 2450 : 	int store_count=0;
; 2451 : 	int DropItemNum=0;
; 2452 : 	int type;
; 2453 : 	int level;
; 2454 : 	int x;
; 2455 : 	int y;
; 2456 : 	float dur=0;
; 2457 : 	int Option1=0;

  00036	89 45 bc	 mov	 DWORD PTR tv145[ebp], eax
  00039	57		 push	 edi
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL36@gObjMonste@13:

; 2470 : 	{
; 2471 : 		BYTE cDropX = lpObj->X;

  00040	8a 86 04 01 00
	00		 mov	 al, BYTE PTR [esi+260]

; 2472 : 		BYTE cDropY = lpObj->Y;

  00046	8a 8e 06 01 00
	00		 mov	 cl, BYTE PTR [esi+262]

; 2473 : 
; 2474 : 		if ( !gObjGetRandomItemDropLocation(lpObj->MapNumber, cDropX, cDropY, 4, 4, 10))

  0004c	6a 0a		 push	 10			; 0000000aH
  0004e	6a 04		 push	 4
  00050	6a 04		 push	 4
  00052	8d 55 ff	 lea	 edx, DWORD PTR _cDropY$158729[ebp]
  00055	88 45 13	 mov	 BYTE PTR _cDropX$158728[ebp], al
  00058	88 4d ff	 mov	 BYTE PTR _cDropY$158729[ebp], cl
  0005b	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00062	52		 push	 edx
  00063	8d 45 13	 lea	 eax, DWORD PTR _cDropX$158728[ebp]
  00066	50		 push	 eax
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  0006d	83 c4 18	 add	 esp, 24			; 00000018H
  00070	85 c0		 test	 eax, eax
  00072	75 12		 jne	 SHORT $LN23@gObjMonste@13

; 2475 : 		{
; 2476 : 			cDropX = lpObj->X;

  00074	8a 96 04 01 00
	00		 mov	 dl, BYTE PTR [esi+260]

; 2477 : 			cDropY = lpObj->Y;

  0007a	8a 86 06 01 00
	00		 mov	 al, BYTE PTR [esi+262]
  00080	88 55 13	 mov	 BYTE PTR _cDropX$158728[ebp], dl
  00083	88 45 ff	 mov	 BYTE PTR _cDropY$158729[ebp], al
$LN23@gObjMonste@13:

; 2478 : 		}
; 2479 : 
; 2480 : 		if ( (rand()%10000) < iExtDropPer )

  00086	e8 00 00 00 00	 call	 _rand
  0008b	99		 cdq
  0008c	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00091	f7 f9		 idiv	 ecx
  00093	3b 55 18	 cmp	 edx, DWORD PTR _iDropRateExcellentItem$[ebp]
  00096	7d 34		 jge	 SHORT $LN22@gObjMonste@13

; 2481 : 		{
; 2482 : 			DropItem = g_MonsterItemMng.GetItem(lpObj->Level-25);

  00098	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  0009f	83 ea 19	 sub	 edx, 25			; 00000019H
  000a2	52		 push	 edx
  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  000a8	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  000ad	89 45 f0	 mov	 DWORD PTR _DropItem$[ebp], eax

; 2483 : 
; 2484 : 			if ( !DropItem )

  000b0	3b c3		 cmp	 eax, ebx
  000b2	75 0b		 jne	 SHORT $LN21@gObjMonste@13

; 2485 : 			{
; 2486 : 				item_drop = 0;

  000b4	89 5d f4	 mov	 DWORD PTR _item_drop$[ebp], ebx

; 2487 : 				exitem_drop=0;

  000b7	89 5d e8	 mov	 DWORD PTR _exitem_drop$[ebp], ebx

; 2488 : 			}
; 2489 : 			else

  000ba	e9 03 02 00 00	 jmp	 $LN25@gObjMonste@13
$LN21@gObjMonste@13:

; 2490 : 			{
; 2491 : 				item_drop = 1;

  000bf	b8 01 00 00 00	 mov	 eax, 1
  000c4	89 45 f4	 mov	 DWORD PTR _item_drop$[ebp], eax

; 2492 : 				exitem_drop=1;

  000c7	89 45 e8	 mov	 DWORD PTR _exitem_drop$[ebp], eax

; 2493 : 			}

  000ca	eb 45		 jmp	 SHORT $LN31@gObjMonste@13
$LN22@gObjMonste@13:

; 2494 : 		}
; 2495 : 		else if ( (rand()%10000) < iCommonDropPer )

  000cc	e8 00 00 00 00	 call	 _rand
  000d1	99		 cdq
  000d2	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  000d7	f7 f9		 idiv	 ecx
  000d9	3b 55 14	 cmp	 edx, DWORD PTR _iDropRateCommonItem$[ebp]
  000dc	7d 2a		 jge	 SHORT $LN16@gObjMonste@13

; 2496 : 		{
; 2497 : 			DropItem = g_MonsterItemMng.GetItem(lpObj->Level);

  000de	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  000e5	52		 push	 edx
  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  000eb	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  000f0	89 45 f0	 mov	 DWORD PTR _DropItem$[ebp], eax

; 2498 : 
; 2499 : 			if ( !DropItem )

  000f3	3b c3		 cmp	 eax, ebx
  000f5	75 08		 jne	 SHORT $LN17@gObjMonste@13

; 2500 : 			{
; 2501 : 				item_drop = 0;

  000f7	89 5d f4	 mov	 DWORD PTR _item_drop$[ebp], ebx

; 2502 : 			}
; 2503 : 			else

  000fa	e9 c3 01 00 00	 jmp	 $LN25@gObjMonste@13
$LN17@gObjMonste@13:

; 2504 : 			{
; 2505 : 				item_drop = 1;

  000ff	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 1

; 2506 : 			}
; 2507 : 		}
; 2508 : 
; 2509 : 		if ( item_drop )

  00106	eb 09		 jmp	 SHORT $LN31@gObjMonste@13
$LN16@gObjMonste@13:
  00108	39 5d f4	 cmp	 DWORD PTR _item_drop$[ebp], ebx
  0010b	0f 84 b1 01 00
	00		 je	 $LN25@gObjMonste@13
$LN31@gObjMonste@13:

; 2510 : 		{
; 2511 : 			type = DropItem->m_Type;

  00111	8b 45 f0	 mov	 eax, DWORD PTR _DropItem$[ebp]
  00114	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]

; 2512 : 			level = DropItem->m_Level;

  00118	0f bf 78 08	 movsx	 edi, WORD PTR [eax+8]

; 2513 : 			dur = DropItem->m_Durability;

  0011c	8b d0		 mov	 edx, eax

; 2514 : 			x = cDropX;

  0011e	0f b6 45 13	 movzx	 eax, BYTE PTR _cDropX$158728[ebp]
  00122	d9 42 24	 fld	 DWORD PTR [edx+36]
  00125	89 4d c0	 mov	 DWORD PTR _type$[ebp], ecx
  00128	d9 5d c4	 fstp	 DWORD PTR _dur$[ebp]

; 2515 : 			y = cDropY;

  0012b	0f b6 4d ff	 movzx	 ecx, BYTE PTR _cDropY$158729[ebp]
  0012f	89 45 c8	 mov	 DWORD PTR _x$[ebp], eax
  00132	89 4d cc	 mov	 DWORD PTR _y$[ebp], ecx

; 2516 : 
; 2517 : 			int option1rand;
; 2518 : 			int option2rand;
; 2519 : 			int option3rand;
; 2520 : 			int optionc;
; 2521 : 
; 2522 : 			if ( exitem_drop )

  00135	39 5d e8	 cmp	 DWORD PTR _exitem_drop$[ebp], ebx
  00138	74 46		 je	 SHORT $LN14@gObjMonste@13

; 2523 : 			{
; 2524 : 				option1rand = gServerInfo.m_Data.iDropItemMonsterRate[1];
; 2525 : 				option2rand = gServerInfo.m_Data.iDropItemMonsterRate[2];

  0013a	8b 15 20 01 00
	00		 mov	 edx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+288
  00140	8b 1d 1c 01 00
	00		 mov	 ebx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+284
  00146	89 55 dc	 mov	 DWORD PTR _option2rand$158740[ebp], edx

; 2526 : 				option3rand = rand()%100;

  00149	e8 00 00 00 00	 call	 _rand
  0014e	99		 cdq
  0014f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00154	f7 f9		 idiv	 ecx
  00156	89 55 f8	 mov	 DWORD PTR _option3rand$158741[ebp], edx

; 2527 : 				optionc = rand()%3;

  00159	e8 00 00 00 00	 call	 _rand
  0015e	99		 cdq
  0015f	b9 03 00 00 00	 mov	 ecx, 3
  00164	f7 f9		 idiv	 ecx
  00166	89 55 d4	 mov	 DWORD PTR _optionc$158742[ebp], edx

; 2528 : 				NOption = NewOptionRand(lpObj->Level);

  00169	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00170	52		 push	 edx
  00171	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  00176	83 c4 04	 add	 esp, 4
  00179	88 45 e4	 mov	 BYTE PTR _NOption$[ebp], al

; 2529 : 				level = 0;

  0017c	33 ff		 xor	 edi, edi

; 2530 : 			}
; 2531 : 			else

  0017e	eb 32		 jmp	 SHORT $LN13@gObjMonste@13
$LN14@gObjMonste@13:

; 2532 : 			{
; 2533 : 				option1rand = gServerInfo.m_Data.iDropItemMonsterRate[3];
; 2534 : 				option2rand = gServerInfo.m_Data.iDropItemMonsterRate[4];

  00180	a1 28 01 00 00	 mov	 eax, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+296
  00185	8b 1d 24 01 00
	00		 mov	 ebx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+292
  0018b	89 45 dc	 mov	 DWORD PTR _option2rand$158740[ebp], eax

; 2535 : 				option3rand = rand()%100;

  0018e	e8 00 00 00 00	 call	 _rand
  00193	99		 cdq
  00194	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00199	f7 f9		 idiv	 ecx
  0019b	89 55 f8	 mov	 DWORD PTR _option3rand$158741[ebp], edx

; 2536 : 				optionc = rand()%3;

  0019e	e8 00 00 00 00	 call	 _rand
  001a3	99		 cdq
  001a4	b9 03 00 00 00	 mov	 ecx, 3
  001a9	f7 f9		 idiv	 ecx

; 2537 : 				NOption = 0;

  001ab	c6 45 e4 00	 mov	 BYTE PTR _NOption$[ebp], 0
  001af	89 55 d4	 mov	 DWORD PTR _optionc$158742[ebp], edx
$LN13@gObjMonste@13:

; 2538 : 			}
; 2539 : 
; 2540 : 			if ( (rand()%100) < option1rand )

  001b2	e8 00 00 00 00	 call	 _rand
  001b7	99		 cdq
  001b8	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001bd	f7 f9		 idiv	 ecx
  001bf	3b d3		 cmp	 edx, ebx
  001c1	7d 0a		 jge	 SHORT $LN32@gObjMonste@13

; 2541 : 			{
; 2542 : 				Option1 = 1;

  001c3	bb 01 00 00 00	 mov	 ebx, 1
  001c8	89 5d e0	 mov	 DWORD PTR _Option1$[ebp], ebx
  001cb	eb 03		 jmp	 SHORT $LN12@gObjMonste@13
$LN32@gObjMonste@13:
  001cd	8b 5d e0	 mov	 ebx, DWORD PTR _Option1$[ebp]
$LN12@gObjMonste@13:

; 2543 : 			}
; 2544 : 
; 2545 : 			if ( (rand()%100) < option2rand )

  001d0	e8 00 00 00 00	 call	 _rand
  001d5	99		 cdq
  001d6	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001db	f7 f9		 idiv	 ecx
  001dd	3b 55 dc	 cmp	 edx, DWORD PTR _option2rand$158740[ebp]
  001e0	7d 0a		 jge	 SHORT $LN33@gObjMonste@13

; 2546 : 			{
; 2547 : 				Option2 = 1;

  001e2	b8 01 00 00 00	 mov	 eax, 1
  001e7	89 45 d8	 mov	 DWORD PTR _Option2$[ebp], eax
  001ea	eb 03		 jmp	 SHORT $LN11@gObjMonste@13
$LN33@gObjMonste@13:
  001ec	8b 45 d8	 mov	 eax, DWORD PTR _Option2$[ebp]
$LN11@gObjMonste@13:

; 2548 : 			}
; 2549 : 
; 2550 : 			switch ( optionc )

  001ef	8b 4d d4	 mov	 ecx, DWORD PTR _optionc$158742[ebp]
  001f2	83 e9 00	 sub	 ecx, 0
  001f5	74 24		 je	 SHORT $LN8@gObjMonste@13
  001f7	49		 dec	 ecx
  001f8	74 12		 je	 SHORT $LN6@gObjMonste@13
  001fa	49		 dec	 ecx
  001fb	75 2b		 jne	 SHORT $LN34@gObjMonste@13

; 2560 : 				case 2:
; 2561 : 					if ( option3rand < 12 )

  001fd	83 7d f8 0c	 cmp	 DWORD PTR _option3rand$158741[ebp], 12 ; 0000000cH
  00201	7d 25		 jge	 SHORT $LN34@gObjMonste@13

; 2562 : 						Option3=1;

  00203	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1

; 2563 : 					break;

  0020a	eb 1c		 jmp	 SHORT $LN34@gObjMonste@13
$LN6@gObjMonste@13:

; 2555 : 					break;
; 2556 : 				case 1:
; 2557 : 					if ( option3rand < 8 )

  0020c	83 7d f8 08	 cmp	 DWORD PTR _option3rand$158741[ebp], 8
  00210	7d 16		 jge	 SHORT $LN34@gObjMonste@13

; 2558 : 						Option3=2;

  00212	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2

; 2559 : 					break;

  00219	eb 0d		 jmp	 SHORT $LN34@gObjMonste@13
$LN8@gObjMonste@13:

; 2551 : 			{
; 2552 : 				case 0:
; 2553 : 					if ( option3rand < 4 )

  0021b	83 7d f8 04	 cmp	 DWORD PTR _option3rand$158741[ebp], 4
  0021f	7d 07		 jge	 SHORT $LN34@gObjMonste@13

; 2554 : 						Option3=3;

  00221	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN34@gObjMonste@13:

; 2564 : 			}
; 2565 : 
; 2566 : 			if ( DropItem->m_serial )

  00228	8b 55 f0	 mov	 edx, DWORD PTR _DropItem$[ebp]

; 2567 : 			{
; 2568 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2569 : 					Option1, Option2, Option3, MaxHitUser, NOption, 0);

  0022b	d9 45 c4	 fld	 DWORD PTR _dur$[ebp]
  0022e	80 7a 04 00	 cmp	 BYTE PTR [edx+4], 0
  00232	6a 00		 push	 0
  00234	74 4f		 je	 SHORT $LN2@gObjMonste@13
  00236	8b 4d e4	 mov	 ecx, DWORD PTR _NOption$[ebp]
  00239	d9 7d fa	 fnstcw	 WORD PTR tv309[ebp]
  0023c	8b 55 d0	 mov	 edx, DWORD PTR _MaxHitUser$[ebp]
  0023f	51		 push	 ecx
  00240	8b 4d ec	 mov	 ecx, DWORD PTR _Option3$[ebp]
  00243	52		 push	 edx
  00244	51		 push	 ecx
  00245	50		 push	 eax
  00246	0f b7 45 fa	 movzx	 eax, WORD PTR tv309[ebp]
  0024a	8b 4d c0	 mov	 ecx, DWORD PTR _type$[ebp]
  0024d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00252	89 45 c4	 mov	 DWORD PTR tv306[ebp], eax
  00255	53		 push	 ebx
  00256	d9 6d c4	 fldcw	 WORD PTR tv306[ebp]
  00259	db 5d c4	 fistp	 DWORD PTR tv304[ebp]
  0025c	8a 55 c4	 mov	 dl, BYTE PTR tv304[ebp]
  0025f	0f b6 c2	 movzx	 eax, dl
  00262	8b 55 cc	 mov	 edx, DWORD PTR _y$[ebp]
  00265	d9 6d fa	 fldcw	 WORD PTR tv309[ebp]
  00268	50		 push	 eax
  00269	8b 45 c8	 mov	 eax, DWORD PTR _x$[ebp]
  0026c	57		 push	 edi
  0026d	51		 push	 ecx
  0026e	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00275	52		 push	 edx
  00276	8b 16		 mov	 edx, DWORD PTR [esi]
  00278	50		 push	 eax
  00279	51		 push	 ecx
  0027a	52		 push	 edx
  0027b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00280	83 c4 34	 add	 esp, 52			; 00000034H

; 2570 : 			}
; 2571 : 			else

  00283	eb 3b		 jmp	 SHORT $LN37@gObjMonste@13
$LN2@gObjMonste@13:

; 2572 : 			{
; 2573 : 				MapC[lpObj->MapNumber].MonsterItemDrop(type, level, dur, x, y,
; 2574 : 					Option1, Option2, Option3, NOption, 0, MaxHitUser, 0, 0);

  00285	8b 4d d0	 mov	 ecx, DWORD PTR _MaxHitUser$[ebp]
  00288	8b 55 e4	 mov	 edx, DWORD PTR _NOption$[ebp]
  0028b	6a 00		 push	 0
  0028d	51		 push	 ecx
  0028e	8b 4d ec	 mov	 ecx, DWORD PTR _Option3$[ebp]
  00291	6a 00		 push	 0
  00293	52		 push	 edx
  00294	8b 55 cc	 mov	 edx, DWORD PTR _y$[ebp]
  00297	51		 push	 ecx
  00298	50		 push	 eax
  00299	8b 45 c8	 mov	 eax, DWORD PTR _x$[ebp]
  0029c	53		 push	 ebx
  0029d	52		 push	 edx
  0029e	50		 push	 eax
  0029f	51		 push	 ecx
  002a0	8b 4d c0	 mov	 ecx, DWORD PTR _type$[ebp]
  002a3	d9 1c 24	 fstp	 DWORD PTR [esp]
  002a6	57		 push	 edi
  002a7	51		 push	 ecx
  002a8	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  002af	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  002b5	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  002bb	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKE@Z ; MapClass::MonsterItemDrop
$LN37@gObjMonste@13:
  002c0	33 db		 xor	 ebx, ebx
$LN25@gObjMonste@13:

; 2465 : 	int iSetDropPer=iDropRateSetItem;
; 2466 : 	int iExtDropPer=iDropRateExcellentItem;
; 2467 : 	int iCommonDropPer=iDropRateCommonItem;
; 2468 : 
; 2469 : 	for (int i=0;i<iCount;i++)

  002c2	ff 4d bc	 dec	 DWORD PTR tv145[ebp]
  002c5	0f 85 75 fd ff
	ff		 jne	 $LL36@gObjMonste@13
  002cb	5f		 pop	 edi
$LN24@gObjMonste@13:
  002cc	5e		 pop	 esi
  002cd	5b		 pop	 ebx

; 2575 : 			}
; 2576 : 		}
; 2577 : 	}
; 2578 : }

  002ce	8b e5		 mov	 esp, ebp
  002d0	5d		 pop	 ebp
  002d1	c3		 ret	 0
?gObjMonsterDieRewardItems@@YAXPAUOBJECTSTRUCT@@0HHHHHHH@Z ENDP ; gObjMonsterDieRewardItems
_TEXT	ENDS
PUBLIC	__real@437f0000
PUBLIC	__real@4059000000000000
PUBLIC	?gEventMonsterItemDrop@@YAHPAUOBJECTSTRUCT@@0@Z	; gEventMonsterItemDrop
EXTRN	?g_iDarkLordHeartDropRate@@3HA:DWORD		; g_iDarkLordHeartDropRate
EXTRN	?g_iBloodBoneDropRate@@3HA:DWORD		; g_iBloodBoneDropRate
EXTRN	?g_iAngelKingsPaperDropRate@@3HA:DWORD		; g_iAngelKingsPaperDropRate
EXTRN	?g_bBloodCastle@@3HA:DWORD			; g_bBloodCastle
EXTRN	?g_iMysteriousBeadDropRate2@@3HA:DWORD		; g_iMysteriousBeadDropRate2
EXTRN	?g_iMysteriousBeadDropRate1@@3HA:DWORD		; g_iMysteriousBeadDropRate1
EXTRN	?gGemOfDefendDropRate@@3HA:DWORD		; gGemOfDefendDropRate
EXTRN	?gGemOfDefendDropLevel@@3HA:DWORD		; gGemOfDefendDropLevel
EXTRN	?gIsDropGemOfDefend@@3HA:DWORD			; gIsDropGemOfDefend
EXTRN	?gSoulOfDarkSpiritDropRate@@3HA:DWORD		; gSoulOfDarkSpiritDropRate
EXTRN	?gSoulOfDarkSpiritDropLevel@@3HA:DWORD		; gSoulOfDarkSpiritDropLevel
EXTRN	?gSoulOfDarkHorseDropRate@@3HA:DWORD		; gSoulOfDarkHorseDropRate
EXTRN	?gSoulOfDarkHorseropLevel@@3HA:DWORD		; gSoulOfDarkHorseropLevel
EXTRN	?gSleeveOfLordDropRate@@3HA:DWORD		; gSleeveOfLordDropRate
EXTRN	?gSleeveOfLordDropLevel@@3HA:DWORD		; gSleeveOfLordDropLevel
EXTRN	?gIsDropDarkLordItem@@3HA:DWORD			; gIsDropDarkLordItem
EXTRN	?g_iJapan1StAnivItemDropRate@@3HA:DWORD		; g_iJapan1StAnivItemDropRate
EXTRN	?g_iMarkOfTheLord@@3HA:DWORD			; g_iMarkOfTheLord
EXTRN	?g_iKundunMarkDropRate@@3HA:DWORD		; g_iKundunMarkDropRate
EXTRN	?gBoxOfGoldDropRate@@3HA:DWORD			; gBoxOfGoldDropRate
EXTRN	?gEventChipEvent@@3HA:DWORD			; gEventChipEvent
EXTRN	?gSilverMedalDropRate@@3HA:DWORD		; gSilverMedalDropRate
EXTRN	?gGoldMedalDropRate@@3HA:DWORD			; gGoldMedalDropRate
EXTRN	?gMedalEvent@@3HA:DWORD				; gMedalEvent
EXTRN	?gHeartOfLoveDropRate@@3HA:DWORD		; gHeartOfLoveDropRate
EXTRN	?gHeartOfLoveEvent@@3HA:DWORD			; gHeartOfLoveEvent
EXTRN	?DropEventItem@CItemBagEx@@QAEHH@Z:PROC		; CItemBagEx::DropEventItem
EXTRN	?StarOfXMasItemBag@@3PAVCItemBagEx@@A:DWORD	; StarOfXMasItemBag
EXTRN	?gXMasEvent@@3HA:DWORD				; gXMasEvent
EXTRN	?GetPartyCount@PartyClass@@QAEHH@Z:PROC		; PartyClass::GetPartyCount
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?gFireCrackerDropRate@@3HA:DWORD		; gFireCrackerDropRate
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?gFireCrackerEvent@@3HA:DWORD			; gFireCrackerEvent
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gItemDropRingOfTransform@@3HA:DWORD		; gItemDropRingOfTransform
EXTRN	?gIsItemDropRingOfTransform@@3HA:DWORD		; gIsItemDropRingOfTransform
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gEventMonsterItemDrop@@YAHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv1432 = -16						; size = 4
tv1430 = -16						; size = 4
tv1257 = -16						; size = 4
tv1255 = -16						; size = 4
tv1232 = -16						; size = 4
tv1230 = -16						; size = 4
tv1207 = -16						; size = 4
tv1205 = -16						; size = 4
tv1155 = -16						; size = 4
tv1153 = -16						; size = 4
tv1121 = -16						; size = 4
tv1119 = -16						; size = 4
_MaxHitUser$158956 = -16				; size = 4
tv1441 = -12						; size = 4
_y$ = -12						; size = 4
_type$ = -8						; size = 4
_x$ = -8						; size = 4
_dur$ = -4						; size = 4
tv1435 = -2						; size = 2
tv1260 = -2						; size = 2
tv1235 = -2						; size = 2
tv1209 = -2						; size = 2
tv1185 = -2						; size = 2
tv1126 = -2						; size = 2
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gEventMonsterItemDrop@@YAHPAUOBJECTSTRUCT@@0@Z PROC	; gEventMonsterItemDrop, COMDAT

; 3163 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 3164 : 	int type;
; 3165 : 	int level;
; 3166 : 	int x;
; 3167 : 	int y;
; 3168 : 	float dur=0;
; 3169 : 	int Option1=0;
; 3170 : 	int Option2=0;
; 3171 : 	int Option3=0;
; 3172 : 
; 3173 : 	if ( gIsItemDropRingOfTransform )

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsItemDropRingOfTransform@@3HA, 0 ; gIsItemDropRingOfTransform
  0000d	d9 ee		 fldz
  0000f	53		 push	 ebx
  00010	d9 5d fc	 fstp	 DWORD PTR _dur$[ebp]
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00017	57		 push	 edi
  00018	0f 84 f7 00 00
	00		 je	 $LN119@gEventMons

; 3174 : 	{
; 3175 : 		if ( (rand()%10000) < gItemDropRingOfTransform )

  0001e	e8 00 00 00 00	 call	 _rand
  00023	99		 cdq
  00024	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00029	f7 f9		 idiv	 ecx
  0002b	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gItemDropRingOfTransform@@3HA ; gItemDropRingOfTransform
  00031	0f 8d de 00 00
	00		 jge	 $LN119@gEventMons

; 3176 : 		{
; 3177 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  00037	0f b7 96 98 00
	00 00		 movzx	 edx, WORD PTR [esi+152]
  0003e	52		 push	 edx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00044	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 3178 : 
; 3179 : 			if ( lpattr )

  00049	85 c0		 test	 eax, eax
  0004b	0f 84 c4 00 00
	00		 je	 $LN119@gEventMons

; 3180 : 			{
; 3181 : 				int level = lpattr->m_Level;

  00051	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]

; 3182 : 				int callbead_level = 0;
; 3183 : 
; 3184 : 				if ( level < 0 )

  00054	85 c9		 test	 ecx, ecx
  00056	79 02		 jns	 SHORT $LN118@gEventMons

; 3185 : 					level = 0;

  00058	33 c9		 xor	 ecx, ecx
$LN118@gEventMons:

; 3186 : 
; 3187 : 				callbead_level = level / 10;

  0005a	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0005f	f7 e9		 imul	 ecx
  00061	c1 fa 02	 sar	 edx, 2
  00064	8b fa		 mov	 edi, edx
  00066	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00069	03 fa		 add	 edi, edx

; 3188 : 
; 3189 : 				if ( callbead_level > 0 )

  0006b	85 ff		 test	 edi, edi
  0006d	7e 01		 jle	 SHORT $LN117@gEventMons

; 3190 : 					callbead_level--;

  0006f	4f		 dec	 edi
$LN117@gEventMons:

; 3191 : 
; 3192 : 				if ( callbead_level > 5 )

  00070	83 ff 05	 cmp	 edi, 5
  00073	7e 05		 jle	 SHORT $LN116@gEventMons

; 3193 : 					callbead_level = 5;

  00075	bf 05 00 00 00	 mov	 edi, 5
$LN116@gEventMons:

; 3194 : 
; 3195 : 				dur = rand()%100+100.0f;

  0007a	e8 00 00 00 00	 call	 _rand
  0007f	99		 cdq
  00080	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00085	f7 f9		 idiv	 ecx

; 3196 : 				x = lpObj->X;

  00087	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 3197 : 				y = lpObj->Y;
; 3198 : 				level = callbead_level;
; 3199 : 				type = ItemGetNumberMake(13, 10);

  0008e	6a 0a		 push	 10			; 0000000aH
  00090	6a 0d		 push	 13			; 0000000dH
  00092	89 55 f4	 mov	 DWORD PTR tv1441[ebp], edx
  00095	db 45 f4	 fild	 DWORD PTR tv1441[ebp]
  00098	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  0009f	89 55 f4	 mov	 DWORD PTR _y$[ebp], edx
  000a2	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4059000000000000
  000a8	d9 5d fc	 fstp	 DWORD PTR _dur$[ebp]
  000ab	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  000b0	83 c4 08	 add	 esp, 8

; 3200 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3201 : 
; 3202 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3203 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  000b3	6a 00		 push	 0
  000b5	6a 00		 push	 0
  000b7	56		 push	 esi
  000b8	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  000bb	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  000c0	d9 45 fc	 fld	 DWORD PTR _dur$[ebp]
  000c3	83 c4 04	 add	 esp, 4
  000c6	d9 7d fe	 fnstcw	 WORD PTR tv1435[ebp]
  000c9	50		 push	 eax
  000ca	0f b7 45 fe	 movzx	 eax, WORD PTR tv1435[ebp]
  000ce	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  000d1	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000d6	89 45 f0	 mov	 DWORD PTR tv1432[ebp], eax
  000d9	6a 00		 push	 0
  000db	6a 00		 push	 0
  000dd	d9 6d f0	 fldcw	 WORD PTR tv1432[ebp]
  000e0	6a 00		 push	 0
  000e2	db 5d f0	 fistp	 DWORD PTR tv1430[ebp]
  000e5	8a 45 f0	 mov	 al, BYTE PTR tv1430[ebp]
  000e8	0f b6 c8	 movzx	 ecx, al
  000eb	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  000ee	d9 6d fe	 fldcw	 WORD PTR tv1435[ebp]
  000f1	51		 push	 ecx
  000f2	57		 push	 edi
  000f3	52		 push	 edx
  000f4	50		 push	 eax
  000f5	53		 push	 ebx
$LN139@gEventMons:
  000f6	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  000fd	8b 16		 mov	 edx, DWORD PTR [esi]
  000ff	51		 push	 ecx
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00106	83 c4 34	 add	 esp, 52			; 00000034H
$LN138@gEventMons:

; 3204 : 
; 3205 : 				return TRUE;

  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	5b		 pop	 ebx

; 3759 : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
$LN119@gEventMons:

; 3206 : 			}
; 3207 : 		}
; 3208 : 	}
; 3209 : 
; 3210 : 	if ( gFireCrackerEvent ) 

  00115	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gFireCrackerEvent@@3HA, 0 ; gFireCrackerEvent
  0011c	bf 11 00 00 00	 mov	 edi, 17			; 00000011H
  00121	0f 84 61 01 00
	00		 je	 $LN130@gEventMons

; 3211 : 	{
; 3212 : 		if ( gLanguage == 0 )	// If Korea

  00127	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  0012e	0f 85 a6 00 00
	00		 jne	 $LN114@gEventMons

; 3213 : 		{
; 3214 : 			if ( lpObj->MapNumber < 7 )

  00134	80 be 09 01 00
	00 07		 cmp	 BYTE PTR [esi+265], 7
  0013b	0f 83 47 01 00
	00		 jae	 $LN130@gEventMons

; 3215 : 			{
; 3216 : 				LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  00141	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00148	50		 push	 eax
  00149	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0014e	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 3217 : 
; 3218 : 				if ( lpattr )

  00153	85 c0		 test	 eax, eax
  00155	0f 84 2d 01 00
	00		 je	 $LN130@gEventMons

; 3219 : 				{
; 3220 : 					if ( lpattr->m_Level >= 17 )

  0015b	39 78 1c	 cmp	 DWORD PTR [eax+28], edi
  0015e	0f 8c 24 01 00
	00		 jl	 $LN130@gEventMons

; 3221 : 					{
; 3222 : 						if ( (rand()%10000) < gFireCrackerDropRate )

  00164	e8 00 00 00 00	 call	 _rand
  00169	99		 cdq
  0016a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0016f	f7 f9		 idiv	 ecx
  00171	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gFireCrackerDropRate@@3HA ; gFireCrackerDropRate
  00177	0f 8d 0b 01 00
	00		 jge	 $LN130@gEventMons

; 3223 : 						{
; 3224 : 							dur = 255.0f;
; 3225 : 							x = lpObj->X;

  0017d	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3226 : 							y = lpObj->Y;

  00184	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3227 : 							level = 2;
; 3228 : 							type = ItemGetNumberMake(14, 11);

  0018b	6a 0b		 push	 11			; 0000000bH
  0018d	6a 0e		 push	 14			; 0000000eH
  0018f	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00194	83 c4 08	 add	 esp, 8

; 3229 : 							int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3230 : 
; 3231 : 							ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3232 : 								Option1,Option2,Option3, MaxHitUser, 0, 0);

  00197	6a 00		 push	 0
  00199	6a 00		 push	 0
  0019b	56		 push	 esi
  0019c	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  0019f	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  001a4	83 c4 04	 add	 esp, 4
  001a7	50		 push	 eax
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	6a 00		 push	 0
  001ae	68 ff 00 00 00	 push	 255			; 000000ffH
  001b3	6a 02		 push	 2
$LN141@gEventMons:
  001b5	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  001b8	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  001bf	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c1	52		 push	 edx
  001c2	53		 push	 ebx
  001c3	57		 push	 edi
  001c4	50		 push	 eax
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  001cb	83 c4 34	 add	 esp, 52			; 00000034H
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi

; 3233 : 
; 3234 : 							return TRUE;

  001d0	b8 01 00 00 00	 mov	 eax, 1
  001d5	5b		 pop	 ebx

; 3759 : }

  001d6	8b e5		 mov	 esp, ebp
  001d8	5d		 pop	 ebp
  001d9	c3		 ret	 0
$LN114@gEventMons:

; 3235 : 						}
; 3236 : 					}
; 3237 : 				}
; 3238 : 			}
; 3239 : 		}
; 3240 : 		else	// Only Fall on Party
; 3241 : 		{
; 3242 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  001da	56		 push	 esi
  001db	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  001e0	83 c4 04	 add	 esp, 4
  001e3	89 45 f0	 mov	 DWORD PTR _MaxHitUser$158956[ebp], eax

; 3243 : 
; 3244 : 			if ( MaxHitUser != -1 )

  001e6	83 f8 ff	 cmp	 eax, -1
  001e9	0f 84 99 00 00
	00		 je	 $LN130@gEventMons

; 3245 : 			{
; 3246 : 				int partycount = gParty.GetPartyCount(gObj[MaxHitUser].PartyNumber);

  001ef	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  001f5	8b 90 a8 02 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+680]
  001fb	52		 push	 edx
  001fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00201	e8 00 00 00 00	 call	 ?GetPartyCount@PartyClass@@QAEHH@Z ; PartyClass::GetPartyCount

; 3247 : 
; 3248 : 				if ( partycount > 0 )

  00206	85 c0		 test	 eax, eax
  00208	7e 7e		 jle	 SHORT $LN130@gEventMons

; 3249 : 				{
; 3250 : 					LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  0020a	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00211	50		 push	 eax
  00212	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00217	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 3251 : 
; 3252 : 					if ( lpattr )

  0021c	85 c0		 test	 eax, eax
  0021e	74 68		 je	 SHORT $LN130@gEventMons

; 3253 : 					{
; 3254 : 						if ( lpattr->m_Level >= 17 )

  00220	39 78 1c	 cmp	 DWORD PTR [eax+28], edi
  00223	7c 63		 jl	 SHORT $LN130@gEventMons

; 3255 : 						{
; 3256 : 							if ( (rand()%10000) < gFireCrackerDropRate )

  00225	e8 00 00 00 00	 call	 _rand
  0022a	99		 cdq
  0022b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00230	f7 f9		 idiv	 ecx
  00232	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gFireCrackerDropRate@@3HA ; gFireCrackerDropRate
  00238	7d 4e		 jge	 SHORT $LN130@gEventMons

; 3257 : 							{
; 3258 : 								dur = 255.0f;
; 3259 : 								x = lpObj->X;

  0023a	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3260 : 								y = lpObj->Y;

  00241	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3261 : 								level = 2;
; 3262 : 								type = ItemGetNumberMake(14, 11);

  00248	6a 0b		 push	 11			; 0000000bH
  0024a	6a 0e		 push	 14			; 0000000eH
  0024c	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 3263 : 
; 3264 : 								ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3265 : 									Option1,Option2,Option3, MaxHitUser, 0, 0);

  00251	8b 55 f0	 mov	 edx, DWORD PTR _MaxHitUser$158956[ebp]
  00254	6a 00		 push	 0
  00256	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00258	6a 00		 push	 0
  0025a	52		 push	 edx
  0025b	6a 00		 push	 0
  0025d	6a 00		 push	 0
  0025f	6a 00		 push	 0
  00261	68 ff 00 00 00	 push	 255			; 000000ffH
  00266	6a 02		 push	 2
  00268	50		 push	 eax
  00269	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00270	53		 push	 ebx
  00271	57		 push	 edi
  00272	50		 push	 eax
  00273	51		 push	 ecx
  00274	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00279	83 c4 3c	 add	 esp, 60			; 0000003cH
  0027c	5f		 pop	 edi
  0027d	5e		 pop	 esi

; 3266 : 
; 3267 : 								return TRUE;

  0027e	b8 01 00 00 00	 mov	 eax, 1
  00283	5b		 pop	 ebx

; 3759 : }

  00284	8b e5		 mov	 esp, ebp
  00286	5d		 pop	 ebp
  00287	c3		 ret	 0
$LN130@gEventMons:

; 3268 : 							}
; 3269 : 						}
; 3270 : 					}
; 3271 : 				}
; 3272 : 			}
; 3273 : 		}
; 3274 : 	}
; 3275 : 
; 3276 : 	if ( gXMasEvent )

  00288	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gXMasEvent@@3HA, 0 ; gXMasEvent
  0028f	74 1e		 je	 SHORT $LN131@gEventMons

; 3277 : 	{
; 3278 : 		if ( !StarOfXMasItemBag )

  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?StarOfXMasItemBag@@3PAVCItemBagEx@@A ; StarOfXMasItemBag
  00297	85 c9		 test	 ecx, ecx

; 3279 : 			return FALSE;

  00299	0f 84 6a 09 00
	00		 je	 $LN2@gEventMons

; 3280 : 
; 3281 : 		if ( StarOfXMasItemBag->DropEventItem(lpObj->m_Index) )

  0029f	8b 16		 mov	 edx, DWORD PTR [esi]
  002a1	52		 push	 edx
  002a2	e8 00 00 00 00	 call	 ?DropEventItem@CItemBagEx@@QAEHH@Z ; CItemBagEx::DropEventItem
  002a7	85 c0		 test	 eax, eax

; 3282 : 			return TRUE;

  002a9	0f 85 5a fe ff
	ff		 jne	 $LN138@gEventMons
$LN131@gEventMons:

; 3283 : 	}
; 3284 : 
; 3285 : 	if ( gHeartOfLoveEvent )

  002af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gHeartOfLoveEvent@@3HA, 0 ; gHeartOfLoveEvent
  002b6	0f 84 9b 00 00
	00		 je	 $LN91@gEventMons

; 3286 : 	{
; 3287 : 		if ( gLanguage == 2 )

  002bc	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR ?gLanguage@@3HA, 2 ; gLanguage
  002c3	75 6e		 jne	 SHORT $LN99@gEventMons

; 3288 : 		{
; 3289 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  002c5	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  002cc	50		 push	 eax
  002cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  002d2	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 3290 : 
; 3291 : 			if ( lpattr )

  002d7	85 c0		 test	 eax, eax
  002d9	74 7c		 je	 SHORT $LN91@gEventMons

; 3292 : 			{
; 3293 : 				if ( lpattr->m_Level >=15 )

  002db	83 78 1c 0f	 cmp	 DWORD PTR [eax+28], 15	; 0000000fH
$LN145@gEventMons:
  002df	7c 76		 jl	 SHORT $LN91@gEventMons

; 3294 : 				{
; 3295 : 					if ( (rand()%10000) < gHeartOfLoveDropRate )

  002e1	e8 00 00 00 00	 call	 _rand
  002e6	99		 cdq
  002e7	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  002ec	f7 f9		 idiv	 ecx
  002ee	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gHeartOfLoveDropRate@@3HA ; gHeartOfLoveDropRate
  002f4	7d 61		 jge	 SHORT $LN91@gEventMons

; 3296 : 					{
; 3297 : 						dur = 255.0f;
; 3298 : 						x = lpObj->X;

  002f6	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3299 : 						y = lpObj->Y;

  002fd	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3300 : 						level = 3;
; 3301 : 						type = ItemGetNumberMake(14, 11);

  00304	6a 0b		 push	 11			; 0000000bH
  00306	6a 0e		 push	 14			; 0000000eH
  00308	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0030d	83 c4 08	 add	 esp, 8

; 3302 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3303 : 
; 3304 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3305 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);

  00310	6a 00		 push	 0
  00312	6a 00		 push	 0
  00314	56		 push	 esi
  00315	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  00318	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0031d	83 c4 04	 add	 esp, 4
  00320	50		 push	 eax
  00321	6a 00		 push	 0
  00323	6a 00		 push	 0
  00325	6a 00		 push	 0
  00327	68 ff 00 00 00	 push	 255			; 000000ffH
  0032c	6a 03		 push	 3

; 3306 : 
; 3307 : 						return TRUE;

  0032e	e9 82 fe ff ff	 jmp	 $LN141@gEventMons
$LN99@gEventMons:

; 3308 : 					}
; 3309 : 				}
; 3310 : 			}
; 3311 : 		}
; 3312 : 		else
; 3313 : 		{
; 3314 : 			if ( lpObj->MapNumber < 7 )

  00333	80 be 09 01 00
	00 07		 cmp	 BYTE PTR [esi+265], 7
  0033a	73 1b		 jae	 SHORT $LN91@gEventMons

; 3315 : 			{
; 3316 : 				LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpObj->Class);

  0033c	0f b7 96 98 00
	00 00		 movzx	 edx, WORD PTR [esi+152]
  00343	52		 push	 edx
  00344	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00349	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr

; 3317 : 
; 3318 : 				if ( lpattr )

  0034e	85 c0		 test	 eax, eax
  00350	74 05		 je	 SHORT $LN91@gEventMons

; 3319 : 				{
; 3320 : 					if ( lpattr->m_Level >=17 )

  00352	39 78 1c	 cmp	 DWORD PTR [eax+28], edi

; 3321 : 					{
; 3322 : 						if ( (rand()%10000) < gHeartOfLoveDropRate )
; 3323 : 						{
; 3324 : 							dur = 255.0f;
; 3325 : 							x = lpObj->X;
; 3326 : 							y = lpObj->Y;
; 3327 : 							level = 3;
; 3328 : 							type = ItemGetNumberMake(14, 11);
; 3329 : 							int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3330 : 
; 3331 : 							ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3332 : 								Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3333 : 
; 3334 : 							return TRUE;

  00355	eb 88		 jmp	 SHORT $LN145@gEventMons
$LN91@gEventMons:

; 3335 : 						}
; 3336 : 					}
; 3337 : 				}
; 3338 : 			}
; 3339 : 		}
; 3340 : 	}
; 3341 : 	
; 3342 : 	if ( gMedalEvent )

  00357	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gMedalEvent@@3HA, 0 ; gMedalEvent
  0035e	0f 84 c6 00 00
	00		 je	 $LN87@gEventMons

; 3343 : 	{
; 3344 : 		if ( lpObj->MapNumber == 1 || lpObj->MapNumber == 2 )	// Silver Medal

  00364	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  0036a	3c 01		 cmp	 al, 1
  0036c	74 6a		 je	 SHORT $LN88@gEventMons
  0036e	3c 02		 cmp	 al, 2
  00370	74 66		 je	 SHORT $LN88@gEventMons

; 3359 : 			}
; 3360 : 		}
; 3361 : 		else if ( lpObj->MapNumber == 4 || lpObj->MapNumber == 7 || lpObj->MapNumber == 8 )	// Gold Medal

  00372	3c 04		 cmp	 al, 4
  00374	74 0c		 je	 SHORT $LN84@gEventMons
  00376	3c 07		 cmp	 al, 7
  00378	74 08		 je	 SHORT $LN84@gEventMons
  0037a	3c 08		 cmp	 al, 8
  0037c	0f 85 a8 00 00
	00		 jne	 $LN87@gEventMons
$LN84@gEventMons:

; 3362 : 		{
; 3363 : 			if ( (rand()%10000) < gGoldMedalDropRate )

  00382	e8 00 00 00 00	 call	 _rand
  00387	99		 cdq
  00388	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0038d	f7 f9		 idiv	 ecx
  0038f	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gGoldMedalDropRate@@3HA ; gGoldMedalDropRate
  00395	0f 8d 8f 00 00
	00		 jge	 $LN87@gEventMons

; 3364 : 			{
; 3365 : 				dur = 255.0f;
; 3366 : 				x = lpObj->X;

  0039b	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3367 : 				y = lpObj->Y;

  003a2	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3368 : 				level = 6;
; 3369 : 				type = ItemGetNumberMake(14, 11);

  003a9	6a 0b		 push	 11			; 0000000bH
  003ab	6a 0e		 push	 14			; 0000000eH
  003ad	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  003b2	83 c4 08	 add	 esp, 8

; 3370 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3371 : 
; 3372 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3373 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  003b5	6a 00		 push	 0
  003b7	6a 00		 push	 0
  003b9	56		 push	 esi
  003ba	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  003bd	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  003c2	83 c4 04	 add	 esp, 4
  003c5	50		 push	 eax
  003c6	6a 00		 push	 0
  003c8	6a 00		 push	 0
  003ca	6a 00		 push	 0
  003cc	68 ff 00 00 00	 push	 255			; 000000ffH
  003d1	6a 06		 push	 6

; 3374 : 
; 3375 : 				return TRUE;

  003d3	e9 dd fd ff ff	 jmp	 $LN141@gEventMons
$LN88@gEventMons:

; 3345 : 		{
; 3346 : 			if ( (rand()%10000) < gSilverMedalDropRate )

  003d8	e8 00 00 00 00	 call	 _rand
  003dd	99		 cdq
  003de	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  003e3	f7 f9		 idiv	 ecx
  003e5	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSilverMedalDropRate@@3HA ; gSilverMedalDropRate
  003eb	7d 3d		 jge	 SHORT $LN87@gEventMons

; 3347 : 			{
; 3348 : 				dur = 255.0f;
; 3349 : 				x = lpObj->X;

  003ed	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3350 : 				y = lpObj->Y;

  003f4	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3351 : 				level = 5;
; 3352 : 				type = ItemGetNumberMake(14, 11);

  003fb	6a 0b		 push	 11			; 0000000bH
  003fd	6a 0e		 push	 14			; 0000000eH
  003ff	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00404	83 c4 08	 add	 esp, 8

; 3353 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3354 : 
; 3355 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3356 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  00407	6a 00		 push	 0
  00409	6a 00		 push	 0
  0040b	56		 push	 esi
  0040c	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  0040f	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00414	83 c4 04	 add	 esp, 4
  00417	50		 push	 eax
  00418	6a 00		 push	 0
  0041a	6a 00		 push	 0
  0041c	6a 00		 push	 0
  0041e	68 ff 00 00 00	 push	 255			; 000000ffH
  00423	6a 05		 push	 5

; 3357 : 
; 3358 : 				return TRUE;

  00425	e9 8b fd ff ff	 jmp	 $LN141@gEventMons
$LN87@gEventMons:

; 3376 : 			}
; 3377 : 		}
; 3378 : 	}
; 3379 : 
; 3380 : 	if ( gEventChipEvent )

  0042a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEventChipEvent@@3HA, 0 ; gEventChipEvent
  00431	74 52		 je	 SHORT $LN81@gEventMons

; 3381 : 	{
; 3382 : 		if ( (rand()%10000) < gBoxOfGoldDropRate )

  00433	e8 00 00 00 00	 call	 _rand
  00438	99		 cdq
  00439	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0043e	f7 f9		 idiv	 ecx
  00440	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gBoxOfGoldDropRate@@3HA ; gBoxOfGoldDropRate
  00446	7d 3d		 jge	 SHORT $LN81@gEventMons

; 3383 : 		{
; 3384 : 			dur = 255.0f;
; 3385 : 			x = lpObj->X;

  00448	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3386 : 			y = lpObj->Y;

  0044f	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3387 : 			level = 7;
; 3388 : 			type = ItemGetNumberMake(14, 11);

  00456	6a 0b		 push	 11			; 0000000bH
  00458	6a 0e		 push	 14			; 0000000eH
  0045a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0045f	83 c4 08	 add	 esp, 8

; 3389 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3390 : 
; 3391 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3392 : 				Option1,Option2,Option3, MaxHitUser, 0, 0);

  00462	6a 00		 push	 0
  00464	6a 00		 push	 0
  00466	56		 push	 esi
  00467	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  0046a	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0046f	83 c4 04	 add	 esp, 4
  00472	50		 push	 eax
  00473	6a 00		 push	 0
  00475	6a 00		 push	 0
  00477	6a 00		 push	 0
  00479	68 ff 00 00 00	 push	 255			; 000000ffH
  0047e	6a 07		 push	 7

; 3393 : 
; 3394 : 			return TRUE;

  00480	e9 30 fd ff ff	 jmp	 $LN141@gEventMons
$LN81@gEventMons:

; 3395 : 		}
; 3396 : 	}
; 3397 : 
; 3398 : 	if ( (rand()%10000) < g_iKundunMarkDropRate )

  00485	e8 00 00 00 00	 call	 _rand
  0048a	99		 cdq
  0048b	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00490	f7 f9		 idiv	 ecx
  00492	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iKundunMarkDropRate@@3HA ; g_iKundunMarkDropRate
  00498	0f 8d c3 00 00
	00		 jge	 $LN80@gEventMons

; 3399 : 	{
; 3400 : 		Option1=0;
; 3401 : 		Option2=0;
; 3402 : 		Option3=0;
; 3403 : 		dur = 1.0f;
; 3404 : 		x = lpObj->X;
; 3405 : 		y = lpObj->Y;

  0049e	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  004a5	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  004ac	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax

; 3406 : 		level = 0;
; 3407 : 
; 3408 : 		if ( lpObj->Level < 25 )

  004af	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  004b6	89 55 f8	 mov	 DWORD PTR _x$[ebp], edx
  004b9	66 83 f8 19	 cmp	 ax, 25			; 00000019H

; 3409 : 			level = 0;

  004bd	0f 8c 46 07 00
	00		 jl	 $LN2@gEventMons

; 3410 : 		else if ( lpObj->Level < 47 )

  004c3	66 83 f8 2f	 cmp	 ax, 47			; 0000002fH
  004c7	7d 07		 jge	 SHORT $LN77@gEventMons

; 3411 : 			level = 1;

  004c9	bf 01 00 00 00	 mov	 edi, 1
  004ce	eb 5e		 jmp	 SHORT $LN64@gEventMons
$LN77@gEventMons:

; 3412 : 		else if ( lpObj->Level < 66 )

  004d0	66 83 f8 42	 cmp	 ax, 66			; 00000042H
  004d4	7d 07		 jge	 SHORT $LN75@gEventMons

; 3413 : 			level = 2;

  004d6	bf 02 00 00 00	 mov	 edi, 2
  004db	eb 51		 jmp	 SHORT $LN64@gEventMons
$LN75@gEventMons:

; 3414 : 		else if ( lpObj->Level < 78 )

  004dd	66 83 f8 4e	 cmp	 ax, 78			; 0000004eH
  004e1	7d 07		 jge	 SHORT $LN73@gEventMons

; 3415 : 			level = 3;

  004e3	bf 03 00 00 00	 mov	 edi, 3
  004e8	eb 44		 jmp	 SHORT $LN64@gEventMons
$LN73@gEventMons:

; 3416 : 		else if ( lpObj->Level < 84 )

  004ea	66 83 f8 54	 cmp	 ax, 84			; 00000054H
  004ee	7d 07		 jge	 SHORT $LN71@gEventMons

; 3417 : 			level = 4;

  004f0	bf 04 00 00 00	 mov	 edi, 4
  004f5	eb 37		 jmp	 SHORT $LN64@gEventMons
$LN71@gEventMons:

; 3418 : 		else if ( lpObj->Level < 92 )

  004f7	66 83 f8 5c	 cmp	 ax, 92			; 0000005cH
  004fb	7d 07		 jge	 SHORT $LN69@gEventMons

; 3419 : 			level = 5;

  004fd	bf 05 00 00 00	 mov	 edi, 5
  00502	eb 2a		 jmp	 SHORT $LN64@gEventMons
$LN69@gEventMons:

; 3420 : 		else if ( lpObj->Level < 114 )

  00504	66 83 f8 72	 cmp	 ax, 114			; 00000072H
  00508	7d 07		 jge	 SHORT $LN67@gEventMons

; 3421 : 			level = 6;

  0050a	bf 06 00 00 00	 mov	 edi, 6
  0050f	eb 1d		 jmp	 SHORT $LN64@gEventMons
$LN67@gEventMons:

; 3422 : 		else if ( lpObj->Level > 115 && lpObj->Level < MAX_CHAR_LEVEL+1 )

  00511	66 83 f8 73	 cmp	 ax, 115			; 00000073H
  00515	0f 8e ee 06 00
	00		 jle	 $LN2@gEventMons
  0051b	b9 91 01 00 00	 mov	 ecx, 401		; 00000191H
  00520	66 3b c1	 cmp	 ax, cx
  00523	0f 8d e0 06 00
	00		 jge	 $LN2@gEventMons

; 3423 : 			level = 7;

  00529	bf 07 00 00 00	 mov	 edi, 7
$LN64@gEventMons:

; 3424 : 
; 3425 : 		if ( level == 0 )
; 3426 : 			return FALSE;
; 3427 : 
; 3428 : 		type = ItemGetNumberMake(14, 29);

  0052e	6a 1d		 push	 29			; 0000001dH
  00530	6a 0e		 push	 14			; 0000000eH
  00532	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00537	83 c4 08	 add	 esp, 8

; 3429 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3430 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3431 : 			Option1,Option2,Option3, MaxHitUser, 0, 0);

  0053a	6a 00		 push	 0
  0053c	6a 00		 push	 0
  0053e	56		 push	 esi
  0053f	8b d8		 mov	 ebx, eax
  00541	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00546	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00549	83 c4 04	 add	 esp, 4
  0054c	50		 push	 eax
  0054d	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00550	6a 00		 push	 0
  00552	6a 00		 push	 0
  00554	6a 00		 push	 0
  00556	6a 01		 push	 1
  00558	57		 push	 edi
  00559	53		 push	 ebx
  0055a	52		 push	 edx
  0055b	50		 push	 eax

; 3432 : 
; 3433 : 		return TRUE;

  0055c	e9 95 fb ff ff	 jmp	 $LN139@gEventMons
$LN80@gEventMons:

; 3434 : 	}
; 3435 : 
; 3436 : 	if ( (rand()%10000) < g_iMarkOfTheLord )

  00561	e8 00 00 00 00	 call	 _rand
  00566	99		 cdq
  00567	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0056c	f7 f9		 idiv	 ecx
  0056e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iMarkOfTheLord@@3HA ; g_iMarkOfTheLord
  00574	7d 5a		 jge	 SHORT $LN63@gEventMons

; 3437 : 	{
; 3438 : 		Option1=0;
; 3439 : 		Option2=0;
; 3440 : 		Option3=0;
; 3441 : 		level = 3;
; 3442 : 		dur = 1.0f;
; 3443 : 		x = lpObj->X;

  00576	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3444 : 		y = lpObj->Y;

  0057d	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 3445 : 		type = ItemGetNumberMake(14, 21);

  00584	6a 15		 push	 21			; 00000015H
  00586	6a 0e		 push	 14			; 0000000eH
  00588	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0058d	83 c4 08	 add	 esp, 8

; 3446 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3447 : 
; 3448 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3449 : 			Option1,Option2,Option3, MaxHitUser, 0, 0);

  00590	6a 00		 push	 0
  00592	6a 00		 push	 0
  00594	56		 push	 esi
  00595	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  00598	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0059d	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  005a0	8b 0e		 mov	 ecx, DWORD PTR [esi]
  005a2	83 c4 04	 add	 esp, 4
  005a5	50		 push	 eax
  005a6	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  005ad	6a 00		 push	 0
  005af	6a 00		 push	 0
  005b1	6a 00		 push	 0
  005b3	6a 01		 push	 1
  005b5	6a 03		 push	 3
  005b7	52		 push	 edx
  005b8	53		 push	 ebx
  005b9	57		 push	 edi
  005ba	50		 push	 eax
  005bb	51		 push	 ecx
  005bc	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  005c1	83 c4 34	 add	 esp, 52			; 00000034H
  005c4	5f		 pop	 edi
  005c5	5e		 pop	 esi
  005c6	b8 01 00 00 00	 mov	 eax, 1
  005cb	5b		 pop	 ebx

; 3759 : }

  005cc	8b e5		 mov	 esp, ebp
  005ce	5d		 pop	 ebp
  005cf	c3		 ret	 0
$LN63@gEventMons:

; 3450 : 
; 3451 : 		return TRUE;
; 3452 : 	}
; 3453 : 
; 3454 : 	if ( (rand()%10000) < g_iJapan1StAnivItemDropRate )

  005d0	e8 00 00 00 00	 call	 _rand
  005d5	99		 cdq
  005d6	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  005db	f7 f9		 idiv	 ecx
  005dd	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iJapan1StAnivItemDropRate@@3HA ; g_iJapan1StAnivItemDropRate
  005e3	0f 8d 7e 01 00
	00		 jge	 $LN59@gEventMons

; 3455 : 	{
; 3456 : 		if ( lpTargetObj->PartyNumber >= 0 )

  005e9	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  005ec	83 ba a8 02 00
	00 00		 cmp	 DWORD PTR [edx+680], 0
  005f3	0f 8c 6e 01 00
	00		 jl	 $LN59@gEventMons

; 3457 : 		{
; 3458 : 			dur = 255.0f;
; 3459 : 			x = lpObj->X;
; 3460 : 			y = lpObj->Y;

  005f9	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00600	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@437f0000
  00606	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]
  0060d	d9 5d fc	 fstp	 DWORD PTR _dur$[ebp]

; 3461 : 			type = ItemGetNumberMake(14,20);	// Branch of Rmedy of Love

  00610	6a 14		 push	 20			; 00000014H
  00612	6a 0e		 push	 14			; 0000000eH
  00614	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax
  00617	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 3462 : 
; 3463 : 			switch ( lpObj->MapNumber )

  0061c	8a 9e 09 01 00
	00		 mov	 bl, BYTE PTR [esi+265]
  00622	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax
  00625	0f b6 c3	 movzx	 eax, bl
  00628	83 c4 08	 add	 esp, 8
  0062b	83 f8 08	 cmp	 eax, 8
  0062e	0f 87 33 01 00
	00		 ja	 $LN59@gEventMons
  00634	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN147@gEventMons[eax*4]
$LN58@gEventMons:

; 3464 : 			{
; 3465 : 				case 0:
; 3466 : 					{
; 3467 : 						level = 1;
; 3468 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3469 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3470 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);

  0063b	6a 00		 push	 0
  0063d	6a 00		 push	 0
  0063f	56		 push	 esi
  00640	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00645	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00648	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0064b	83 c4 04	 add	 esp, 4
  0064e	50		 push	 eax
  0064f	8b 06		 mov	 eax, DWORD PTR [esi]
  00651	6a 00		 push	 0
  00653	6a 00		 push	 0
  00655	6a 00		 push	 0
  00657	68 ff 00 00 00	 push	 255			; 000000ffH
  0065c	6a 01		 push	 1
  0065e	51		 push	 ecx
  0065f	52		 push	 edx
  00660	57		 push	 edi
  00661	53		 push	 ebx
  00662	50		 push	 eax
  00663	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00668	83 c4 34	 add	 esp, 52			; 00000034H
  0066b	5f		 pop	 edi
  0066c	5e		 pop	 esi
  0066d	b8 01 00 00 00	 mov	 eax, 1
  00672	5b		 pop	 ebx

; 3759 : }

  00673	8b e5		 mov	 esp, ebp
  00675	5d		 pop	 ebp
  00676	c3		 ret	 0
$LN57@gEventMons:

; 3471 : 						
; 3472 : 						return TRUE;
; 3473 : 					}
; 3474 : 				case 1:
; 3475 : 					{
; 3476 : 						level = 2;
; 3477 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3478 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3479 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);

  00677	6a 00		 push	 0
  00679	6a 00		 push	 0
  0067b	56		 push	 esi
  0067c	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00681	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00684	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00687	83 c4 04	 add	 esp, 4
  0068a	50		 push	 eax
  0068b	8b 06		 mov	 eax, DWORD PTR [esi]
  0068d	6a 00		 push	 0
  0068f	6a 00		 push	 0
  00691	6a 00		 push	 0
  00693	68 ff 00 00 00	 push	 255			; 000000ffH
  00698	6a 02		 push	 2
  0069a	51		 push	 ecx
  0069b	52		 push	 edx
  0069c	57		 push	 edi
  0069d	53		 push	 ebx
  0069e	50		 push	 eax
  0069f	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  006a4	83 c4 34	 add	 esp, 52			; 00000034H
  006a7	5f		 pop	 edi
  006a8	5e		 pop	 esi
  006a9	b8 01 00 00 00	 mov	 eax, 1
  006ae	5b		 pop	 ebx

; 3759 : }

  006af	8b e5		 mov	 esp, ebp
  006b1	5d		 pop	 ebp
  006b2	c3		 ret	 0
$LN54@gEventMons:

; 3480 : 						return TRUE;
; 3481 : 					}
; 3482 : 				case 2:
; 3483 : 					{
; 3484 : 						level = 2;
; 3485 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3486 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3487 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3488 : 						return TRUE;
; 3489 : 					}
; 3490 : 				case 3:
; 3491 : 					{
; 3492 : 						level = 1;
; 3493 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3494 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3495 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3496 : 						return TRUE;
; 3497 : 					}
; 3498 : 				case 4:
; 3499 : 					{
; 3500 : 						level = 3;
; 3501 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3502 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3503 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);

  006b3	6a 00		 push	 0
  006b5	6a 00		 push	 0
  006b7	56		 push	 esi
  006b8	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  006bd	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  006c0	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  006c3	83 c4 04	 add	 esp, 4
  006c6	50		 push	 eax
  006c7	8b 06		 mov	 eax, DWORD PTR [esi]
  006c9	6a 00		 push	 0
  006cb	6a 00		 push	 0
  006cd	6a 00		 push	 0
  006cf	68 ff 00 00 00	 push	 255			; 000000ffH
  006d4	6a 03		 push	 3
  006d6	51		 push	 ecx
  006d7	52		 push	 edx
  006d8	57		 push	 edi
  006d9	53		 push	 ebx
  006da	50		 push	 eax
  006db	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  006e0	83 c4 34	 add	 esp, 52			; 00000034H
  006e3	5f		 pop	 edi
  006e4	5e		 pop	 esi
  006e5	b8 01 00 00 00	 mov	 eax, 1
  006ea	5b		 pop	 ebx

; 3759 : }

  006eb	8b e5		 mov	 esp, ebp
  006ed	5d		 pop	 ebp
  006ee	c3		 ret	 0
$LN53@gEventMons:

; 3504 : 						return TRUE;
; 3505 : 					}
; 3506 : 				case 7:
; 3507 : 					{
; 3508 : 						level = 4;
; 3509 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3510 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3511 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);

  006ef	6a 00		 push	 0
  006f1	6a 00		 push	 0
  006f3	56		 push	 esi
  006f4	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  006f9	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  006fc	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  006ff	83 c4 04	 add	 esp, 4
  00702	50		 push	 eax
  00703	8b 06		 mov	 eax, DWORD PTR [esi]
  00705	6a 00		 push	 0
  00707	6a 00		 push	 0
  00709	6a 00		 push	 0
  0070b	68 ff 00 00 00	 push	 255			; 000000ffH
  00710	6a 04		 push	 4
  00712	51		 push	 ecx
  00713	52		 push	 edx
  00714	57		 push	 edi
  00715	53		 push	 ebx
  00716	50		 push	 eax
  00717	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0071c	83 c4 34	 add	 esp, 52			; 00000034H
  0071f	5f		 pop	 edi
  00720	5e		 pop	 esi
  00721	b8 01 00 00 00	 mov	 eax, 1
  00726	5b		 pop	 ebx

; 3759 : }

  00727	8b e5		 mov	 esp, ebp
  00729	5d		 pop	 ebp
  0072a	c3		 ret	 0
$LN52@gEventMons:

; 3512 : 						return TRUE;
; 3513 : 					}
; 3514 : 				case 8:
; 3515 : 					{
; 3516 : 						level = 5;
; 3517 : 						int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3518 : 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3519 : 							Option1,Option2,Option3, MaxHitUser, 0, 0);

  0072b	6a 00		 push	 0
  0072d	6a 00		 push	 0
  0072f	56		 push	 esi
  00730	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00735	8b 4d f8	 mov	 ecx, DWORD PTR _type$[ebp]
  00738	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  0073b	83 c4 04	 add	 esp, 4
  0073e	50		 push	 eax
  0073f	8b 06		 mov	 eax, DWORD PTR [esi]
  00741	6a 00		 push	 0
  00743	6a 00		 push	 0
  00745	6a 00		 push	 0
  00747	68 ff 00 00 00	 push	 255			; 000000ffH
  0074c	6a 05		 push	 5
  0074e	51		 push	 ecx
  0074f	52		 push	 edx
  00750	57		 push	 edi
  00751	53		 push	 ebx
  00752	50		 push	 eax
  00753	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00758	83 c4 34	 add	 esp, 52			; 00000034H
  0075b	5f		 pop	 edi
  0075c	5e		 pop	 esi
  0075d	b8 01 00 00 00	 mov	 eax, 1
  00762	5b		 pop	 ebx

; 3759 : }

  00763	8b e5		 mov	 esp, ebp
  00765	5d		 pop	 ebp
  00766	c3		 ret	 0
$LN59@gEventMons:

; 3520 : 						return TRUE;
; 3521 : 					}
; 3522 : 			}
; 3523 : 		}
; 3524 : 	}
; 3525 : 
; 3526 : 	if ( gIsDropDarkLordItem )

  00767	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsDropDarkLordItem@@3HA, 0 ; gIsDropDarkLordItem
  0076e	0f 84 70 01 00
	00		 je	 $LN45@gEventMons

; 3527 : 	{
; 3528 : 		if ( lpObj->Level >= gSleeveOfLordDropLevel )

  00774	0f bf 8e 9c 00
	00 00		 movsx	 ecx, WORD PTR [esi+156]
  0077b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gSleeveOfLordDropLevel@@3HA ; gSleeveOfLordDropLevel
  00781	0f 8c 8b 00 00
	00		 jl	 $LN132@gEventMons

; 3529 : 		{
; 3530 : 			if ( (rand()%10000) < gSleeveOfLordDropRate)

  00787	e8 00 00 00 00	 call	 _rand
  0078c	99		 cdq
  0078d	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00792	f7 f9		 idiv	 ecx
  00794	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSleeveOfLordDropRate@@3HA ; gSleeveOfLordDropRate
  0079a	7d 76		 jge	 SHORT $LN132@gEventMons

; 3531 : 			{
; 3532 : 				type = ItemGetNumberMake(13,14);

  0079c	6a 0e		 push	 14			; 0000000eH
  0079e	6a 0d		 push	 13			; 0000000dH
  007a0	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  007a5	83 c4 08	 add	 esp, 8

; 3533 : 				level = 1;
; 3534 : 				x = lpObj->X;
; 3535 : 				y = lpObj->Y;
; 3536 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3537 : 
; 3538 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3539 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  007a8	6a 00		 push	 0
  007aa	6a 00		 push	 0
  007ac	56		 push	 esi
  007ad	8b f8		 mov	 edi, eax
  007af	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  007b4	d9 45 fc	 fld	 DWORD PTR _dur$[ebp]
  007b7	83 c4 04	 add	 esp, 4
  007ba	d9 7d fe	 fnstcw	 WORD PTR tv1260[ebp]
  007bd	50		 push	 eax
  007be	0f b7 45 fe	 movzx	 eax, WORD PTR tv1260[ebp]
  007c2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  007c7	89 45 f0	 mov	 DWORD PTR tv1257[ebp], eax
  007ca	d9 6d f0	 fldcw	 WORD PTR tv1257[ebp]
  007cd	db 5d f0	 fistp	 DWORD PTR tv1255[ebp]
  007d0	8a 55 f0	 mov	 dl, BYTE PTR tv1255[ebp]
  007d3	d9 6d fe	 fldcw	 WORD PTR tv1260[ebp]
$LN146@gEventMons:
  007d6	6a 00		 push	 0
  007d8	6a 00		 push	 0
  007da	0f b6 c2	 movzx	 eax, dl
  007dd	6a 00		 push	 0
  007df	50		 push	 eax
  007e0	6a 01		 push	 1
$LN143@gEventMons:
  007e2	0f b6 8e 06 01
	00 00		 movzx	 ecx, BYTE PTR [esi+262]
  007e9	0f b6 96 04 01
	00 00		 movzx	 edx, BYTE PTR [esi+260]
  007f0	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  007f7	57		 push	 edi
  007f8	51		 push	 ecx
  007f9	8b 0e		 mov	 ecx, DWORD PTR [esi]
  007fb	52		 push	 edx
  007fc	50		 push	 eax
  007fd	51		 push	 ecx
  007fe	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00803	83 c4 34	 add	 esp, 52			; 00000034H
  00806	5f		 pop	 edi
  00807	5e		 pop	 esi
  00808	b8 01 00 00 00	 mov	 eax, 1
  0080d	5b		 pop	 ebx

; 3759 : }

  0080e	8b e5		 mov	 esp, ebp
  00810	5d		 pop	 ebp
  00811	c3		 ret	 0
$LN132@gEventMons:

; 3540 : 
; 3541 : 				return TRUE;
; 3542 : 			}
; 3543 : 		}
; 3544 : 
; 3545 : 		if ( lpObj->Level >= gSoulOfDarkHorseropLevel )

  00812	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00819	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSoulOfDarkHorseropLevel@@3HA ; gSoulOfDarkHorseropLevel
  0081f	7c 60		 jl	 SHORT $LN134@gEventMons

; 3546 : 		{
; 3547 : 			if ( (rand()%10000) < gSoulOfDarkHorseDropRate)

  00821	e8 00 00 00 00	 call	 _rand
  00826	99		 cdq
  00827	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0082c	f7 f9		 idiv	 ecx
  0082e	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSoulOfDarkHorseDropRate@@3HA ; gSoulOfDarkHorseDropRate
  00834	7d 4b		 jge	 SHORT $LN134@gEventMons

; 3548 : 			{
; 3549 : 				type = ItemGetNumberMake(13,31);

  00836	6a 1f		 push	 31			; 0000001fH
  00838	6a 0d		 push	 13			; 0000000dH
  0083a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0083f	83 c4 08	 add	 esp, 8

; 3550 : 				level = 0;
; 3551 : 				x = lpObj->X;
; 3552 : 				y = lpObj->Y;
; 3553 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3554 : 
; 3555 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3556 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  00842	6a 00		 push	 0
  00844	6a 00		 push	 0
  00846	56		 push	 esi
  00847	8b f8		 mov	 edi, eax
  00849	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0084e	d9 45 fc	 fld	 DWORD PTR _dur$[ebp]
  00851	83 c4 04	 add	 esp, 4
  00854	d9 7d fe	 fnstcw	 WORD PTR tv1235[ebp]
  00857	50		 push	 eax
  00858	0f b7 45 fe	 movzx	 eax, WORD PTR tv1235[ebp]
  0085c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00861	89 45 f0	 mov	 DWORD PTR tv1232[ebp], eax
  00864	6a 00		 push	 0
  00866	6a 00		 push	 0
  00868	d9 6d f0	 fldcw	 WORD PTR tv1232[ebp]
  0086b	6a 00		 push	 0
  0086d	db 5d f0	 fistp	 DWORD PTR tv1230[ebp]
  00870	8a 55 f0	 mov	 dl, BYTE PTR tv1230[ebp]
  00873	0f b6 c2	 movzx	 eax, dl
  00876	50		 push	 eax
  00877	d9 6d fe	 fldcw	 WORD PTR tv1235[ebp]
  0087a	6a 00		 push	 0

; 3557 : 
; 3558 : 				return TRUE;

  0087c	e9 61 ff ff ff	 jmp	 $LN143@gEventMons
$LN134@gEventMons:

; 3559 : 			}
; 3560 : 		}
; 3561 : 
; 3562 : 		if ( lpObj->Level >= gSoulOfDarkSpiritDropLevel )

  00881	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00888	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSoulOfDarkSpiritDropLevel@@3HA ; gSoulOfDarkSpiritDropLevel
  0088e	7c 54		 jl	 SHORT $LN45@gEventMons

; 3563 : 		{
; 3564 : 			if ( (rand()%10000) < gSoulOfDarkSpiritDropRate )

  00890	e8 00 00 00 00	 call	 _rand
  00895	99		 cdq
  00896	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0089b	f7 f9		 idiv	 ecx
  0089d	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gSoulOfDarkSpiritDropRate@@3HA ; gSoulOfDarkSpiritDropRate
  008a3	7d 3f		 jge	 SHORT $LN45@gEventMons

; 3565 : 			{
; 3566 : 				type = ItemGetNumberMake(13,31);

  008a5	6a 1f		 push	 31			; 0000001fH
  008a7	6a 0d		 push	 13			; 0000000dH
  008a9	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  008ae	83 c4 08	 add	 esp, 8

; 3567 : 				level = 1;
; 3568 : 				x = lpObj->X;
; 3569 : 				y = lpObj->Y;
; 3570 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3571 : 
; 3572 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3573 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  008b1	6a 00		 push	 0
  008b3	6a 00		 push	 0
  008b5	56		 push	 esi
  008b6	8b f8		 mov	 edi, eax
  008b8	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  008bd	d9 45 fc	 fld	 DWORD PTR _dur$[ebp]
  008c0	83 c4 04	 add	 esp, 4
  008c3	d9 7d fe	 fnstcw	 WORD PTR tv1209[ebp]
  008c6	50		 push	 eax
  008c7	0f b7 45 fe	 movzx	 eax, WORD PTR tv1209[ebp]
  008cb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  008d0	89 45 f0	 mov	 DWORD PTR tv1207[ebp], eax
  008d3	d9 6d f0	 fldcw	 WORD PTR tv1207[ebp]
  008d6	db 5d f0	 fistp	 DWORD PTR tv1205[ebp]
  008d9	8a 55 f0	 mov	 dl, BYTE PTR tv1205[ebp]
  008dc	d9 6d fe	 fldcw	 WORD PTR tv1209[ebp]

; 3574 : 
; 3575 : 				return TRUE;

  008df	e9 f2 fe ff ff	 jmp	 $LN146@gEventMons
$LN45@gEventMons:

; 3576 : 			}
; 3577 : 		}
; 3578 : 	}
; 3579 : 
; 3580 : 	if ( gIsDropGemOfDefend )

  008e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gIsDropGemOfDefend@@3HA, 0 ; gIsDropGemOfDefend
  008eb	74 7d		 je	 SHORT $LN133@gEventMons

; 3581 : 	{
; 3582 : 		if ( lpObj->MapNumber != MAP_INDEX_KALIMA7 && lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE )

  008ed	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  008f3	3c 24		 cmp	 al, 36			; 00000024H
  008f5	74 04		 je	 SHORT $LN43@gEventMons
  008f7	3c 1f		 cmp	 al, 31			; 0000001fH
  008f9	75 6f		 jne	 SHORT $LN133@gEventMons
$LN43@gEventMons:

; 3583 : 		{
; 3584 : 		}
; 3585 : 		else
; 3586 : 		{
; 3587 : 			if ( lpObj->Level >= gGemOfDefendDropLevel )

  008fb	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00902	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gGemOfDefendDropLevel@@3HA ; gGemOfDefendDropLevel
  00908	7c 60		 jl	 SHORT $LN133@gEventMons

; 3588 : 			{
; 3589 : 				if ( (rand()%10000)< gGemOfDefendDropRate )

  0090a	e8 00 00 00 00	 call	 _rand
  0090f	99		 cdq
  00910	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00915	f7 f9		 idiv	 ecx
  00917	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?gGemOfDefendDropRate@@3HA ; gGemOfDefendDropRate
  0091d	7d 4b		 jge	 SHORT $LN133@gEventMons

; 3590 : 				{
; 3591 : 					type = ItemGetNumberMake(14,31);

  0091f	6a 1f		 push	 31			; 0000001fH
  00921	6a 0e		 push	 14			; 0000000eH
  00923	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00928	83 c4 08	 add	 esp, 8

; 3592 : 					level = 0;
; 3593 : 					x = lpObj->X;
; 3594 : 					y = lpObj->Y;
; 3595 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3596 : 
; 3597 : 					ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3598 : 						Option1,Option2,Option3, MaxHitUser, 0, 0);

  0092b	6a 00		 push	 0
  0092d	6a 00		 push	 0
  0092f	56		 push	 esi
  00930	8b f8		 mov	 edi, eax
  00932	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00937	d9 45 fc	 fld	 DWORD PTR _dur$[ebp]
  0093a	83 c4 04	 add	 esp, 4
  0093d	d9 7d fe	 fnstcw	 WORD PTR tv1185[ebp]
  00940	50		 push	 eax
  00941	0f b7 45 fe	 movzx	 eax, WORD PTR tv1185[ebp]
  00945	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0094a	89 45 f0	 mov	 DWORD PTR tv1155[ebp], eax
  0094d	6a 00		 push	 0
  0094f	6a 00		 push	 0
  00951	d9 6d f0	 fldcw	 WORD PTR tv1155[ebp]
  00954	6a 00		 push	 0
  00956	db 5d f0	 fistp	 DWORD PTR tv1153[ebp]
  00959	8a 55 f0	 mov	 dl, BYTE PTR tv1153[ebp]
  0095c	0f b6 c2	 movzx	 eax, dl
  0095f	50		 push	 eax
  00960	d9 6d fe	 fldcw	 WORD PTR tv1185[ebp]
  00963	6a 00		 push	 0

; 3599 : 
; 3600 : 					return TRUE;

  00965	e9 78 fe ff ff	 jmp	 $LN143@gEventMons
$LN133@gEventMons:

; 3601 : 				}
; 3602 : 			}
; 3603 : 		}
; 3604 : 	}
; 3605 : 
; 3606 : #if GS_CASTLE == 1 
; 3607 : 	if ( gIsDropSetItemInCastleHuntZone )
; 3608 : 	{
; 3609 : 		if ( lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE )
; 3610 : 		{
; 3611 : 		}
; 3612 : 		else
; 3613 : 		{
; 3614 : 			if ( lpObj->Level >= gSetItemInCastleHuntZoneDropLevel )
; 3615 : 			{
; 3616 : 				if ( (rand()%10000) < gSetItemInCastleHuntZoneDropRate )
; 3617 : 				{
; 3618 : 					int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3619 : 
; 3620 : 					if ( CHECK_LIMIT(MaxHitUser, OBJMAX) )
; 3621 : 					{
; 3622 : 						LogAdd(LOG_BLACK, "[Castle HuntZone] Drop SetItem [%s][%s] ",
; 3623 : 							gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name);
; 3624 : 			
; 3625 : 						MakeRewardSetItem(MaxHitUser, lpObj->X, lpObj->Y, 0, lpObj->MapNumber);
; 3626 : 						return TRUE;
; 3627 : 					}
; 3628 : 				}
; 3629 : 			}
; 3630 : 		}
; 3631 : 	}
; 3632 : #endif
; 3633 : 	if(lpObj->MapNumber == MAP_INDEX_AIDA)

  0096a	80 be 09 01 00
	00 21		 cmp	 BYTE PTR [esi+265], 33	; 00000021H
  00971	0f 85 98 00 00
	00		 jne	 $LN135@gEventMons

; 3634 : 	{
; 3635 : 		bool bDropMysteriousBead = false;
; 3636 : 
; 3637 : 		switch ( lpObj->Class )

  00977	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0097e	05 d0 fe ff ff	 add	 eax, -304		; fffffed0H
  00983	83 f8 09	 cmp	 eax, 9
  00986	0f 87 83 00 00
	00		 ja	 $LN135@gEventMons
  0098c	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN129@gEventMons[eax]
  00993	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN148@gEventMons[edx*4]
$LN36@gEventMons:

; 3638 : 		{
; 3639 : 			case 304:	case 305:	case 306:
; 3640 : 			case 307:	case 308:	case 309:
; 3641 : 				if ( (rand()%10000) < g_iMysteriousBeadDropRate1 )

  0099a	e8 00 00 00 00	 call	 _rand
  0099f	99		 cdq
  009a0	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  009a5	f7 f9		 idiv	 ecx
  009a7	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iMysteriousBeadDropRate1@@3HA ; g_iMysteriousBeadDropRate1

; 3642 : 					bDropMysteriousBead = true;
; 3643 : 				break;

  009ad	eb 13		 jmp	 SHORT $LN137@gEventMons
$LN34@gEventMons:

; 3644 : 
; 3645 : 			case 310:	case 311:	case 312:	case 313:
; 3646 : 				if ( (rand()%10000) < g_iMysteriousBeadDropRate2 )

  009af	e8 00 00 00 00	 call	 _rand
  009b4	99		 cdq
  009b5	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  009ba	f7 f9		 idiv	 ecx
  009bc	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iMysteriousBeadDropRate2@@3HA ; g_iMysteriousBeadDropRate2
$LN137@gEventMons:
  009c2	7d 4b		 jge	 SHORT $LN135@gEventMons

; 3647 : 					bDropMysteriousBead = true;
; 3648 : 				break;
; 3649 : 		}
; 3650 : 
; 3651 : 		if ( bDropMysteriousBead == true )
; 3652 : 		{
; 3653 : 			type = ItemGetNumberMake(12,26);

  009c4	6a 1a		 push	 26			; 0000001aH
  009c6	6a 0c		 push	 12			; 0000000cH
  009c8	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  009cd	83 c4 08	 add	 esp, 8

; 3654 : 			level = 0;
; 3655 : 			x = lpObj->X;
; 3656 : 			y = lpObj->Y;
; 3657 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3658 : 
; 3659 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3660 : 				Option1,Option2,Option3, MaxHitUser, 0, 0);

  009d0	6a 00		 push	 0
  009d2	6a 00		 push	 0
  009d4	56		 push	 esi
  009d5	8b f8		 mov	 edi, eax
  009d7	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  009dc	d9 45 fc	 fld	 DWORD PTR _dur$[ebp]
  009df	83 c4 04	 add	 esp, 4
  009e2	d9 7d fe	 fnstcw	 WORD PTR tv1126[ebp]
  009e5	50		 push	 eax
  009e6	0f b7 45 fe	 movzx	 eax, WORD PTR tv1126[ebp]
  009ea	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  009ef	89 45 f0	 mov	 DWORD PTR tv1121[ebp], eax
  009f2	6a 00		 push	 0
  009f4	6a 00		 push	 0
  009f6	d9 6d f0	 fldcw	 WORD PTR tv1121[ebp]
  009f9	6a 00		 push	 0
  009fb	db 5d f0	 fistp	 DWORD PTR tv1119[ebp]
  009fe	8a 55 f0	 mov	 dl, BYTE PTR tv1119[ebp]
  00a01	0f b6 c2	 movzx	 eax, dl
  00a04	50		 push	 eax
  00a05	d9 6d fe	 fldcw	 WORD PTR tv1126[ebp]
  00a08	6a 00		 push	 0

; 3661 : 
; 3662 : 			return TRUE;

  00a0a	e9 d3 fd ff ff	 jmp	 $LN143@gEventMons
$LN135@gEventMons:

; 3663 : 		}
; 3664 : 	}
; 3665 : 
; 3666 : 	if ( g_bBloodCastle )

  00a0f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bBloodCastle@@3HA, 0 ; g_bBloodCastle
  00a16	0f 84 6d 01 00
	00		 je	 $LN136@gEventMons

; 3667 : 	{
; 3668 : 		if ( !BC_MAP_RANGE(lpObj->MapNumber ) )

  00a1c	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00a23	3c 0b		 cmp	 al, 11			; 0000000bH
  00a25	72 0d		 jb	 SHORT $LN128@gEventMons
  00a27	b2 11		 mov	 dl, 17			; 00000011H
  00a29	3a d0		 cmp	 dl, al
  00a2b	1b c0		 sbb	 eax, eax
  00a2d	40		 inc	 eax
  00a2e	0f 85 55 01 00
	00		 jne	 $LN136@gEventMons
$LN128@gEventMons:

; 3669 : 		{
; 3670 : 			Option1=0;
; 3671 : 			Option2=0;
; 3672 : 			Option3=0;
; 3673 : 
; 3674 : 			if ( (rand()%10000) < g_iAngelKingsPaperDropRate )

  00a34	e8 00 00 00 00	 call	 _rand
  00a39	99		 cdq
  00a3a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00a3f	f7 f9		 idiv	 ecx
  00a41	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iAngelKingsPaperDropRate@@3HA ; g_iAngelKingsPaperDropRate
  00a47	0f 8d 9e 00 00
	00		 jge	 $LN29@gEventMons

; 3675 : 			{
; 3676 : 				dur = 128.0f;
; 3677 : 				x = lpObj->X;
; 3678 : 				y = lpObj->Y;

  00a4d	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00a54	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00a5b	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax

; 3679 : 
; 3680 : 				if ( lpObj->Level < 32 )

  00a5e	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  00a65	89 55 f8	 mov	 DWORD PTR _x$[ebp], edx
  00a68	66 83 f8 20	 cmp	 ax, 32			; 00000020H
  00a6c	7d 07		 jge	 SHORT $LN28@gEventMons

; 3681 : 					level = 1;

  00a6e	bf 01 00 00 00	 mov	 edi, 1
  00a73	eb 40		 jmp	 SHORT $LN18@gEventMons
$LN28@gEventMons:

; 3682 : 				else if ( lpObj->Level < 45 )

  00a75	66 83 f8 2d	 cmp	 ax, 45			; 0000002dH
  00a79	7d 07		 jge	 SHORT $LN26@gEventMons

; 3683 : 					level = 2;

  00a7b	bf 02 00 00 00	 mov	 edi, 2
  00a80	eb 33		 jmp	 SHORT $LN18@gEventMons
$LN26@gEventMons:

; 3684 : 				else if ( lpObj->Level < 57 )

  00a82	66 83 f8 39	 cmp	 ax, 57			; 00000039H
  00a86	7d 07		 jge	 SHORT $LN24@gEventMons

; 3685 : 					level = 3;

  00a88	bf 03 00 00 00	 mov	 edi, 3
  00a8d	eb 26		 jmp	 SHORT $LN18@gEventMons
$LN24@gEventMons:

; 3686 : 				else if ( lpObj->Level < 68 )

  00a8f	66 83 f8 44	 cmp	 ax, 68			; 00000044H
  00a93	7d 07		 jge	 SHORT $LN22@gEventMons

; 3687 : 					level = 4;

  00a95	bf 04 00 00 00	 mov	 edi, 4
  00a9a	eb 19		 jmp	 SHORT $LN18@gEventMons
$LN22@gEventMons:

; 3688 : 				else if ( lpObj->Level < 76 )

  00a9c	66 83 f8 4c	 cmp	 ax, 76			; 0000004cH
  00aa0	7d 07		 jge	 SHORT $LN20@gEventMons

; 3689 : 					level = 5;

  00aa2	bf 05 00 00 00	 mov	 edi, 5
  00aa7	eb 0c		 jmp	 SHORT $LN18@gEventMons
$LN20@gEventMons:

; 3690 : 				else if ( lpObj->Level < 84 )

  00aa9	33 c9		 xor	 ecx, ecx
  00aab	66 83 f8 54	 cmp	 ax, 84			; 00000054H
  00aaf	0f 9d c1	 setge	 cl
  00ab2	8d 79 06	 lea	 edi, DWORD PTR [ecx+6]
$LN18@gEventMons:

; 3691 : 					level = 6;
; 3692 : 				else
; 3693 : 					level = 7;
; 3694 : 
; 3695 : 				type = ItemGetNumberMake(13,16);

  00ab5	6a 10		 push	 16			; 00000010H
$LN142@gEventMons:
  00ab7	6a 0d		 push	 13			; 0000000dH
  00ab9	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00abe	83 c4 08	 add	 esp, 8

; 3696 : 
; 3697 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3698 : 
; 3699 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3700 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);

  00ac1	6a 00		 push	 0
  00ac3	6a 00		 push	 0
  00ac5	56		 push	 esi
  00ac6	8b d8		 mov	 ebx, eax
  00ac8	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00acd	8b 55 f4	 mov	 edx, DWORD PTR _y$[ebp]
  00ad0	83 c4 04	 add	 esp, 4
  00ad3	50		 push	 eax
  00ad4	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00ad7	6a 00		 push	 0
  00ad9	6a 00		 push	 0
  00adb	6a 00		 push	 0
  00add	68 80 00 00 00	 push	 128			; 00000080H
  00ae2	57		 push	 edi
  00ae3	53		 push	 ebx
  00ae4	52		 push	 edx
  00ae5	50		 push	 eax

; 3701 : 
; 3702 : 				return TRUE;

  00ae6	e9 0b f6 ff ff	 jmp	 $LN139@gEventMons
$LN29@gEventMons:

; 3703 : 			}
; 3704 : 
; 3705 : 			if ( (rand()%10000) < g_iBloodBoneDropRate )

  00aeb	e8 00 00 00 00	 call	 _rand
  00af0	99		 cdq
  00af1	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00af6	f7 f9		 idiv	 ecx
  00af8	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iBloodBoneDropRate@@3HA ; g_iBloodBoneDropRate
  00afe	0f 8d 85 00 00
	00		 jge	 $LN136@gEventMons

; 3706 : 			{
; 3707 : 				dur = 128.0f;
; 3708 : 				x = lpObj->X;
; 3709 : 				y = lpObj->Y;

  00b04	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  00b0b	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00b12	89 45 f4	 mov	 DWORD PTR _y$[ebp], eax

; 3710 : 
; 3711 : 				if ( lpObj->Level < 32 )

  00b15	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  00b1c	89 55 f8	 mov	 DWORD PTR _x$[ebp], edx
  00b1f	66 83 f8 20	 cmp	 ax, 32			; 00000020H
  00b23	7d 09		 jge	 SHORT $LN15@gEventMons

; 3712 : 					level = 1;

  00b25	bf 01 00 00 00	 mov	 edi, 1

; 3722 : 					level = 6;
; 3723 : 				else
; 3724 : 					level = 7;
; 3725 : 
; 3726 : 				type = ItemGetNumberMake(13,17);

  00b2a	6a 11		 push	 17			; 00000011H

; 3727 : 
; 3728 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3729 : 
; 3730 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3731 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3732 : 
; 3733 : 				return TRUE;

  00b2c	eb 89		 jmp	 SHORT $LN142@gEventMons
$LN15@gEventMons:

; 3713 : 				else if ( lpObj->Level < 45 )

  00b2e	66 83 f8 2d	 cmp	 ax, 45			; 0000002dH
  00b32	7d 0c		 jge	 SHORT $LN13@gEventMons

; 3714 : 					level = 2;

  00b34	bf 02 00 00 00	 mov	 edi, 2

; 3722 : 					level = 6;
; 3723 : 				else
; 3724 : 					level = 7;
; 3725 : 
; 3726 : 				type = ItemGetNumberMake(13,17);

  00b39	6a 11		 push	 17			; 00000011H

; 3727 : 
; 3728 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3729 : 
; 3730 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3731 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3732 : 
; 3733 : 				return TRUE;

  00b3b	e9 77 ff ff ff	 jmp	 $LN142@gEventMons
$LN13@gEventMons:

; 3715 : 				else if ( lpObj->Level < 57 )

  00b40	66 83 f8 39	 cmp	 ax, 57			; 00000039H
  00b44	7d 0c		 jge	 SHORT $LN11@gEventMons

; 3716 : 					level = 3;

  00b46	bf 03 00 00 00	 mov	 edi, 3

; 3722 : 					level = 6;
; 3723 : 				else
; 3724 : 					level = 7;
; 3725 : 
; 3726 : 				type = ItemGetNumberMake(13,17);

  00b4b	6a 11		 push	 17			; 00000011H

; 3727 : 
; 3728 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3729 : 
; 3730 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3731 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3732 : 
; 3733 : 				return TRUE;

  00b4d	e9 65 ff ff ff	 jmp	 $LN142@gEventMons
$LN11@gEventMons:

; 3717 : 				else if ( lpObj->Level < 68 )

  00b52	66 83 f8 44	 cmp	 ax, 68			; 00000044H
  00b56	7d 0c		 jge	 SHORT $LN9@gEventMons

; 3718 : 					level = 4;

  00b58	bf 04 00 00 00	 mov	 edi, 4

; 3722 : 					level = 6;
; 3723 : 				else
; 3724 : 					level = 7;
; 3725 : 
; 3726 : 				type = ItemGetNumberMake(13,17);

  00b5d	6a 11		 push	 17			; 00000011H

; 3727 : 
; 3728 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3729 : 
; 3730 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3731 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3732 : 
; 3733 : 				return TRUE;

  00b5f	e9 53 ff ff ff	 jmp	 $LN142@gEventMons
$LN9@gEventMons:

; 3719 : 				else if ( lpObj->Level < 76 )

  00b64	66 83 f8 4c	 cmp	 ax, 76			; 0000004cH
  00b68	7d 0c		 jge	 SHORT $LN7@gEventMons

; 3720 : 					level = 5;

  00b6a	bf 05 00 00 00	 mov	 edi, 5

; 3722 : 					level = 6;
; 3723 : 				else
; 3724 : 					level = 7;
; 3725 : 
; 3726 : 				type = ItemGetNumberMake(13,17);

  00b6f	6a 11		 push	 17			; 00000011H

; 3727 : 
; 3728 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3729 : 
; 3730 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3731 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3732 : 
; 3733 : 				return TRUE;

  00b71	e9 41 ff ff ff	 jmp	 $LN142@gEventMons
$LN7@gEventMons:

; 3721 : 				else if ( lpObj->Level < 84 )

  00b76	33 c9		 xor	 ecx, ecx
  00b78	66 83 f8 54	 cmp	 ax, 84			; 00000054H
  00b7c	0f 9d c1	 setge	 cl

; 3722 : 					level = 6;
; 3723 : 				else
; 3724 : 					level = 7;
; 3725 : 
; 3726 : 				type = ItemGetNumberMake(13,17);

  00b7f	6a 11		 push	 17			; 00000011H
  00b81	8d 79 06	 lea	 edi, DWORD PTR [ecx+6]

; 3727 : 
; 3728 : 				int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3729 : 
; 3730 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3731 : 					Option1,Option2,Option3, MaxHitUser, 0, 0);
; 3732 : 
; 3733 : 				return TRUE;

  00b84	e9 2e ff ff ff	 jmp	 $LN142@gEventMons
$LN136@gEventMons:

; 3734 : 			}
; 3735 : 		}
; 3736 : 	}
; 3737 : 
; 3738 : 	if ( (rand()%10000) < g_iDarkLordHeartDropRate )

  00b89	e8 00 00 00 00	 call	 _rand
  00b8e	99		 cdq
  00b8f	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00b94	f7 f9		 idiv	 ecx
  00b96	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_iDarkLordHeartDropRate@@3HA ; g_iDarkLordHeartDropRate
  00b9c	7d 6b		 jge	 SHORT $LN2@gEventMons

; 3739 : 	{
; 3740 : 		int iDropRate = 0;
; 3741 : 
; 3742 : 		if ( lpTargetObj->MapNumber == 0 || lpTargetObj->MapNumber == 3 || lpTargetObj->MapNumber == 2 )

  00b9e	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00ba1	8a 82 09 01 00
	00		 mov	 al, BYTE PTR [edx+265]
  00ba7	84 c0		 test	 al, al
  00ba9	74 08		 je	 SHORT $LN1@gEventMons
  00bab	3c 03		 cmp	 al, 3
  00bad	74 04		 je	 SHORT $LN1@gEventMons
  00baf	3c 02		 cmp	 al, 2
  00bb1	75 56		 jne	 SHORT $LN2@gEventMons
$LN1@gEventMons:

; 3743 : 		{
; 3744 : 			type = ItemGetNumberMake(14,11);

  00bb3	6a 0b		 push	 11			; 0000000bH
  00bb5	6a 0e		 push	 14			; 0000000eH
  00bb7	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00bbc	83 c4 08	 add	 esp, 8

; 3745 : 			level = 13;
; 3746 : 			x = lpObj->X;
; 3747 : 			y = lpObj->Y;
; 3748 : 			dur = 0;
; 3749 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 3750 : 
; 3751 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3752 : 				Option1,Option2,Option3, MaxHitUser, 0, 0);

  00bbf	6a 00		 push	 0
  00bc1	6a 00		 push	 0
  00bc3	56		 push	 esi
  00bc4	8b f8		 mov	 edi, eax
  00bc6	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00bcb	0f b6 8e 04 01
	00 00		 movzx	 ecx, BYTE PTR [esi+260]
  00bd2	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  00bd9	83 c4 04	 add	 esp, 4
  00bdc	50		 push	 eax
  00bdd	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  00be4	6a 00		 push	 0
  00be6	6a 00		 push	 0
  00be8	6a 00		 push	 0
  00bea	6a 00		 push	 0
  00bec	6a 0d		 push	 13			; 0000000dH
  00bee	57		 push	 edi
  00bef	50		 push	 eax
  00bf0	8b 06		 mov	 eax, DWORD PTR [esi]
  00bf2	51		 push	 ecx
  00bf3	52		 push	 edx
  00bf4	50		 push	 eax
  00bf5	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00bfa	83 c4 34	 add	 esp, 52			; 00000034H
  00bfd	5f		 pop	 edi
  00bfe	5e		 pop	 esi
  00bff	b8 01 00 00 00	 mov	 eax, 1
  00c04	5b		 pop	 ebx

; 3759 : }

  00c05	8b e5		 mov	 esp, ebp
  00c07	5d		 pop	 ebp
  00c08	c3		 ret	 0
$LN2@gEventMons:
  00c09	5f		 pop	 edi
  00c0a	5e		 pop	 esi

; 3753 : 
; 3754 : 			return TRUE;
; 3755 : 		}
; 3756 : 	}
; 3757 : 
; 3758 : 	return FALSE;

  00c0b	33 c0		 xor	 eax, eax
  00c0d	5b		 pop	 ebx

; 3759 : }

  00c0e	8b e5		 mov	 esp, ebp
  00c10	5d		 pop	 ebp
  00c11	c3		 ret	 0
  00c12	8b ff		 npad	 2
$LN147@gEventMons:
  00c14	00 00 00 00	 DD	 $LN58@gEventMons
  00c18	00 00 00 00	 DD	 $LN57@gEventMons
  00c1c	00 00 00 00	 DD	 $LN57@gEventMons
  00c20	00 00 00 00	 DD	 $LN58@gEventMons
  00c24	00 00 00 00	 DD	 $LN54@gEventMons
  00c28	00 00 00 00	 DD	 $LN59@gEventMons
  00c2c	00 00 00 00	 DD	 $LN59@gEventMons
  00c30	00 00 00 00	 DD	 $LN53@gEventMons
  00c34	00 00 00 00	 DD	 $LN52@gEventMons
$LN148@gEventMons:
  00c38	00 00 00 00	 DD	 $LN36@gEventMons
  00c3c	00 00 00 00	 DD	 $LN34@gEventMons
$LN129@gEventMons:
  00c40	00		 DB	 0
  00c41	00		 DB	 0
  00c42	00		 DB	 0
  00c43	00		 DB	 0
  00c44	00		 DB	 0
  00c45	00		 DB	 0
  00c46	01		 DB	 1
  00c47	01		 DB	 1
  00c48	01		 DB	 1
  00c49	01		 DB	 1
?gEventMonsterItemDrop@@YAHPAUOBJECTSTRUCT@@0@Z ENDP	; gEventMonsterItemDrop
_TEXT	ENDS
PUBLIC	??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP?$AA@ ; `string'
PUBLIC	?Run@CQeustNpcTeleport@@QAEXH@Z			; CQeustNpcTeleport::Run
EXTRN	?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjClearViewport
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?gQuestNPCTeleportTime@@3HA:DWORD		; gQuestNPCTeleportTime
;	COMDAT ??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP?$AA@
CONST	SEGMENT
??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP?$AA@ DB 'NPC %d', 0b7H
	DB	0ceH, ' ', 0c0H, 0ccH, 0b5H, 0bfH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Run@CQeustNpcTeleport@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$159103 = -8					; size = 8
_aIndex$ = 8						; size = 4
?Run@CQeustNpcTeleport@@QAEXH@Z PROC			; CQeustNpcTeleport::Run, COMDAT
; _this$ = ecx

; 3762 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 3763 : 	if ( this->RefCount > 0 )

  00009	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0000c	0f 8f 34 01 00
	00		 jg	 $LN4@Run

; 3764 : 	{
; 3765 : 		return;
; 3766 : 	}
; 3767 : 
; 3768 : 	this->TimeCount++;

  00012	ff 47 1c	 inc	 DWORD PTR [edi+28]
  00015	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]

; 3769 : 
; 3770 : 	if ( this->TimeCount > gQuestNPCTeleportTime )

  00018	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gQuestNPCTeleportTime@@3HA ; gQuestNPCTeleportTime
  0001e	0f 8e 22 01 00
	00		 jle	 $LN4@Run

; 3771 : 	{
; 3772 : 		PMSG_MAGICATTACK_RESULT pMsg;
; 3773 : 
; 3774 : 		this->TimeCount = 0;
; 3775 : 
; 3776 : 		PHeadSetBE((LPBYTE)&pMsg, 0x19, sizeof(pMsg));

  00024	53		 push	 ebx
  00025	56		 push	 esi
  00026	6a 08		 push	 8
  00028	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$159103[ebp]
  0002b	6a 19		 push	 25			; 00000019H
  0002d	50		 push	 eax
  0002e	c7 47 1c 00 00
	00 00		 mov	 DWORD PTR [edi+28], 0
  00035	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE

; 3777 : 		pMsg.MagicNumber = 6;
; 3778 : 		pMsg.SourceNumberH = SET_NUMBERH(aIndex);

  0003a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]

; 3779 : 		pMsg.SourceNumberL = SET_NUMBERL(aIndex);
; 3780 : 		pMsg.TargetNumberH = SET_NUMBERH(aIndex);
; 3781 : 		pMsg.TargetNumberL = SET_NUMBERL(aIndex);
; 3782 : 
; 3783 : 		MsgSendV2(&gObj[aIndex], (UCHAR*)&pMsg, pMsg.h.size);

  0003d	8b f0		 mov	 esi, eax
  0003f	8b c8		 mov	 ecx, eax
  00041	69 f6 64 15 00
	00		 imul	 esi, 5476		; 00001564H
  00047	c1 e9 08	 shr	 ecx, 8
  0004a	88 4d fc	 mov	 BYTE PTR _pMsg$159103[ebp+4], cl
  0004d	88 4d fe	 mov	 BYTE PTR _pMsg$159103[ebp+6], cl
  00050	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$159103[ebp+1]
  00054	51		 push	 ecx
  00055	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$159103[ebp]
  00058	52		 push	 edx
  00059	8d 9e 00 00 00
	00		 lea	 ebx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi]
  0005f	53		 push	 ebx
  00060	c6 45 fb 06	 mov	 BYTE PTR _pMsg$159103[ebp+3], 6
  00064	88 45 fd	 mov	 BYTE PTR _pMsg$159103[ebp+5], al
  00067	88 45 ff	 mov	 BYTE PTR _pMsg$159103[ebp+7], al
  0006a	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAUOBJECTSTRUCT@@PAEH@Z ; MsgSendV2

; 3784 : 		gObjViewportListProtocolDestroy(&gObj[aIndex]);

  0006f	53		 push	 ebx
  00070	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 3785 : 		gObjClearViewport(&gObj[aIndex]);

  00075	53		 push	 ebx
  00076	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport
  0007b	83 c4 20	 add	 esp, 32			; 00000020H
  0007e	8b ff		 npad	 2
$LL3@Run:

; 3786 : 
; 3787 : 		int tableindex;
; 3788 : 
; 3789 : 		while ( true )
; 3790 : 		{
; 3791 : 			tableindex = rand() % MAX_QUEST_TELEPORT;

  00080	e8 00 00 00 00	 call	 _rand
  00085	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0008a	79 05		 jns	 SHORT $LN10@Run
  0008c	48		 dec	 eax
  0008d	83 c8 fc	 or	 eax, -4			; fffffffcH
  00090	40		 inc	 eax
$LN10@Run:

; 3792 : 
; 3793 : 			if ( this->LastMapNumber != tableindex )

  00091	39 47 20	 cmp	 DWORD PTR [edi+32], eax
  00094	74 ea		 je	 SHORT $LL3@Run

; 3794 : 			{
; 3795 : 				this->LastMapNumber = tableindex;

  00096	89 47 20	 mov	 DWORD PTR [edi+32], eax

; 3796 : 				break;
; 3797 : 			}
; 3798 : 		}
; 3799 : 
; 3800 : 		gObj[aIndex].X = this->m_QuestNPCTeleportPos[tableindex].x;

  00099	8b c8		 mov	 ecx, eax
  0009b	03 c9		 add	 ecx, ecx
  0009d	0f b7 54 cf 28	 movzx	 edx, WORD PTR [edi+ecx*8+40]
  000a2	66 89 96 04 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260], dx

; 3801 : 		gObj[aIndex].Y = this->m_QuestNPCTeleportPos[tableindex].y;

  000a9	0f b7 54 cf 2c	 movzx	 edx, WORD PTR [edi+ecx*8+44]
  000ae	66 89 96 06 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262], dx

; 3802 : 		gObj[aIndex].TX = gObj[aIndex].X;

  000b5	0f b7 96 04 01
	00 00		 movzx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]

; 3803 : 		gObj[aIndex].TY = gObj[aIndex].Y;

  000bc	0f b7 9e 06 01
	00 00		 movzx	 ebx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  000c3	66 89 96 20 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+288], dx

; 3804 : 		gObj[aIndex].MTX = gObj[aIndex].X;

  000ca	66 89 96 24 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+292], dx

; 3805 : 		gObj[aIndex].MTY = gObj[aIndex].Y;
; 3806 : 		gObj[aIndex].m_OldX = gObj[aIndex].TX;

  000d1	66 89 96 1c 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+284], dx
  000d8	66 89 9e 22 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+290], bx
  000df	66 89 9e 26 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+294], bx

; 3807 : 		gObj[aIndex].m_OldY = gObj[aIndex].TY;

  000e6	66 89 9e 1e 01
	00 00		 mov	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+286], bx

; 3808 : 		gObj[aIndex].MapNumber = this->m_QuestNPCTeleportPos[tableindex].mapnum;

  000ed	0f b6 4c cf 24	 movzx	 ecx, BYTE PTR [edi+ecx*8+36]

; 3809 : 		gObj[aIndex].Dir = this->m_QuestNPCTeleportPos[tableindex].dir;

  000f2	8d 50 03	 lea	 edx, DWORD PTR [eax+3]
  000f5	03 d2		 add	 edx, edx
  000f7	88 8e 09 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+265], cl
  000fd	0f b6 0c d7	 movzx	 ecx, BYTE PTR [edi+edx*8]

; 3810 : 		gObj[aIndex].StartX = gObj[aIndex].X;

  00101	8a 96 04 01 00
	00		 mov	 dl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+260]

; 3811 : 		gObj[aIndex].StartY = gObj[aIndex].Y;
; 3812 : 		gObj[aIndex].m_State = 1;
; 3813 : 		gObj[aIndex].PathCount = 0;
; 3814 : 
; 3815 : 		LogAdd(LOG_BLACK, "NPC %d ", tableindex);	// #warning Translation Deathway

  00107	50		 push	 eax
  00108	88 8e 08 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+264], cl
  0010e	0f b6 8e 06 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+262]
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PGINOIGE@NPC?5?$CFd?$LH?N?5?$MA?L?$LF?$LP?$AA@
  0011a	6a 00		 push	 0
  0011c	88 96 1a 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+282], dl
  00122	88 8e 1b 01 00
	00		 mov	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+283], cl
  00128	c7 86 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+444], 1
  00132	c7 86 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[esi+296], 0
  0013c	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00141	83 c4 0c	 add	 esp, 12			; 0000000cH
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
$LN4@Run:
  00146	5f		 pop	 edi

; 3816 : 	}
; 3817 : }

  00147	8b e5		 mov	 esp, ebp
  00149	5d		 pop	 ebp
  0014a	c2 04 00	 ret	 4
?Run@CQeustNpcTeleport@@QAEXH@Z ENDP			; CQeustNpcTeleport::Run
_TEXT	ENDS
PUBLIC	??0CQeustNpcTeleport@@QAE@XZ			; CQeustNpcTeleport::CQeustNpcTeleport
EXTRN	__imp__InitializeCriticalSection@4:PROC
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\gobjmonster.h
;	COMDAT ??0CQeustNpcTeleport@@QAE@XZ
_TEXT	SEGMENT
??0CQeustNpcTeleport@@QAE@XZ PROC			; CQeustNpcTeleport::CQeustNpcTeleport, COMDAT
; _this$ = ecx

; 31   : 	CQeustNpcTeleport()	// line : 97

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 32   : 	{
; 33   : 		this->LastMapNumber = -1;
; 34   : 		this->RefCount = 0;
; 35   : 		InitializeCriticalSection(&this->CsRef);

  00003	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00006	50		 push	 eax
  00007	c7 46 20 ff ff
	ff ff		 mov	 DWORD PTR [esi+32], -1
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 36   : 		this->TimeCount = 0;
; 37   : 		this->m_QuestNPCTeleportPos[0].mapnum = MAP_INDEX_DEVIAS;

  0001a	b8 02 00 00 00	 mov	 eax, 2
  0001f	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 38   : 		this->m_QuestNPCTeleportPos[0].x = 198;
; 39   : 		this->m_QuestNPCTeleportPos[0].y = 47;
; 40   : 		this->m_QuestNPCTeleportPos[0].dir = 2;

  00022	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 41   : 		this->m_QuestNPCTeleportPos[1].mapnum = MAP_INDEX_LORENCIA;
; 42   : 		this->m_QuestNPCTeleportPos[1].x = 137;
; 43   : 		this->m_QuestNPCTeleportPos[1].y = 87;
; 44   : 		this->m_QuestNPCTeleportPos[1].dir = 1;
; 45   : 		this->m_QuestNPCTeleportPos[2].mapnum = MAP_INDEX_NORIA;
; 46   : 		this->m_QuestNPCTeleportPos[2].x = 169;
; 47   : 		this->m_QuestNPCTeleportPos[2].y = 89;
; 48   : 		this->m_QuestNPCTeleportPos[2].dir = 2;

  00025	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 49   : 		this->m_QuestNPCTeleportPos[3].mapnum = MAP_INDEX_ATHLANSE;
; 50   : 		this->m_QuestNPCTeleportPos[3].x = 17;
; 51   : 		this->m_QuestNPCTeleportPos[3].y = 0x19;
; 52   : 		this->m_QuestNPCTeleportPos[3].dir = 2;

  00028	89 46 60	 mov	 DWORD PTR [esi+96], eax
  0002b	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00032	c7 46 28 c6 00
	00 00		 mov	 DWORD PTR [esi+40], 198	; 000000c6H
  00039	c7 46 2c 2f 00
	00 00		 mov	 DWORD PTR [esi+44], 47	; 0000002fH
  00040	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00047	c7 46 38 89 00
	00 00		 mov	 DWORD PTR [esi+56], 137	; 00000089H
  0004e	c7 46 3c 57 00
	00 00		 mov	 DWORD PTR [esi+60], 87	; 00000057H
  00055	c7 46 40 01 00
	00 00		 mov	 DWORD PTR [esi+64], 1
  0005c	c7 46 44 03 00
	00 00		 mov	 DWORD PTR [esi+68], 3
  00063	c7 46 48 a9 00
	00 00		 mov	 DWORD PTR [esi+72], 169	; 000000a9H
  0006a	c7 46 4c 59 00
	00 00		 mov	 DWORD PTR [esi+76], 89	; 00000059H
  00071	c7 46 54 07 00
	00 00		 mov	 DWORD PTR [esi+84], 7
  00078	c7 46 58 11 00
	00 00		 mov	 DWORD PTR [esi+88], 17	; 00000011H
  0007f	c7 46 5c 19 00
	00 00		 mov	 DWORD PTR [esi+92], 25	; 00000019H

; 53   : 	};	// line : 114

  00086	8b c6		 mov	 eax, esi
  00088	5e		 pop	 esi
  00089	c3		 ret	 0
??0CQeustNpcTeleport@@QAE@XZ ENDP			; CQeustNpcTeleport::CQeustNpcTeleport
_TEXT	ENDS
PUBLIC	??1CQeustNpcTeleport@@QAE@XZ			; CQeustNpcTeleport::~CQeustNpcTeleport
EXTRN	__imp__DeleteCriticalSection@4:PROC
; Function compile flags: /Ogtp
;	COMDAT ??1CQeustNpcTeleport@@QAE@XZ
_TEXT	SEGMENT
??1CQeustNpcTeleport@@QAE@XZ PROC			; CQeustNpcTeleport::~CQeustNpcTeleport, COMDAT
; _this$ = ecx

; 57   : 		DeleteCriticalSection(&this->CsRef);

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 58   : 	};	// line : 115

  0000a	c3		 ret	 0
??1CQeustNpcTeleport@@QAE@XZ ENDP			; CQeustNpcTeleport::~CQeustNpcTeleport
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z	; gObjMonsterRegen
EXTRN	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z:PROC	; CMonsterSetBase::GetPosition
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gObjViewportListCreate@@YAXF@Z:PROC		; gObjViewportListCreate
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjViewportClose
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\gobjmonster.cpp
;	COMDAT ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_map$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z PROC		; gObjMonsterRegen, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00015	57		 push	 edi

; 41   : 	int map[3];
; 42   : 
; 43   : 	map[0] = 0;
; 44   : 	map[1] = 2;
; 45   : 	map[2] = 3;
; 46   : 
; 47   : 	gObjViewportListProtocolDestroy(lpObj);

  00016	56		 push	 esi
  00017	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _map$[ebp], 0
  0001e	c7 45 f4 02 00
	00 00		 mov	 DWORD PTR _map$[ebp+4], 2
  00025	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _map$[ebp+8], 3
  0002c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy

; 48   : 	gObjViewportClose(lpObj);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportClose

; 49   : 
; 50   : 	lpObj->m_ActState.Attack = 0;

  00037	83 a6 b4 01 00
	00 fd		 and	 DWORD PTR [esi+436], -3	; fffffffdH

; 51   : 	lpObj->m_ActState.EmotionCount = 0;
; 52   : 	lpObj->m_ActState.Escape = 0;
; 53   : 	lpObj->m_ActState.Move = 0;
; 54   : 	lpObj->m_ActState.Rest = 0;
; 55   : 	lpObj->m_ActState.Emotion = 0;
; 56   : 	lpObj->TargetNumber = -1;

  0003e	83 c8 ff	 or	 eax, -1
  00041	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax

; 57   : 	lpObj->NextActionTime = 5000;
; 58   : 
; 59   : 	if ( lpObj->Class == 43 )

  00048	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0004f	c6 86 b5 01 00
	00 00		 mov	 BYTE PTR [esi+437], 0
  00056	81 a6 b4 01 00
	00 02 ff ff ff	 and	 DWORD PTR [esi+436], -254 ; ffffff02H
  00060	83 c4 08	 add	 esp, 8
  00063	c7 86 1c 02 00
	00 88 13 00 00	 mov	 DWORD PTR [esi+540], 5000 ; 00001388H
  0006d	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00070	0f 85 ca 00 00
	00		 jne	 $LN14@gObjMonste@14

; 60   : 	{
; 61   : 		lpObj->MapNumber = map[ rand() % 3 ];

  00076	e8 00 00 00 00	 call	 _rand
  0007b	99		 cdq
  0007c	b9 03 00 00 00	 mov	 ecx, 3
  00081	f7 f9		 idiv	 ecx

; 62   : 
; 63   : 		if ( gMSetBase.GetBoxPosition(lpObj->MapNumber, 10, 10, 240, 240, lpObj->X, lpObj->Y)== FALSE )

  00083	8d be 06 01 00
	00		 lea	 edi, DWORD PTR [esi+262]
  00089	57		 push	 edi
  0008a	8d 9e 04 01 00
	00		 lea	 ebx, DWORD PTR [esi+260]
  00090	53		 push	 ebx
  00091	68 f0 00 00 00	 push	 240			; 000000f0H
  00096	68 f0 00 00 00	 push	 240			; 000000f0H
  0009b	6a 0a		 push	 10			; 0000000aH
  0009d	6a 0a		 push	 10			; 0000000aH
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  000a4	8a 54 95 f0	 mov	 dl, BYTE PTR _map$[ebp+edx*4]
  000a8	88 96 09 01 00
	00		 mov	 BYTE PTR [esi+265], dl
  000ae	0f b6 d2	 movzx	 edx, dl
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition
  000b7	85 c0		 test	 eax, eax
  000b9	75 34		 jne	 SHORT $LN13@gObjMonste@14
$LN19@gObjMonste@14:

; 64   : 		{
; 65   : 			lpObj->Live = FALSE;

  000bb	c6 46 62 00	 mov	 BYTE PTR [esi+98], 0

; 66   : 			lpObj->m_State = 4;

  000bf	c7 86 bc 01 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+444], 4

; 67   : 			lpObj->RegenTime = GetTickCount();

  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000cf	89 86 08 02 00
	00		 mov	 DWORD PTR [esi+520], eax

; 68   : 			lpObj->DieRegen = TRUE;

  000d5	c6 86 02 02 00
	00 01		 mov	 BYTE PTR [esi+514], 1
$LN8@gObjMonste@14:

; 84   : 	{
; 85   : 		return FALSE;

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	33 c0		 xor	 eax, eax
  000e0	5b		 pop	 ebx

; 143  : }

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	33 cd		 xor	 ecx, ebp
  000e6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
$LN13@gObjMonste@14:

; 69   : 			return FALSE;
; 70   : 		}
; 71   : 
; 72   : 		lpObj->TX = lpObj->X;

  000ef	0f b7 03	 movzx	 eax, WORD PTR [ebx]

; 73   : 		lpObj->TY = lpObj->Y;

  000f2	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  000f5	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  000fc	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx

; 74   : 		lpObj->MTX = lpObj->X;

  00103	66 89 86 24 01
	00 00		 mov	 WORD PTR [esi+292], ax

; 75   : 		lpObj->MTY = lpObj->Y;
; 76   : 		lpObj->StartX = lpObj->X;

  0010a	8a 03		 mov	 al, BYTE PTR [ebx]
  0010c	66 89 8e 26 01
	00 00		 mov	 WORD PTR [esi+294], cx

; 77   : 		lpObj->StartY = lpObj->Y;

  00113	8a 0f		 mov	 cl, BYTE PTR [edi]

; 137  : 	}
; 138  : 
; 139  : 
; 140  : 	gObjMonsterHitDamageInit(lpObj);

  00115	56		 push	 esi
  00116	88 86 1a 01 00
	00		 mov	 BYTE PTR [esi+282], al
  0011c	88 8e 1b 01 00
	00		 mov	 BYTE PTR [esi+283], cl
  00122	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit
  00127	83 c4 04	 add	 esp, 4
  0012a	5f		 pop	 edi
  0012b	5e		 pop	 esi

; 141  : 
; 142  : 	return TRUE;

  0012c	b8 01 00 00 00	 mov	 eax, 1
  00131	5b		 pop	 ebx

; 143  : }

  00132	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00135	33 cd		 xor	 ecx, ebp
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c3		 ret	 0
$LN14@gObjMonste@14:

; 78   : 	}
; 79   : 	else if ( lpObj->Class == 44 )

  00140	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00143	0f 84 f2 00 00
	00		 je	 $LN1@gObjMonste@14

; 80   : 	{
; 81   : 
; 82   : 	}
; 83   : 	else if ( lpObj->Class == 53 || lpObj->Class == 54 || lpObj->Class == 55 || lpObj->Class == 56 )

  00149	83 f8 35	 cmp	 eax, 53			; 00000035H
  0014c	74 8e		 je	 SHORT $LN8@gObjMonste@14
  0014e	83 f8 36	 cmp	 eax, 54			; 00000036H
  00151	74 89		 je	 SHORT $LN8@gObjMonste@14
  00153	83 f8 37	 cmp	 eax, 55			; 00000037H
  00156	74 84		 je	 SHORT $LN8@gObjMonste@14
  00158	83 f8 38	 cmp	 eax, 56			; 00000038H
  0015b	0f 84 7b ff ff
	ff		 je	 $LN8@gObjMonste@14

; 86   : 	}
; 87   : 	else if ( lpObj->Class >= 78 && lpObj->Class <= 83 )

  00161	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00164	72 09		 jb	 SHORT $LN6@gObjMonste@14
  00166	83 f8 53	 cmp	 eax, 83			; 00000053H

; 88   : 	{
; 89   : 		return FALSE;

  00169	0f 86 6d ff ff
	ff		 jbe	 $LN8@gObjMonste@14
$LN6@gObjMonste@14:

; 90   : 	}
; 91   : 	else if ( (lpObj->m_Attribute < 51) ? FALSE : (lpObj->m_Attribute > 58)? FALSE : TRUE )

  0016f	0f b7 86 26 03
	00 00		 movzx	 eax, WORD PTR [esi+806]
  00176	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  0017a	7c 5d		 jl	 SHORT $LN4@gObjMonste@14
  0017c	33 d2		 xor	 edx, edx
  0017e	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  00182	0f 9e c2	 setle	 dl
  00185	8b c2		 mov	 eax, edx
  00187	85 c0		 test	 eax, eax
  00189	74 4e		 je	 SHORT $LN4@gObjMonste@14

; 92   : 	{
; 93   : 		lpObj->Live = TRUE;
; 94   : 		lpObj->DieRegen = FALSE;
; 95   : 		CreateFrustrum(lpObj->X, lpObj->Y, lpObj->m_Index);

  0018b	8b 06		 mov	 eax, DWORD PTR [esi]
  0018d	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  00194	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  0019b	50		 push	 eax
  0019c	51		 push	 ecx
  0019d	52		 push	 edx
  0019e	c6 46 62 01	 mov	 BYTE PTR [esi+98], 1
  001a2	c6 86 02 02 00
	00 00		 mov	 BYTE PTR [esi+514], 0
  001a9	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 96   : 		gObjClearViewport(lpObj);

  001ae	56		 push	 esi
  001af	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAUOBJECTSTRUCT@@@Z ; gObjClearViewport

; 97   : 		gObjViewportListCreate(lpObj->m_Index);

  001b4	0f b7 06	 movzx	 eax, WORD PTR [esi]
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 ?gObjViewportListCreate@@YAXF@Z ; gObjViewportListCreate

; 98   : 		gObjViewportListProtocolCreate(lpObj);

  001bd	56		 push	 esi
  001be	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  001c3	83 c4 18	 add	 esp, 24			; 00000018H
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	33 c0		 xor	 eax, eax
  001ca	5b		 pop	 ebx

; 143  : }

  001cb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ce	33 cd		 xor	 ecx, ebp
  001d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c3		 ret	 0
$LN4@gObjMonste@14:

; 99   : 		return FALSE;
; 100  : 	}
; 101  : 	else if ( gMSetBase.GetPosition(lpObj->m_PosNum, lpObj->MapNumber, lpObj->X, lpObj->Y) == FALSE )

  001d9	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  001e0	0f bf 86 10 02
	00 00		 movsx	 eax, WORD PTR [esi+528]
  001e7	8d be 06 01 00
	00		 lea	 edi, DWORD PTR [esi+262]
  001ed	57		 push	 edi
  001ee	8d 9e 04 01 00
	00		 lea	 ebx, DWORD PTR [esi+260]
  001f4	53		 push	 ebx
  001f5	52		 push	 edx
  001f6	50		 push	 eax
  001f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  001fc	e8 00 00 00 00	 call	 ?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ; CMonsterSetBase::GetPosition
  00201	85 c0		 test	 eax, eax

; 102  : 	{
; 103  : #if (GS_CASTLE == 1)
; 104  : 		if(lpObj->m_Attribute == 62)
; 105  : 		{
; 106  : 			BYTE btX = lpObj->X,btY = lpObj->Y;
; 107  : 			if(gObjGetRandomFreeLocation(lpObj->MapNumber,(BYTE &)btX,(BYTE &)btY,5,5,30) == FALSE)
; 108  : 			{
; 109  : 				return FALSE;
; 110  : 			}
; 111  : 
; 112  : 			lpObj->X = btX;
; 113  : 			lpObj->Y = btY;
; 114  : 			__asm Jmp EndLabel;
; 115  : 		}
; 116  : 
; 117  : #endif
; 118  : 		lpObj->Live = FALSE;
; 119  : 		lpObj->m_State = 4;
; 120  : 		lpObj->RegenTime = GetTickCount();
; 121  : 		lpObj->DieRegen = TRUE;
; 122  : 		return FALSE;

  00203	0f 84 b2 fe ff
	ff		 je	 $LN19@gObjMonste@14

; 123  : 
; 124  : 
; 125  : 	}
; 126  : 	else
; 127  : 	{
; 128  : #if (GS_CASTLE == 1)
; 129  : EndLabel:
; 130  : #endif
; 131  : 		lpObj->MTX = lpObj->X;
; 132  : 		lpObj->MTY = lpObj->Y;

  00209	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  0020c	0f b7 03	 movzx	 eax, WORD PTR [ebx]

; 133  : 		lpObj->TX = lpObj->X;
; 134  : 		lpObj->TY = lpObj->Y;
; 135  : 		lpObj->StartX = lpObj->X;
; 136  : 		lpObj->StartY = lpObj->Y;

  0020f	8a 17		 mov	 dl, BYTE PTR [edi]
  00211	66 89 8e 26 01
	00 00		 mov	 WORD PTR [esi+294], cx
  00218	66 89 8e 22 01
	00 00		 mov	 WORD PTR [esi+290], cx
  0021f	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00221	66 89 86 24 01
	00 00		 mov	 WORD PTR [esi+292], ax
  00228	66 89 86 20 01
	00 00		 mov	 WORD PTR [esi+288], ax
  0022f	88 8e 1a 01 00
	00		 mov	 BYTE PTR [esi+282], cl
  00235	88 96 1b 01 00
	00		 mov	 BYTE PTR [esi+283], dl
$LN1@gObjMonste@14:

; 137  : 	}
; 138  : 
; 139  : 
; 140  : 	gObjMonsterHitDamageInit(lpObj);

  0023b	56		 push	 esi
  0023c	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit

; 143  : }

  00241	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00244	83 c4 04	 add	 esp, 4
  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	33 cd		 xor	 ecx, ebp
  0024b	b8 01 00 00 00	 mov	 eax, 1
  00250	5b		 pop	 ebx
  00251	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00256	8b e5		 mov	 esp, ebp
  00258	5d		 pop	 ebp
  00259	c3		 ret	 0
?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ENDP		; gObjMonsterRegen
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?gObjMonsterMagicAttack@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjMonsterMagicAttack
EXTRN	?CGBeattackRecv@@YAXPAEHH@Z:PROC		; CGBeattackRecv
EXTRN	?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z:PROC ; CGDurationMagicRecv
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterMagicAttack@@YAXPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv91 = -296						; size = 4
tv405 = -292						; size = 4
_ASBOfs$ = -288						; size = 4
_pCount$ = -284						; size = 8
_pAttack$ = -276					; size = 3
_pDuration$ = -272					; size = 12
_AttackSendBuff$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iMonsterClass$ = 12					; size = 4
?gObjMonsterMagicAttack@@YAXPAUOBJECTSTRUCT@@H@Z PROC	; gObjMonsterMagicAttack, COMDAT

; 1330 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]

; 1331 : 	int tObjNum;
; 1332 : 	int count = 0;
; 1333 : 	PMSG_BEATTACK_COUNT pCount;
; 1334 : 	PMSG_BEATTACK pAttack;
; 1335 : 	BYTE AttackSendBuff[256];
; 1336 : 	int ASBOfs = 0;
; 1337 : 	PMSG_DURATION_MAGIC_RECV pDuration;
; 1338 : 
; 1339 : 	pDuration.MagicNumber = 0;
; 1340 : 	pDuration.Dir = 0;
; 1341 : 	pDuration.X = lpObj->X;

  00019	8a 87 04 01 00
	00		 mov	 al, BYTE PTR [edi+260]

; 1342 : 	pDuration.Y = lpObj->Y;
; 1343 : 
; 1344 : 	CGDurationMagicRecv(&pDuration, lpObj->m_Index);

  0001f	8b 17		 mov	 edx, DWORD PTR [edi]
  00021	0f b6 8f 06 01
	00 00		 movzx	 ecx, BYTE PTR [edi+262]
  00028	88 85 f4 fe ff
	ff		 mov	 BYTE PTR _pDuration$[ebp+4], al
  0002e	52		 push	 edx
  0002f	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pDuration$[ebp]
  00035	50		 push	 eax
  00036	c6 85 f3 fe ff
	ff 00		 mov	 BYTE PTR _pDuration$[ebp+3], 0
  0003d	c6 85 f6 fe ff
	ff 00		 mov	 BYTE PTR _pDuration$[ebp+6], 0
  00044	88 8d f5 fe ff
	ff		 mov	 BYTE PTR _pDuration$[ebp+5], cl
  0004a	e8 00 00 00 00	 call	 ?CGDurationMagicRecv@@YAXPAUPMSG_DURATION_MAGIC_RECV@@H@Z ; CGDurationMagicRecv

; 1345 : 
; 1346 : 	pCount.h.c = 0xC1;
; 1347 : 	pCount.h.headcode = PROTOCOL_BEATTACK;
; 1348 : 	pCount.h.size = 0;
; 1349 : 	pCount.MagicNumber = 0;
; 1350 : 	pCount.Count = 0;
; 1351 : 	pCount.X = lpObj->X;

  0004f	0f b6 8f 04 01
	00 00		 movzx	 ecx, BYTE PTR [edi+260]

; 1352 : 	pCount.Y = lpObj->Y;

  00056	8a 97 06 01 00
	00		 mov	 dl, BYTE PTR [edi+262]
  0005c	88 8d e8 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], cl

; 1380 : 					}
; 1381 : 				}
; 1382 : 			}
; 1383 : 		}
; 1384 : 
; 1385 : 		count++;

  00062	8d 8f 18 07 00
	00		 lea	 ecx, DWORD PTR [edi+1816]
  00068	83 c4 08	 add	 esp, 8
  0006b	c6 85 e4 fe ff
	ff c1		 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H
  00072	66 c7 85 e5 fe
	ff ff 00 10	 mov	 WORD PTR _pCount$[ebp+1], 4096 ; 00001000H
  0007b	c6 85 e7 fe ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+3], 0
  00082	c6 85 eb fe ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+7], 0
  00089	88 95 e9 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], dl
  0008f	c7 85 e0 fe ff
	ff 08 00 00 00	 mov	 DWORD PTR _ASBOfs$[ebp], 8
  00099	8d b5 04 ff ff
	ff		 lea	 esi, DWORD PTR _AttackSendBuff$[ebp+8]
  0009f	89 8d dc fe ff
	ff		 mov	 DWORD PTR tv405[ebp], ecx

; 1386 : 
; 1387 : 		if ( count > MAX_VIEWPORT_MONSTER-1 )

  000a5	c7 85 d8 fe ff
	ff 14 00 00 00	 mov	 DWORD PTR tv91[ebp], 20	; 00000014H
  000af	90		 npad	 1
$LL14@gObjMonste@15:

; 1353 : 	ASBOfs = sizeof(pCount);
; 1354 : 
; 1355 : 	while ( true )
; 1356 : 	{
; 1357 : 		if ( lpObj->VpPlayer2[count].state )

  000b0	80 79 fc 00	 cmp	 BYTE PTR [ecx-4], 0
  000b4	0f 84 a7 00 00
	00		 je	 $LN7@gObjMonste@15

; 1358 : 		{
; 1359 : 			if ( lpObj->VpPlayer2[count].type == OBJ_USER )

  000ba	80 39 01	 cmp	 BYTE PTR [ecx], 1
  000bd	0f 85 9e 00 00
	00		 jne	 $LN7@gObjMonste@15

; 1360 : 			{
; 1361 : 				tObjNum = lpObj->VpPlayer2[count].number;

  000c3	0f bf 59 fe	 movsx	 ebx, WORD PTR [ecx-2]

; 1362 : 
; 1363 : 				if ( tObjNum >= 0 )

  000c7	85 db		 test	 ebx, ebx
  000c9	0f 88 92 00 00
	00		 js	 $LN7@gObjMonste@15

; 1364 : 				{
; 1365 : 					if ( lpObj->Class == 77 )	// Phoenix of Darkness

  000cf	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  000d6	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  000d9	75 26		 jne	 SHORT $LN9@gObjMonste@15

; 1366 : 					{
; 1367 : 						pAttack.NumberH = SET_NUMBERH(tObjNum);

  000db	8b c3		 mov	 eax, ebx
  000dd	c1 e8 08	 shr	 eax, 8
  000e0	88 85 ec fe ff
	ff		 mov	 BYTE PTR _pAttack$[ebp], al

; 1368 : 						pAttack.NumberL = SET_NUMBERL(tObjNum);
; 1369 : 						memcpy(&AttackSendBuff[ASBOfs], &pAttack, sizeof(pAttack));

  000e6	8a 85 ee fe ff
	ff		 mov	 al, BYTE PTR _pAttack$[ebp+2]
  000ec	88 9d ed fe ff
	ff		 mov	 BYTE PTR _pAttack$[ebp+1], bl
  000f2	66 8b 95 ec fe
	ff ff		 mov	 dx, WORD PTR _pAttack$[ebp]
  000f9	66 89 16	 mov	 WORD PTR [esi], dx
  000fc	88 46 02	 mov	 BYTE PTR [esi+2], al

; 1370 : 						ASBOfs+= sizeof(pAttack);
; 1371 : 						pCount.Count++;

  000ff	eb 50		 jmp	 SHORT $LN23@gObjMonste@15
$LN9@gObjMonste@15:

; 1372 : 					}
; 1373 : 					else if ( lpObj->Class == 275 || gObjCalDistance(lpObj, &gObj[tObjNum]) < 6 )

  00101	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  00106	66 3b c2	 cmp	 ax, dx
  00109	74 22		 je	 SHORT $LN21@gObjMonste@15
  0010b	8b c3		 mov	 eax, ebx
  0010d	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00113	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00118	50		 push	 eax
  00119	57		 push	 edi
  0011a	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  0011f	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv405[ebp]
  00125	83 c4 08	 add	 esp, 8
  00128	83 f8 06	 cmp	 eax, 6
  0012b	7d 34		 jge	 SHORT $LN7@gObjMonste@15
$LN21@gObjMonste@15:

; 1374 : 					{
; 1375 : 						pAttack.NumberH = SET_NUMBERH(tObjNum);

  0012d	8b d3		 mov	 edx, ebx
  0012f	c1 ea 08	 shr	 edx, 8
  00132	88 95 ec fe ff
	ff		 mov	 BYTE PTR _pAttack$[ebp], dl

; 1376 : 						pAttack.NumberL = SET_NUMBERL(tObjNum);
; 1377 : 						memcpy(&AttackSendBuff[ASBOfs], &pAttack, sizeof(pAttack));

  00138	8a 95 ee fe ff
	ff		 mov	 dl, BYTE PTR _pAttack$[ebp+2]
  0013e	88 9d ed fe ff
	ff		 mov	 BYTE PTR _pAttack$[ebp+1], bl
  00144	66 8b 85 ec fe
	ff ff		 mov	 ax, WORD PTR _pAttack$[ebp]
  0014b	66 89 06	 mov	 WORD PTR [esi], ax
  0014e	88 56 02	 mov	 BYTE PTR [esi+2], dl
$LN23@gObjMonste@15:

; 1378 : 						ASBOfs+= sizeof(pAttack);

  00151	83 85 e0 fe ff
	ff 03		 add	 DWORD PTR _ASBOfs$[ebp], 3
  00158	83 c6 03	 add	 esi, 3

; 1379 : 						pCount.Count++;

  0015b	fe 85 eb fe ff
	ff		 inc	 BYTE PTR _pCount$[ebp+7]
$LN7@gObjMonste@15:

; 1380 : 					}
; 1381 : 				}
; 1382 : 			}
; 1383 : 		}
; 1384 : 
; 1385 : 		count++;

  00161	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 1386 : 
; 1387 : 		if ( count > MAX_VIEWPORT_MONSTER-1 )

  00164	ff 8d d8 fe ff
	ff		 dec	 DWORD PTR tv91[ebp]
  0016a	89 8d dc fe ff
	ff		 mov	 DWORD PTR tv405[ebp], ecx
  00170	0f 85 3a ff ff
	ff		 jne	 $LL14@gObjMonste@15

; 1388 : 			break;
; 1389 : 	}
; 1390 : 
; 1391 : 	if ( pCount.Count > 0 )

  00176	80 bd eb fe ff
	ff 00		 cmp	 BYTE PTR _pCount$[ebp+7], 0
  0017d	0f 86 9e 00 00
	00		 jbe	 $LN1@gObjMonste@15

; 1392 : 	{
; 1393 : 		pCount.h.size = ASBOfs;

  00183	8a 85 e0 fe ff
	ff		 mov	 al, BYTE PTR _ASBOfs$[ebp]

; 1394 : 		memcpy(AttackSendBuff, &pCount, sizeof(pCount));

  00189	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _pCount$[ebp+4]
  0018f	88 85 e5 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al
  00195	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _pCount$[ebp]

; 1395 : 
; 1396 : 		if ( lpObj->Class == 161 || lpObj->Class == 181 || lpObj->Class == 189 || lpObj->Class == 197 || lpObj->Class == 267 || lpObj->Class == 275 )

  0019b	0f b7 87 98 00
	00 00		 movzx	 eax, WORD PTR [edi+152]
  001a2	89 8d fc fe ff
	ff		 mov	 DWORD PTR _AttackSendBuff$[ebp], ecx
  001a8	b9 a1 00 00 00	 mov	 ecx, 161		; 000000a1H
  001ad	89 95 00 ff ff
	ff		 mov	 DWORD PTR _AttackSendBuff$[ebp+4], edx
  001b3	66 3b c1	 cmp	 ax, cx
  001b6	74 57		 je	 SHORT $LN2@gObjMonste@15
  001b8	ba b5 00 00 00	 mov	 edx, 181		; 000000b5H
  001bd	66 3b c2	 cmp	 ax, dx
  001c0	74 4d		 je	 SHORT $LN2@gObjMonste@15
  001c2	b9 bd 00 00 00	 mov	 ecx, 189		; 000000bdH
  001c7	66 3b c1	 cmp	 ax, cx
  001ca	74 43		 je	 SHORT $LN2@gObjMonste@15
  001cc	ba c5 00 00 00	 mov	 edx, 197		; 000000c5H
  001d1	66 3b c2	 cmp	 ax, dx
  001d4	74 39		 je	 SHORT $LN2@gObjMonste@15
  001d6	b9 0b 01 00 00	 mov	 ecx, 267		; 0000010bH
  001db	66 3b c1	 cmp	 ax, cx
  001de	74 2f		 je	 SHORT $LN2@gObjMonste@15
  001e0	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  001e5	66 3b c2	 cmp	 ax, dx
  001e8	74 25		 je	 SHORT $LN2@gObjMonste@15

; 1399 : 		}
; 1400 : 		else
; 1401 : 		{
; 1402 : 			CGBeattackRecv(AttackSendBuff, lpObj->m_Index, TRUE);

  001ea	8b 07		 mov	 eax, DWORD PTR [edi]
  001ec	6a 01		 push	 1
  001ee	50		 push	 eax
  001ef	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _AttackSendBuff$[ebp]
  001f5	51		 push	 ecx
  001f6	e8 00 00 00 00	 call	 ?CGBeattackRecv@@YAXPAEHH@Z ; CGBeattackRecv
  001fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fe	5f		 pop	 edi
  001ff	5e		 pop	 esi
  00200	5b		 pop	 ebx

; 1403 : 		}
; 1404 : 	}
; 1405 : }

  00201	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00204	33 cd		 xor	 ecx, ebp
  00206	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020b	8b e5		 mov	 esp, ebp
  0020d	5d		 pop	 ebp
  0020e	c3		 ret	 0
$LN2@gObjMonste@15:

; 1397 : 		{
; 1398 : 			gObjMonsterBeattackRecv(AttackSendBuff, lpObj->m_Index);

  0020f	8b 17		 mov	 edx, DWORD PTR [edi]
  00211	52		 push	 edx
  00212	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _AttackSendBuff$[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?gObjMonsterBeattackRecv@@YAXPAEH@Z ; gObjMonsterBeattackRecv
  0021e	83 c4 08	 add	 esp, 8
$LN1@gObjMonste@15:

; 1403 : 		}
; 1404 : 	}
; 1405 : }

  00221	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00224	5f		 pop	 edi
  00225	5e		 pop	 esi
  00226	33 cd		 xor	 ecx, ebp
  00228	5b		 pop	 ebx
  00229	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c3		 ret	 0
?gObjMonsterMagicAttack@@YAXPAUOBJECTSTRUCT@@H@Z ENDP	; gObjMonsterMagicAttack
_TEXT	ENDS
PUBLIC	?gObjMonsterAttack@@YAXPAUOBJECTSTRUCT@@0@Z	; gObjMonsterAttack
EXTRN	?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z:PROC		; CGAttack
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterAttack@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_pAttackMsg$158410 = -8					; size = 7
_pAttackMsg$158380 = -8					; size = 7
_pAttackMsg$158371 = -8					; size = 7
_pAttackMsg$158363 = -8					; size = 7
_pAttackMsg$158354 = -8					; size = 7
_pAttackMsg$158344 = -8					; size = 7
_pAttackMsg$158336 = -8					; size = 7
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjMonsterAttack@@YAXPAUOBJECTSTRUCT@@0@Z PROC	; gObjMonsterAttack, COMDAT

; 1478 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1479 : 	int AttackType = int(lpObj->m_AttackType);

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	0f bf 8e 22 03
	00 00		 movsx	 ecx, WORD PTR [esi+802]

; 1480 : 
; 1481 : 	if ( AttackType >= 100 )

  00012	33 db		 xor	 ebx, ebx
  00014	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00017	7c 02		 jl	 SHORT $LN30@gObjMonste@16

; 1482 : 		AttackType = 0;

  00019	33 c9		 xor	 ecx, ecx
$LN30@gObjMonste@16:

; 1483 : 
; 1484 : 	if ( lpObj->m_iMonsterBattleDelay > 0 )

  0001b	38 9e 2b 02 00
	00		 cmp	 BYTE PTR [esi+555], bl
  00021	0f 8f aa 04 00
	00		 jg	 $LN3@gObjMonste@16

; 1485 : 		return;
; 1486 : 
; 1487 : 	if ( lpObj->Class == 144 || lpObj->Class == 174 || lpObj->Class == 182 || lpObj->Class == 190 ||
; 1488 : 		lpObj->Class == 260 || lpObj->Class == 268 )

  00027	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0002e	ba 90 00 00 00	 mov	 edx, 144		; 00000090H
  00033	66 3b c2	 cmp	 ax, dx
  00036	74 32		 je	 SHORT $LN27@gObjMonste@16
  00038	ba ae 00 00 00	 mov	 edx, 174		; 000000aeH
  0003d	66 3b c2	 cmp	 ax, dx
  00040	74 28		 je	 SHORT $LN27@gObjMonste@16
  00042	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  00047	66 3b c2	 cmp	 ax, dx
  0004a	74 1e		 je	 SHORT $LN27@gObjMonste@16
  0004c	ba be 00 00 00	 mov	 edx, 190		; 000000beH
  00051	66 3b c2	 cmp	 ax, dx
  00054	74 14		 je	 SHORT $LN27@gObjMonste@16
  00056	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  0005b	66 3b c2	 cmp	 ax, dx
  0005e	74 0a		 je	 SHORT $LN27@gObjMonste@16
  00060	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  00065	66 3b c2	 cmp	 ax, dx
  00068	75 46		 jne	 SHORT $LN28@gObjMonste@16
$LN27@gObjMonste@16:

; 1489 : 	{
; 1490 : 		if ( rand()%2 )

  0006a	e8 00 00 00 00	 call	 _rand
  0006f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00074	79 05		 jns	 SHORT $LN33@gObjMonste@16
  00076	48		 dec	 eax
  00077	83 c8 fe	 or	 eax, -2			; fffffffeH
  0007a	40		 inc	 eax
$LN33@gObjMonste@16:
  0007b	74 31		 je	 SHORT $LN26@gObjMonste@16
$LN39@gObjMonste@16:

; 1491 : 		{
; 1492 : 			PMSG_MAGICATTACK pAttackMsg;
; 1493 : 
; 1494 : 			pAttackMsg.MagicNumber = 0;

  0007d	88 5d fb	 mov	 BYTE PTR _pAttackMsg$158336[ebp+3], bl
$LN38@gObjMonste@16:

; 1495 : 			pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);

  00080	0f bf 86 d4 02
	00 00		 movsx	 eax, WORD PTR [esi+724]

; 1496 : 			pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1497 : 			pAttackMsg.Dis = 0;
; 1498 : 
; 1499 : 			CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  00087	8b 16		 mov	 edx, DWORD PTR [esi]
  00089	8a 8e d4 02 00
	00		 mov	 cl, BYTE PTR [esi+724]
  0008f	c1 e8 08	 shr	 eax, 8
  00092	88 45 fc	 mov	 BYTE PTR _pAttackMsg$158336[ebp+4], al
  00095	52		 push	 edx
  00096	8d 45 f8	 lea	 eax, DWORD PTR _pAttackMsg$158336[ebp]
  00099	50		 push	 eax
  0009a	88 4d fd	 mov	 BYTE PTR _pAttackMsg$158336[ebp+5], cl
  0009d	88 5d fe	 mov	 BYTE PTR _pAttackMsg$158336[ebp+6], bl
  000a0	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack

; 1521 : 		}
; 1522 : 
; 1523 : 		gObjMonsterMagicAttack(lpObj, lpObj->Class);

  000a5	83 c4 08	 add	 esp, 8
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 1672 : 				}
; 1673 : 		}
; 1674 : 	}
; 1675 : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
$LN26@gObjMonste@16:

; 1500 : 			return;
; 1501 : 		}
; 1502 : 
; 1503 : 		AttackType = 0;

  000ae	33 c9		 xor	 ecx, ecx
$LN28@gObjMonste@16:

; 1504 : 	}
; 1505 : 
; 1506 : 	if ( lpObj->Class == 161 || lpObj->Class == 181 || lpObj->Class == 189 ||
; 1507 : 		lpObj->Class == 197 || lpObj->Class == 267 || lpObj->Class == 275  )

  000b0	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000b7	ba a1 00 00 00	 mov	 edx, 161		; 000000a1H
  000bc	66 3b c2	 cmp	 ax, dx
  000bf	0f 84 a8 03 00
	00		 je	 $LN24@gObjMonste@16
  000c5	ba b5 00 00 00	 mov	 edx, 181		; 000000b5H
  000ca	66 3b c2	 cmp	 ax, dx
  000cd	0f 84 9a 03 00
	00		 je	 $LN24@gObjMonste@16
  000d3	ba bd 00 00 00	 mov	 edx, 189		; 000000bdH
  000d8	66 3b c2	 cmp	 ax, dx
  000db	0f 84 8c 03 00
	00		 je	 $LN24@gObjMonste@16
  000e1	ba c5 00 00 00	 mov	 edx, 197		; 000000c5H
  000e6	66 3b c2	 cmp	 ax, dx
  000e9	0f 84 7e 03 00
	00		 je	 $LN24@gObjMonste@16
  000ef	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  000f4	66 3b c2	 cmp	 ax, dx
  000f7	0f 84 70 03 00
	00		 je	 $LN24@gObjMonste@16
  000fd	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  00102	66 3b c2	 cmp	 ax, dx
  00105	0f 84 62 03 00
	00		 je	 $LN24@gObjMonste@16

; 1524 : 		return;
; 1525 : 	}
; 1526 : 
; 1527 : 	if ( lpObj->Class == 149 || lpObj->Class == 179 || lpObj->Class == 187 ||
; 1528 : 		lpObj->Class == 195 || lpObj->Class == 265 || lpObj->Class == 273  )

  0010b	ba 95 00 00 00	 mov	 edx, 149		; 00000095H
  00110	66 3b c2	 cmp	 ax, dx
  00113	0f 84 39 03 00
	00		 je	 $LN20@gObjMonste@16
  00119	ba b3 00 00 00	 mov	 edx, 179		; 000000b3H
  0011e	66 3b c2	 cmp	 ax, dx
  00121	0f 84 2b 03 00
	00		 je	 $LN20@gObjMonste@16
  00127	ba bb 00 00 00	 mov	 edx, 187		; 000000bbH
  0012c	66 3b c2	 cmp	 ax, dx
  0012f	0f 84 1d 03 00
	00		 je	 $LN20@gObjMonste@16
  00135	ba c3 00 00 00	 mov	 edx, 195		; 000000c3H
  0013a	66 3b c2	 cmp	 ax, dx
  0013d	0f 84 0f 03 00
	00		 je	 $LN20@gObjMonste@16
  00143	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  00148	66 3b c2	 cmp	 ax, dx
  0014b	0f 84 01 03 00
	00		 je	 $LN20@gObjMonste@16
  00151	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  00156	66 3b c2	 cmp	 ax, dx
  00159	0f 84 f3 02 00
	00		 je	 $LN20@gObjMonste@16

; 1539 : 	}
; 1540 : 	
; 1541 : 	if (     lpObj->Class == 145
; 1542 :           || lpObj->Class == 175
; 1543 :           || lpObj->Class == 183
; 1544 :           || lpObj->Class == 191
; 1545 :           || lpObj->Class == 261
; 1546 :           || lpObj->Class == 269
; 1547 :           || lpObj->Class == 146
; 1548 :           || lpObj->Class == 176
; 1549 :           || lpObj->Class == 184
; 1550 :           || lpObj->Class == 192
; 1551 :           || lpObj->Class == 262
; 1552 :           || lpObj->Class == 270
; 1553 :           || lpObj->Class == 147
; 1554 :           || lpObj->Class == 177
; 1555 :           || lpObj->Class == 185
; 1556 :           || lpObj->Class == 193
; 1557 :           || lpObj->Class == 263
; 1558 :           || lpObj->Class == 271
; 1559 :           || lpObj->Class == 148
; 1560 :           || lpObj->Class == 178
; 1561 :           || lpObj->Class == 186
; 1562 :           || lpObj->Class == 194
; 1563 :           || lpObj->Class == 264
; 1564 :           || lpObj->Class == 272
; 1565 :           || lpObj->Class == 160
; 1566 :           || lpObj->Class == 180
; 1567 :           || lpObj->Class == 188
; 1568 :           || lpObj->Class == 196
; 1569 :           || lpObj->Class == 266
; 1570 :           || lpObj->Class == 274 )

  0015f	ba 91 00 00 00	 mov	 edx, 145		; 00000091H
  00164	66 3b c2	 cmp	 ax, dx
  00167	0f 84 62 01 00
	00		 je	 $LN18@gObjMonste@16
  0016d	ba af 00 00 00	 mov	 edx, 175		; 000000afH
  00172	66 3b c2	 cmp	 ax, dx
  00175	0f 84 54 01 00
	00		 je	 $LN18@gObjMonste@16
  0017b	ba b7 00 00 00	 mov	 edx, 183		; 000000b7H
  00180	66 3b c2	 cmp	 ax, dx
  00183	0f 84 46 01 00
	00		 je	 $LN18@gObjMonste@16
  00189	ba bf 00 00 00	 mov	 edx, 191		; 000000bfH
  0018e	66 3b c2	 cmp	 ax, dx
  00191	0f 84 38 01 00
	00		 je	 $LN18@gObjMonste@16
  00197	ba 05 01 00 00	 mov	 edx, 261		; 00000105H
  0019c	66 3b c2	 cmp	 ax, dx
  0019f	0f 84 2a 01 00
	00		 je	 $LN18@gObjMonste@16
  001a5	ba 0d 01 00 00	 mov	 edx, 269		; 0000010dH
  001aa	66 3b c2	 cmp	 ax, dx
  001ad	0f 84 1c 01 00
	00		 je	 $LN18@gObjMonste@16
  001b3	ba 92 00 00 00	 mov	 edx, 146		; 00000092H
  001b8	66 3b c2	 cmp	 ax, dx
  001bb	0f 84 0e 01 00
	00		 je	 $LN18@gObjMonste@16
  001c1	ba b0 00 00 00	 mov	 edx, 176		; 000000b0H
  001c6	66 3b c2	 cmp	 ax, dx
  001c9	0f 84 00 01 00
	00		 je	 $LN18@gObjMonste@16
  001cf	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  001d4	66 3b c2	 cmp	 ax, dx
  001d7	0f 84 f2 00 00
	00		 je	 $LN18@gObjMonste@16
  001dd	ba c0 00 00 00	 mov	 edx, 192		; 000000c0H
  001e2	66 3b c2	 cmp	 ax, dx
  001e5	0f 84 e4 00 00
	00		 je	 $LN18@gObjMonste@16
  001eb	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  001f0	66 3b c2	 cmp	 ax, dx
  001f3	0f 84 d6 00 00
	00		 je	 $LN18@gObjMonste@16
  001f9	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH
  001fe	66 3b c2	 cmp	 ax, dx
  00201	0f 84 c8 00 00
	00		 je	 $LN18@gObjMonste@16
  00207	ba 93 00 00 00	 mov	 edx, 147		; 00000093H
  0020c	66 3b c2	 cmp	 ax, dx
  0020f	0f 84 ba 00 00
	00		 je	 $LN18@gObjMonste@16
  00215	ba b1 00 00 00	 mov	 edx, 177		; 000000b1H
  0021a	66 3b c2	 cmp	 ax, dx
  0021d	0f 84 ac 00 00
	00		 je	 $LN18@gObjMonste@16
  00223	ba b9 00 00 00	 mov	 edx, 185		; 000000b9H
  00228	66 3b c2	 cmp	 ax, dx
  0022b	0f 84 9e 00 00
	00		 je	 $LN18@gObjMonste@16
  00231	ba c1 00 00 00	 mov	 edx, 193		; 000000c1H
  00236	66 3b c2	 cmp	 ax, dx
  00239	0f 84 90 00 00
	00		 je	 $LN18@gObjMonste@16
  0023f	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  00244	66 3b c2	 cmp	 ax, dx
  00247	0f 84 82 00 00
	00		 je	 $LN18@gObjMonste@16
  0024d	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  00252	66 3b c2	 cmp	 ax, dx
  00255	74 78		 je	 SHORT $LN18@gObjMonste@16
  00257	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  0025c	66 3b c2	 cmp	 ax, dx
  0025f	74 6e		 je	 SHORT $LN18@gObjMonste@16
  00261	ba b2 00 00 00	 mov	 edx, 178		; 000000b2H
  00266	66 3b c2	 cmp	 ax, dx
  00269	74 64		 je	 SHORT $LN18@gObjMonste@16
  0026b	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  00270	66 3b c2	 cmp	 ax, dx
  00273	74 5a		 je	 SHORT $LN18@gObjMonste@16
  00275	ba c2 00 00 00	 mov	 edx, 194		; 000000c2H
  0027a	66 3b c2	 cmp	 ax, dx
  0027d	74 50		 je	 SHORT $LN18@gObjMonste@16
  0027f	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  00284	66 3b c2	 cmp	 ax, dx
  00287	74 46		 je	 SHORT $LN18@gObjMonste@16
  00289	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  0028e	66 3b c2	 cmp	 ax, dx
  00291	74 3c		 je	 SHORT $LN18@gObjMonste@16
  00293	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00298	66 3b c2	 cmp	 ax, dx
  0029b	74 32		 je	 SHORT $LN18@gObjMonste@16
  0029d	ba b4 00 00 00	 mov	 edx, 180		; 000000b4H
  002a2	66 3b c2	 cmp	 ax, dx
  002a5	74 28		 je	 SHORT $LN18@gObjMonste@16
  002a7	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  002ac	66 3b c2	 cmp	 ax, dx
  002af	74 1e		 je	 SHORT $LN18@gObjMonste@16
  002b1	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  002b6	66 3b c2	 cmp	 ax, dx
  002b9	74 14		 je	 SHORT $LN18@gObjMonste@16
  002bb	ba 0a 01 00 00	 mov	 edx, 266		; 0000010aH
  002c0	66 3b c2	 cmp	 ax, dx
  002c3	74 0a		 je	 SHORT $LN18@gObjMonste@16
  002c5	ba 12 01 00 00	 mov	 edx, 274		; 00000112H
  002ca	66 3b c2	 cmp	 ax, dx
  002cd	75 1e		 jne	 SHORT $LN19@gObjMonste@16
$LN18@gObjMonste@16:

; 1571 : 	{
; 1572 : 		if ( (rand()%2) )

  002cf	e8 00 00 00 00	 call	 _rand
  002d4	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002d9	79 05		 jns	 SHORT $LN34@gObjMonste@16
  002db	48		 dec	 eax
  002dc	83 c8 fe	 or	 eax, -2			; fffffffeH
  002df	40		 inc	 eax
$LN34@gObjMonste@16:
  002e0	74 09		 je	 SHORT $LN17@gObjMonste@16
$LN9@gObjMonste@16:

; 1573 : 		{
; 1574 : 			PMSG_MAGICATTACK pAttackMsg;
; 1575 : 
; 1576 : 			pAttackMsg.MagicNumber = 1;

  002e2	c6 45 fb 01	 mov	 BYTE PTR _pAttackMsg$158363[ebp+3], 1

; 1577 : 			pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1578 : 			pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1579 : 			pAttackMsg.Dis = 0;
; 1580 : 
; 1581 : 			CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 1582 : 			return;

  002e6	e9 95 fd ff ff	 jmp	 $LN38@gObjMonste@16
$LN17@gObjMonste@16:

; 1583 : 		}
; 1584 : 		AttackType = 0;

  002eb	33 c9		 xor	 ecx, ecx
$LN19@gObjMonste@16:

; 1585 : 	}
; 1586 : 	
; 1587 : 	if (	 lpObj->Class == 89
; 1588 :           || lpObj->Class == 95
; 1589 :           || lpObj->Class == 112
; 1590 :           || lpObj->Class == 118
; 1591 :           || lpObj->Class == 124
; 1592 :           || lpObj->Class == 130
; 1593 :           || lpObj->Class == 143 )

  002ed	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  002f4	83 f8 59	 cmp	 eax, 89			; 00000059H
  002f7	0f 84 11 01 00
	00		 je	 $LN15@gObjMonste@16
  002fd	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00300	0f 84 08 01 00
	00		 je	 $LN15@gObjMonste@16
  00306	83 f8 70	 cmp	 eax, 112		; 00000070H
  00309	0f 84 ff 00 00
	00		 je	 $LN15@gObjMonste@16
  0030f	83 f8 76	 cmp	 eax, 118		; 00000076H
  00312	0f 84 f6 00 00
	00		 je	 $LN15@gObjMonste@16
  00318	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0031b	0f 84 ed 00 00
	00		 je	 $LN15@gObjMonste@16
  00321	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  00326	66 3b c2	 cmp	 ax, dx
  00329	0f 84 df 00 00
	00		 je	 $LN15@gObjMonste@16
  0032f	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  00334	66 3b c2	 cmp	 ax, dx
  00337	0f 84 d1 00 00
	00		 je	 $LN15@gObjMonste@16

; 1604 : 	}
; 1605 : 	else if (	   lpObj->Class == 163
; 1606 :             || lpObj->Class == 165
; 1607 :             || lpObj->Class == 167
; 1608 :             || lpObj->Class == 169
; 1609 :             || lpObj->Class == 171
; 1610 :             || lpObj->Class == 173 )

  0033d	ba a3 00 00 00	 mov	 edx, 163		; 000000a3H
  00342	66 3b c2	 cmp	 ax, dx
  00345	0f 84 91 00 00
	00		 je	 $LN12@gObjMonste@16
  0034b	ba a5 00 00 00	 mov	 edx, 165		; 000000a5H
  00350	66 3b c2	 cmp	 ax, dx
  00353	0f 84 83 00 00
	00		 je	 $LN12@gObjMonste@16
  00359	ba a7 00 00 00	 mov	 edx, 167		; 000000a7H
  0035e	66 3b c2	 cmp	 ax, dx
  00361	74 79		 je	 SHORT $LN12@gObjMonste@16
  00363	ba a9 00 00 00	 mov	 edx, 169		; 000000a9H
  00368	66 3b c2	 cmp	 ax, dx
  0036b	74 6f		 je	 SHORT $LN12@gObjMonste@16
  0036d	ba ab 00 00 00	 mov	 edx, 171		; 000000abH
  00372	66 3b c2	 cmp	 ax, dx
  00375	74 65		 je	 SHORT $LN12@gObjMonste@16
  00377	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  0037c	66 3b c2	 cmp	 ax, dx
  0037f	74 5b		 je	 SHORT $LN12@gObjMonste@16

; 1620 : 	}
; 1621 : 	else if ( lpObj->Class == 66 || lpObj->Class == 73 || lpObj->Class == 77 )

  00381	83 f8 42	 cmp	 eax, 66			; 00000042H
  00384	0f 84 58 ff ff
	ff		 je	 $LN9@gObjMonste@16
  0038a	83 f8 49	 cmp	 eax, 73			; 00000049H
  0038d	0f 84 4f ff ff
	ff		 je	 $LN9@gObjMonste@16
  00393	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00396	0f 84 46 ff ff
	ff		 je	 $LN9@gObjMonste@16

; 1622 : 	{
; 1623 : 		PMSG_MAGICATTACK pAttackMsg;
; 1624 : 
; 1625 : 		pAttackMsg.MagicNumber = 1;
; 1626 : 		pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1627 : 		pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1628 : 		pAttackMsg.Dis = 0;
; 1629 : 
; 1630 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 1631 : 	}
; 1632 : 
; 1633 : #pragma message("Delete this unuseful Code with ADDON gObjMonsterAttack")
; 1634 : 
; 1635 : 	else if ( lpObj->Class == 66 || lpObj->Class == 73 || lpObj->Class == 77 )
; 1636 : 	{
; 1637 : 		PMSG_MAGICATTACK pAttackMsg;
; 1638 : 
; 1639 : 		pAttackMsg.MagicNumber = 1;
; 1640 : 		pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1641 : 		pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1642 : 		pAttackMsg.Dis = 0;
; 1643 : 
; 1644 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 1645 : 	}
; 1646 : 	else
; 1647 : 	{
; 1648 : 		switch ( AttackType ) 

  0039c	3b cb		 cmp	 ecx, ebx

; 1660 : 				}
; 1661 : 				break;
; 1662 : 		
; 1663 : 			default:
; 1664 : 				{
; 1665 : 					PMSG_MAGICATTACK pAttackMsg;
; 1666 : 					pAttackMsg.MagicNumber = 0;
; 1667 : 					pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1668 : 					pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1669 : 					pAttackMsg.Dis = 0;
; 1670 : 
; 1671 : 					CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  0039e	0f 85 d9 fc ff
	ff		 jne	 $LN39@gObjMonste@16

; 1649 : 		{
; 1650 : 			case 0:
; 1651 : 				{
; 1652 : 					PMSG_ATTACK pAttackMsg;
; 1653 : 
; 1654 : 					pAttackMsg.AttackAction = 120;
; 1655 : 					pAttackMsg.DirDis = lpObj->Dir;

  003a4	0f bf 96 d4 02
	00 00		 movsx	 edx, WORD PTR [esi+724]
  003ab	8a 8e 08 01 00
	00		 mov	 cl, BYTE PTR [esi+264]

; 1656 : 					pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1657 : 					pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);

  003b1	8a 86 d4 02 00
	00		 mov	 al, BYTE PTR [esi+724]
  003b7	c1 ea 08	 shr	 edx, 8
  003ba	88 4d fe	 mov	 BYTE PTR _pAttackMsg$158410[ebp+6], cl

; 1658 : 
; 1659 : 					CGAttack(&pAttackMsg, lpObj->m_Index);

  003bd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  003bf	88 55 fb	 mov	 BYTE PTR _pAttackMsg$158410[ebp+3], dl
  003c2	51		 push	 ecx
  003c3	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$158410[ebp]
  003c6	52		 push	 edx
  003c7	c6 45 fd 78	 mov	 BYTE PTR _pAttackMsg$158410[ebp+5], 120 ; 00000078H
  003cb	88 45 fc	 mov	 BYTE PTR _pAttackMsg$158410[ebp+4], al
  003ce	e8 00 00 00 00	 call	 ?CGAttack@@YAXPAUPMSG_ATTACK@@H@Z ; CGAttack
  003d3	83 c4 08	 add	 esp, 8
  003d6	5e		 pop	 esi
  003d7	5b		 pop	 ebx

; 1672 : 				}
; 1673 : 		}
; 1674 : 	}
; 1675 : }

  003d8	8b e5		 mov	 esp, ebp
  003da	5d		 pop	 ebp
  003db	c3		 ret	 0
$LN12@gObjMonste@16:

; 1611 : 	{
; 1612 : 		PMSG_MAGICATTACK pAttackMsg;
; 1613 : 
; 1614 : 		pAttackMsg.MagicNumber = 1;
; 1615 : 		pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);

  003dc	0f bf 8e d4 02
	00 00		 movsx	 ecx, WORD PTR [esi+724]

; 1616 : 		pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1617 : 		pAttackMsg.Dis = 0;
; 1618 : 
; 1619 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  003e3	8b 06		 mov	 eax, DWORD PTR [esi]
  003e5	8a 96 d4 02 00
	00		 mov	 dl, BYTE PTR [esi+724]
  003eb	c1 e9 08	 shr	 ecx, 8
  003ee	88 4d fc	 mov	 BYTE PTR _pAttackMsg$158380[ebp+4], cl
  003f1	50		 push	 eax
  003f2	8d 4d f8	 lea	 ecx, DWORD PTR _pAttackMsg$158380[ebp]
  003f5	51		 push	 ecx
  003f6	c6 45 fb 01	 mov	 BYTE PTR _pAttackMsg$158380[ebp+3], 1
  003fa	88 55 fd	 mov	 BYTE PTR _pAttackMsg$158380[ebp+5], dl
  003fd	88 5d fe	 mov	 BYTE PTR _pAttackMsg$158336[ebp+6], bl
  00400	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00405	83 c4 08	 add	 esp, 8
  00408	5e		 pop	 esi
  00409	5b		 pop	 ebx

; 1672 : 				}
; 1673 : 		}
; 1674 : 	}
; 1675 : }

  0040a	8b e5		 mov	 esp, ebp
  0040c	5d		 pop	 ebp
  0040d	c3		 ret	 0
$LN15@gObjMonste@16:

; 1594 : 	{
; 1595 : 
; 1596 : 		PMSG_MAGICATTACK pAttackMsg;
; 1597 : 
; 1598 : 		pAttackMsg.MagicNumber = rand()%2+1;

  0040e	e8 00 00 00 00	 call	 _rand
  00413	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00418	79 05		 jns	 SHORT $LN35@gObjMonste@16
  0041a	48		 dec	 eax
  0041b	83 c8 fe	 or	 eax, -2			; fffffffeH
  0041e	40		 inc	 eax
$LN35@gObjMonste@16:

; 1599 : 		pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);

  0041f	0f bf 96 d4 02
	00 00		 movsx	 edx, WORD PTR [esi+724]

; 1600 : 		pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1601 : 		pAttackMsg.Dis = 0;
; 1602 : 
; 1603 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  00426	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00428	c1 ea 08	 shr	 edx, 8
  0042b	fe c0		 inc	 al
  0042d	88 55 fc	 mov	 BYTE PTR _pAttackMsg$158371[ebp+4], dl
  00430	88 45 fb	 mov	 BYTE PTR _pAttackMsg$158371[ebp+3], al
  00433	8a 86 d4 02 00
	00		 mov	 al, BYTE PTR [esi+724]
  00439	51		 push	 ecx
  0043a	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$158371[ebp]
  0043d	52		 push	 edx
  0043e	88 45 fd	 mov	 BYTE PTR _pAttackMsg$158371[ebp+5], al
  00441	88 5d fe	 mov	 BYTE PTR _pAttackMsg$158336[ebp+6], bl
  00444	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack
  00449	83 c4 08	 add	 esp, 8
  0044c	5e		 pop	 esi
  0044d	5b		 pop	 ebx

; 1672 : 				}
; 1673 : 		}
; 1674 : 	}
; 1675 : }

  0044e	8b e5		 mov	 esp, ebp
  00450	5d		 pop	 ebp
  00451	c3		 ret	 0
$LN20@gObjMonste@16:

; 1529 : 	{
; 1530 : 		PMSG_MAGICATTACK pAttackMsg;
; 1531 : 
; 1532 : 		pAttackMsg.MagicNumber = rand()%2+1;

  00452	e8 00 00 00 00	 call	 _rand
  00457	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0045c	79 05		 jns	 SHORT $LN36@gObjMonste@16
  0045e	48		 dec	 eax
  0045f	83 c8 fe	 or	 eax, -2			; fffffffeH
  00462	40		 inc	 eax
$LN36@gObjMonste@16:
  00463	fe c0		 inc	 al
  00465	88 45 fb	 mov	 BYTE PTR _pAttackMsg$158354[ebp+3], al

; 1533 : 		pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1534 : 		pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1535 : 		pAttackMsg.Dis = 0;
; 1536 : 
; 1537 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);
; 1538 : 		return;

  00468	e9 13 fc ff ff	 jmp	 $LN38@gObjMonste@16
$LN24@gObjMonste@16:

; 1508 : 	{
; 1509 : 		PMSG_MAGICATTACK pAttackMsg;
; 1510 : 
; 1511 : 		pAttackMsg.MagicNumber = rand()%6+1;

  0046d	e8 00 00 00 00	 call	 _rand
  00472	99		 cdq
  00473	b9 06 00 00 00	 mov	 ecx, 6
  00478	f7 f9		 idiv	 ecx

; 1512 : 		pAttackMsg.NumberH = SET_NUMBERH(lpObj->TargetNumber);
; 1513 : 		pAttackMsg.NumberL = SET_NUMBERL(lpObj->TargetNumber);
; 1514 : 		pAttackMsg.Dis = 0;
; 1515 : 
; 1516 : 		CGMagicAttack(&pAttackMsg, lpObj->m_Index);

  0047a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0047c	0f b6 86 d4 02
	00 00		 movzx	 eax, BYTE PTR [esi+724]
  00483	51		 push	 ecx
  00484	88 45 fd	 mov	 BYTE PTR _pAttackMsg$158344[ebp+5], al
  00487	88 5d fe	 mov	 BYTE PTR _pAttackMsg$158344[ebp+6], bl
  0048a	fe c2		 inc	 dl
  0048c	88 55 fb	 mov	 BYTE PTR _pAttackMsg$158344[ebp+3], dl
  0048f	0f bf 96 d4 02
	00 00		 movsx	 edx, WORD PTR [esi+724]
  00496	c1 ea 08	 shr	 edx, 8
  00499	88 55 fc	 mov	 BYTE PTR _pAttackMsg$158344[ebp+4], dl
  0049c	8d 55 f8	 lea	 edx, DWORD PTR _pAttackMsg$158344[ebp]
  0049f	52		 push	 edx
  004a0	e8 00 00 00 00	 call	 ?CGMagicAttack@@YAXPAUPMSG_MAGICATTACK@@H@Z ; CGMagicAttack

; 1517 : 
; 1518 : 		if ( pAttackMsg.MagicNumber == 1 || pAttackMsg.MagicNumber == 2 || pAttackMsg.MagicNumber == 0 )

  004a5	8a 45 fb	 mov	 al, BYTE PTR _pAttackMsg$158344[ebp+3]
  004a8	83 c4 08	 add	 esp, 8
  004ab	3c 01		 cmp	 al, 1
  004ad	74 08		 je	 SHORT $LN22@gObjMonste@16
  004af	3c 02		 cmp	 al, 2
  004b1	74 04		 je	 SHORT $LN22@gObjMonste@16
  004b3	3a c3		 cmp	 al, bl
  004b5	75 09		 jne	 SHORT $LN23@gObjMonste@16
$LN22@gObjMonste@16:

; 1519 : 		{
; 1520 : 			gObjUseMonsterSpecialAbillity(lpObj);	// Kundun

  004b7	56		 push	 esi
  004b8	e8 00 00 00 00	 call	 ?gObjUseMonsterSpecialAbillity@@YAXPAUOBJECTSTRUCT@@@Z ; gObjUseMonsterSpecialAbillity
  004bd	83 c4 04	 add	 esp, 4
$LN23@gObjMonste@16:

; 1521 : 		}
; 1522 : 
; 1523 : 		gObjMonsterMagicAttack(lpObj, lpObj->Class);

  004c0	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  004c7	50		 push	 eax
  004c8	56		 push	 esi
  004c9	e8 00 00 00 00	 call	 ?gObjMonsterMagicAttack@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjMonsterMagicAttack
  004ce	83 c4 08	 add	 esp, 8
$LN3@gObjMonste@16:
  004d1	5e		 pop	 esi
  004d2	5b		 pop	 ebx

; 1672 : 				}
; 1673 : 		}
; 1674 : 	}
; 1675 : }

  004d3	8b e5		 mov	 esp, ebp
  004d5	5d		 pop	 ebp
  004d6	c3		 ret	 0
?gObjMonsterAttack@@YAXPAUOBJECTSTRUCT@@0@Z ENDP	; gObjMonsterAttack
_TEXT	ENDS
PUBLIC	?gObjMonsterTrapAct@@YAXPAUOBJECTSTRUCT@@@Z	; gObjMonsterTrapAct
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterTrapAct@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjMonsterTrapAct@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterTrapAct, COMDAT

; 2169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2170 : 	if(lpObj->VPCount2 < 1)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	83 be 9c 0a 00
	00 01		 cmp	 DWORD PTR [esi+2716], 1
  0000e	0f 8c 84 00 00
	00		 jl	 $LN1@gObjMonste@17

; 2171 : 	{
; 2172 : 		return;
; 2173 : 	}
; 2174 : 
; 2175 : 	if(lpObj->m_AttackRange > 0)

  00014	0f b7 86 20 03
	00 00		 movzx	 eax, WORD PTR [esi+800]
  0001b	66 85 c0	 test	 ax, ax
  0001e	7e 42		 jle	 SHORT $LN9@gObjMonste@17

; 2176 : 	{
; 2177 : 		if(lpObj->Dir == 3)

  00020	8a 8e 08 01 00
	00		 mov	 cl, BYTE PTR [esi+264]
  00026	80 f9 03	 cmp	 cl, 3
  00029	75 0e		 jne	 SHORT $LN8@gObjMonste@17

; 2178 : 		{
; 2179 : 			gObjTrapAttackEnemySearchX(lpObj,lpObj->m_AttackRange+1);

  0002b	98		 cwde
  0002c	40		 inc	 eax
  0002d	50		 push	 eax
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearchX@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchX
  00034	83 c4 08	 add	 esp, 8
  00037	eb 32		 jmp	 SHORT $LN3@gObjMonste@17
$LN8@gObjMonste@17:

; 2180 : 		}
; 2181 : 		else if(lpObj->Dir == 1)

  00039	80 f9 01	 cmp	 cl, 1
  0003c	75 10		 jne	 SHORT $LN6@gObjMonste@17

; 2182 : 		{
; 2183 : 			gObjTrapAttackEnemySearchY(lpObj,lpObj->m_AttackRange+1);

  0003e	0f bf c8	 movsx	 ecx, ax
  00041	41		 inc	 ecx
  00042	51		 push	 ecx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearchY@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchY
  00049	83 c4 08	 add	 esp, 8
  0004c	eb 1d		 jmp	 SHORT $LN3@gObjMonste@17
$LN6@gObjMonste@17:

; 2184 : 		}
; 2185 : #if(GS_CASTLE==0)
; 2186 : 		else if(lpObj->Dir == 8)

  0004e	80 f9 08	 cmp	 cl, 8
  00051	75 18		 jne	 SHORT $LN3@gObjMonste@17

; 2187 : 		{
; 2188 : 			gObjTrapAttackEnemySearchRange(lpObj,lpObj->m_AttackRange);

  00053	0f bf d0	 movsx	 edx, ax
  00056	52		 push	 edx
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearchRange@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjTrapAttackEnemySearchRange
  0005d	83 c4 08	 add	 esp, 8

; 2189 : 		}
; 2190 : #endif
; 2191 : 	}
; 2192 : 	else

  00060	eb 09		 jmp	 SHORT $LN3@gObjMonste@17
$LN9@gObjMonste@17:

; 2193 : 	{
; 2194 : 		gObjTrapAttackEnemySearch(lpObj);

  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?gObjTrapAttackEnemySearch@@YAXPAUOBJECTSTRUCT@@@Z ; gObjTrapAttackEnemySearch
  00068	83 c4 04	 add	 esp, 4
$LN3@gObjMonste@17:

; 2195 : 	}
; 2196 : 
; 2197 : 	if(lpObj->TargetNumber >= 0)

  0006b	66 83 be d4 02
	00 00 00	 cmp	 WORD PTR [esi+724], 0
  00073	7c 16		 jl	 SHORT $LN2@gObjMonste@17

; 2198 : 	{
; 2199 : 		lpObj->m_ActState.Attack = 1;
; 2200 : 		lpObj->NextActionTime = lpObj->m_AttackSpeed;

  00075	8b 86 08 03 00
	00		 mov	 eax, DWORD PTR [esi+776]
  0007b	83 8e b4 01 00
	00 02		 or	 DWORD PTR [esi+436], 2
  00082	89 86 1c 02 00
	00		 mov	 DWORD PTR [esi+540], eax
  00088	5e		 pop	 esi

; 2205 : 	}
; 2206 : }

  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN2@gObjMonste@17:

; 2201 : 	}
; 2202 : 	else
; 2203 : 	{
; 2204 : 		lpObj->NextActionTime = lpObj->m_MoveSpeed;

  0008b	0f bf 8e 1c 03
	00 00		 movsx	 ecx, WORD PTR [esi+796]
  00092	89 8e 1c 02 00
	00		 mov	 DWORD PTR [esi+540], ecx
$LN1@gObjMonste@17:
  00098	5e		 pop	 esi

; 2205 : 	}
; 2206 : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?gObjMonsterTrapAct@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterTrapAct
_TEXT	ENDS
PUBLIC	__real@41ddcd6500000000
PUBLIC	??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5?$AA@ ; `string'
PUBLIC	??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5I@ ; `string'
PUBLIC	??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5K@ ; `string'
PUBLIC	?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterDieGiveItem
EXTRN	?gEvent1ItemDropTodayMax@@3HA:DWORD		; gEvent1ItemDropTodayMax
EXTRN	?gEvent1ItemDropTodayCount@@3HA:DWORD		; gEvent1ItemDropTodayCount
EXTRN	?gEvent1ItemDropTodayPercent@@3HA:DWORD		; gEvent1ItemDropTodayPercent
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?GetDropRate@CVip@@QAEMH@Z:PROC			; CVip::GetDropRate
EXTRN	?gVip@@3VCVip@@A:BYTE				; gVip
EXTRN	?MonsterItemDrop@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@@Z:PROC ; CQuestInfo::MonsterItemDrop
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?AttackEvent55BagOpen@@YAHPAUOBJECTSTRUCT@@@Z:PROC ; AttackEvent55BagOpen
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z:PROC ; CChaosCastle::SearchNDropMonsterItem
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?KundunEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z:PROC ; KundunEventItemBoxOpen
EXTRN	?MakeRewardSetItem@@YAXHEEHH@Z:PROC		; MakeRewardSetItem
;	COMDAT __real@41ddcd6500000000
CONST	SEGMENT
__real@41ddcd6500000000 DQ 041ddcd6500000000r	; 2e+009
CONST	ENDS
;	COMDAT ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN?$FL@ DB '['
	DB	0a1H, 0dbH, 'Kundun EVENT] Drop Item [%d][%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5?$AA@
CONST	SEGMENT
??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5?$AA@ DB '['
	DB	0a1H, 0dbH, 'Kundun EVENT] Drop SetItem ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5I@
CONST	SEGMENT
??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5I@ DB '['
	DB	0a1H, 0daH, 'Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser ['
	DB	'%d][%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5K@
CONST	SEGMENT
??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5K@ DB '['
	DB	0a1H, 0daH, 0a1H, 0daH, 'Kundun EVENT] Kundun die, Killer [%s]'
	DB	'[%s]', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv1215 = -44						; size = 4
tv1213 = -44						; size = 4
tv1188 = -44						; size = 4
_Option3$ = -40						; size = 4
_x$ = -36						; size = 4
_moneyrate$ = -36					; size = 4
tv1298 = -32						; size = 4
_optionc$158879 = -32					; size = 4
_level$ = -28						; size = 4
_dur$ = -24						; size = 4
_DropItem$ = -20					; size = 4
tv1041 = -16						; size = 4
_NOption$ = -16						; size = 1
_ItemDropPer$ = -16					; size = 4
_cDropX$158786 = -12					; size = 1
_Option1$ = -12						; size = 4
tv1042 = -8						; size = 4
_Option2$ = -8						; size = 4
_y$ = -4						; size = 4
tv1265 = 8						; size = 4
tv1197 = 8						; size = 4
tv1196 = 8						; size = 4
tv709 = 8						; size = 4
_cDropY$158787 = 8					; size = 1
_option3rand$158878 = 8					; size = 4
tv295 = 8						; size = 4
_type$ = 8						; size = 4
_MaxHitUser$158821 = 8					; size = 4
_itemrate$ = 8						; size = 4
_item_drop$ = 8						; size = 4
_lpObj$ = 8						; size = 4
tv1218 = 10						; size = 2
_lpTargetObj$ = 12					; size = 4
?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z PROC	; gObjMonsterDieGiveItem, COMDAT

; 2582 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2583 : 
; 2584 : 	int store_count=0;
; 2585 : 	int ExtDropPer=0;
; 2586 : 	int DropItemNum=0;
; 2587 : 	int type;
; 2588 : 	int level;
; 2589 : 	int x;
; 2590 : 	int y;
; 2591 : 	float dur=0;
; 2592 : 	int Option1=0;
; 2593 : 	int Option2=0;
; 2594 : 	int Option3=0;
; 2595 : 	unsigned char NOption=0;
; 2596 : 	BOOL item_drop=0;
; 2597 : 	int n;
; 2598 : 	CItem * DropItem=NULL;	
; 2599 : 
; 2600 : #if GS_CASTLE == 1 
; 2601 : 	if ( lpObj->m_btCsNpcType )
; 2602 : 		return;
; 2603 : 
; 2604 : 	if ( lpObj->Class == 295 )
; 2605 : 	{
; 2606 : 		int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 2607 : 		int iMaxCount = 1;
; 2608 : 
; 2609 : 		for ( int i=0; i<iMaxCount ; i++ )
; 2610 : 		{
; 2611 : 			BYTE cDropX = lpObj->X;
; 2612 : 			BYTE cDropY = lpObj->Y;
; 2613 : 
; 2614 : 			LogAdd(LOG_BLACK, "[Castle HuntZone] Boss Monster ItemDrop MaxHitUser [%d][%s][%s]",
; 2615 : 				i, lpTargetObj->AccountID, lpTargetObj->Name);
; 2616 : 
; 2617 : 			if ( gObjGetRandomItemDropLocation(lpObj->MapNumber, cDropX, cDropY, 4, 4, 10) == FALSE )
; 2618 : 			{
; 2619 : 				cDropX = lpObj->X;
; 2620 : 				cDropY = lpObj->Y;
; 2621 : 			}
; 2622 : 
; 2623 : 			if ( i == 0 )
; 2624 : 			{
; 2625 : 				cDropX = lpObj->X;
; 2626 : 				cDropY = lpObj->Y;
; 2627 : 			}
; 2628 : 
; 2629 : 			CastleHuntZoneBossRewardOpen(lpTargetObj, lpObj->MapNumber, cDropX, cDropY);
; 2630 : 		}
; 2631 : 		return;
; 2632 : 	}
; 2633 : #endif
; 2634 : 	
; 2635 : 	if ( lpObj->Class == 275 ) // Kundun 

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000b	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00012	33 d2		 xor	 edx, edx
  00014	b9 13 01 00 00	 mov	 ecx, 275		; 00000113H
  00019	57		 push	 edi
  0001a	89 55 f4	 mov	 DWORD PTR _Option1$[ebp], edx
  0001d	89 55 f8	 mov	 DWORD PTR _Option2$[ebp], edx
  00020	89 55 d8	 mov	 DWORD PTR _Option3$[ebp], edx
  00023	66 3b c1	 cmp	 ax, cx
  00026	0f 85 fc 01 00
	00		 jne	 $LN103@gObjMonste@18

; 2636 : 	{
; 2637 : 		LogAdd(LOG_BLACK, "[Kundun EVENT] Kundun die, Killer [%s][%s]",
; 2638 : 			lpTargetObj->AccountID, lpTargetObj->Name);

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0002f	8d 78 6f	 lea	 edi, DWORD PTR [eax+111]
  00032	57		 push	 edi
  00033	8d 58 64	 lea	 ebx, DWORD PTR [eax+100]
  00036	53		 push	 ebx
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5K@
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2639 : 
; 2640 : 		KUNDUN_EVENT_LOG.Output("[Kundun EVENT] Kundun die, Killer [%s][%s]",
; 2641 : 			lpTargetObj->AccountID, lpTargetObj->Name);

  00042	57		 push	 edi
  00043	53		 push	 ebx
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DAHAGAMG@?$FL?$KB?Z?$KB?ZKundun?5EVENT?$FN?5Kundun?5die?0?5K@
  00049	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  0004e	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 2642 : 
; 2643 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00059	83 c4 24	 add	 esp, 36			; 00000024H
  0005c	8b d8		 mov	 ebx, eax

; 2644 : 		int iMaxNumOfRewardItem = 3;
; 2645 : 
; 2646 : 		for ( int i=0;i<iMaxNumOfRewardItem;i++)

  0005e	33 ff		 xor	 edi, edi
$LL135@gObjMonste@18:

; 2647 : 		{
; 2648 : 			BYTE cDropX = lpObj->X;

  00060	8a 96 04 01 00
	00		 mov	 dl, BYTE PTR [esi+260]

; 2649 : 			BYTE cDropY = lpObj->Y;

  00066	8a 86 06 01 00
	00		 mov	 al, BYTE PTR [esi+262]
  0006c	88 55 f4	 mov	 BYTE PTR _cDropX$158786[ebp], dl
  0006f	88 45 08	 mov	 BYTE PTR _cDropY$158787[ebp], al

; 2650 : 
; 2651 : 			if ( OBJMAX_RANGE(MaxHitUser) )

  00072	85 db		 test	 ebx, ebx
  00074	78 42		 js	 SHORT $LN99@gObjMonste@18
  00076	33 c0		 xor	 eax, eax
  00078	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  0007e	0f 9e c0	 setle	 al
  00081	85 c0		 test	 eax, eax
  00083	74 33		 je	 SHORT $LN99@gObjMonste@18

; 2652 : 			{
; 2653 : 
; 2654 : 				LogAdd(LOG_BLACK, "[Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]",
; 2655 : 					i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name);

  00085	8b c3		 mov	 eax, ebx
  00087	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0008d	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  00093	51		 push	 ecx
  00094	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  0009a	50		 push	 eax
  0009b	57		 push	 edi
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5I@
  000a1	6a 00		 push	 0
  000a3	89 4d f0	 mov	 DWORD PTR tv1041[ebp], ecx
  000a6	89 45 f8	 mov	 DWORD PTR tv1042[ebp], eax
  000a9	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2656 : 
; 2657 : 				KUNDUN_EVENT_LOG.Output("[Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]",
; 2658 : 					i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name);

  000ae	8b 4d f0	 mov	 ecx, DWORD PTR tv1041[ebp]
  000b1	8b 55 f8	 mov	 edx, DWORD PTR tv1042[ebp]
  000b4	51		 push	 ecx
  000b5	52		 push	 edx

; 2659 : 			}
; 2660 : 			else

  000b6	eb 23		 jmp	 SHORT $LN151@gObjMonste@18
$LN99@gObjMonste@18:

; 2661 : 			{
; 2662 : 				LogAdd(LOG_BLACK, "[Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]",
; 2663 : 					i, lpTargetObj->AccountID, lpTargetObj->Name);

  000b8	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000bb	8d 48 6f	 lea	 ecx, DWORD PTR [eax+111]
  000be	51		 push	 ecx
  000bf	83 c0 64	 add	 eax, 100		; 00000064H
  000c2	50		 push	 eax
  000c3	57		 push	 edi
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5I@
  000c9	6a 00		 push	 0
  000cb	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2664 : 
; 2665 : 				KUNDUN_EVENT_LOG.Output("[Kundun EVENT] In KALIMA(7), ItemDrop MaxHitUser [%d][%s][%s]",
; 2666 : 					i, lpTargetObj->AccountID, lpTargetObj->Name);

  000d0	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000d3	8d 48 6f	 lea	 ecx, DWORD PTR [eax+111]
  000d6	51		 push	 ecx
  000d7	83 c0 64	 add	 eax, 100		; 00000064H
  000da	50		 push	 eax
$LN151@gObjMonste@18:
  000db	57		 push	 edi
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@HALHLIDI@?$FL?$KB?ZKundun?5EVENT?$FN?5In?5KALIMA?$CI7?$CJ?0?5I@
  000e1	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  000e6	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 2667 : 			}
; 2668 : 
; 2669 : 			if ( !gObjGetRandomItemDropLocation(lpObj->MapNumber, cDropX, cDropY, 4, 4, 10))

  000eb	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  000f2	83 c4 28	 add	 esp, 40			; 00000028H
  000f5	6a 0a		 push	 10			; 0000000aH
  000f7	6a 04		 push	 4
  000f9	6a 04		 push	 4
  000fb	8d 45 08	 lea	 eax, DWORD PTR _cDropY$158787[ebp]
  000fe	50		 push	 eax
  000ff	8d 4d f4	 lea	 ecx, DWORD PTR _cDropX$158786[ebp]
  00102	51		 push	 ecx
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  00109	83 c4 18	 add	 esp, 24			; 00000018H
  0010c	85 c0		 test	 eax, eax
  0010e	75 12		 jne	 SHORT $LN97@gObjMonste@18

; 2670 : 			{
; 2671 : 				cDropX = lpObj->X;

  00110	8a 86 04 01 00
	00		 mov	 al, BYTE PTR [esi+260]

; 2672 : 				cDropY = lpObj->Y;

  00116	8a 8e 06 01 00
	00		 mov	 cl, BYTE PTR [esi+262]
  0011c	88 45 f4	 mov	 BYTE PTR _cDropX$158786[ebp], al
  0011f	88 4d 08	 mov	 BYTE PTR _cDropY$158787[ebp], cl
$LN97@gObjMonste@18:

; 2673 : 			}
; 2674 : 
; 2675 : 			if ( lpObj->Class == 275 ) // Kundun	// useless if

  00122	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  00127	66 39 96 98 00
	00 00		 cmp	 WORD PTR [esi+152], dx
  0012e	75 50		 jne	 SHORT $LN95@gObjMonste@18

; 2676 : 			{
; 2677 : 				if ( (rand()%10000) < 2500 )

  00130	e8 00 00 00 00	 call	 _rand
  00135	99		 cdq
  00136	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0013b	f7 f9		 idiv	 ecx
  0013d	81 fa c4 09 00
	00		 cmp	 edx, 2500		; 000009c4H
  00143	7d 3b		 jge	 SHORT $LN95@gObjMonste@18

; 2678 : 				{
; 2679 : 					MakeRewardSetItem(MaxHitUser, cDropX, cDropY, 1, lpObj->MapNumber);

  00145	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  0014c	8b 45 08	 mov	 eax, DWORD PTR _cDropY$158787[ebp]
  0014f	8b 4d f4	 mov	 ecx, DWORD PTR _cDropX$158786[ebp]
  00152	52		 push	 edx
  00153	6a 01		 push	 1
  00155	50		 push	 eax
  00156	51		 push	 ecx
  00157	53		 push	 ebx
  00158	e8 00 00 00 00	 call	 ?MakeRewardSetItem@@YAXHEEHH@Z ; MakeRewardSetItem

; 2680 : 
; 2681 : 					LogAdd(LOG_BLACK, "[Kundun EVENT] Drop SetItem ");

  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5?$AA@
  00162	6a 00		 push	 0
  00164	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2682 : 					KUNDUN_EVENT_LOG.Output("[Kundun EVENT] Drop SetItem ");

  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OPPMOMBL@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5SetItem?5?$AA@
  0016e	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  00173	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00178	83 c4 24	 add	 esp, 36			; 00000024H

; 2683 : 
; 2684 : 					continue;

  0017b	e9 97 00 00 00	 jmp	 $LN101@gObjMonste@18
$LN95@gObjMonste@18:

; 2685 : 				}
; 2686 : 			}
; 2687 : 
; 2688 : 			if ( OBJMAX_RANGE(MaxHitUser ))

  00180	85 db		 test	 ebx, ebx
  00182	78 41		 js	 SHORT $LN94@gObjMonste@18
  00184	33 c0		 xor	 eax, eax
  00186	81 fb e7 1c 00
	00		 cmp	 ebx, 7399		; 00001ce7H
  0018c	0f 9e c0	 setle	 al
  0018f	85 c0		 test	 eax, eax
  00191	74 32		 je	 SHORT $LN94@gObjMonste@18

; 2689 : 			{
; 2690 : 				LogAdd(LOG_BLACK, "[Kundun EVENT] Drop Item [%d][%s][%s]",
; 2691 : 					i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name);

  00193	8b c3		 mov	 eax, ebx
  00195	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0019b	8d 88 6f 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+111]
  001a1	51		 push	 ecx
  001a2	8d 80 64 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+100]
  001a8	50		 push	 eax
  001a9	57		 push	 edi
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN?$FL@
  001af	6a 00		 push	 0
  001b1	89 4d f0	 mov	 DWORD PTR tv1041[ebp], ecx
  001b4	89 45 f8	 mov	 DWORD PTR tv1042[ebp], eax
  001b7	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2692 : 				KUNDUN_EVENT_LOG.Output("[Kundun EVENT] Drop Item [%d][%s][%s]",
; 2693 : 					i, gObj[MaxHitUser].AccountID, gObj[MaxHitUser].Name);

  001bc	8b 55 f0	 mov	 edx, DWORD PTR tv1041[ebp]
  001bf	8b 45 f8	 mov	 eax, DWORD PTR tv1042[ebp]
  001c2	52		 push	 edx

; 2694 : 			}
; 2695 : 			else

  001c3	eb 22		 jmp	 SHORT $LN152@gObjMonste@18
$LN94@gObjMonste@18:

; 2696 : 			{
; 2697 : 				LogAdd(LOG_BLACK, "[Kundun EVENT] Drop Item [%d][%s][%s]",
; 2698 : 					i, lpTargetObj->AccountID, lpTargetObj->Name);

  001c5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001c8	8d 48 6f	 lea	 ecx, DWORD PTR [eax+111]
  001cb	51		 push	 ecx
  001cc	83 c0 64	 add	 eax, 100		; 00000064H
  001cf	50		 push	 eax
  001d0	57		 push	 edi
  001d1	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN?$FL@
  001d6	6a 00		 push	 0
  001d8	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 2699 : 				KUNDUN_EVENT_LOG.Output("[Kundun EVENT] Drop Item [%d][%s][%s]",
; 2700 : 					i, lpTargetObj->AccountID, lpTargetObj->Name);

  001dd	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001e0	8d 48 6f	 lea	 ecx, DWORD PTR [eax+111]
  001e3	51		 push	 ecx
  001e4	83 c0 64	 add	 eax, 100		; 00000064H
$LN152@gObjMonste@18:
  001e7	50		 push	 eax
  001e8	57		 push	 edi
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@CKKBBPGB@?$FL?$KB?$NLKundun?5EVENT?$FN?5Drop?5Item?5?$FL?$CFd?$FN?$FL@
  001ee	68 00 00 00 00	 push	 OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  001f3	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output

; 2701 : 			}
; 2702 : 
; 2703 : 			KundunEventItemBoxOpen(lpTargetObj, lpObj->MapNumber, cDropX, cDropY);

  001f8	8b 4d 08	 mov	 ecx, DWORD PTR _cDropY$158787[ebp]
  001fb	8b 55 f4	 mov	 edx, DWORD PTR _cDropX$158786[ebp]
  001fe	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00205	83 c4 28	 add	 esp, 40			; 00000028H
  00208	51		 push	 ecx
  00209	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0020c	52		 push	 edx
  0020d	50		 push	 eax
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ?KundunEventItemBoxOpen@@YAXPAUOBJECTSTRUCT@@EEE@Z ; KundunEventItemBoxOpen
  00214	83 c4 10	 add	 esp, 16			; 00000010H
$LN101@gObjMonste@18:

; 2644 : 		int iMaxNumOfRewardItem = 3;
; 2645 : 
; 2646 : 		for ( int i=0;i<iMaxNumOfRewardItem;i++)

  00217	47		 inc	 edi
  00218	83 ff 03	 cmp	 edi, 3
  0021b	0f 8c 3f fe ff
	ff		 jl	 $LL135@gObjMonste@18
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
$LN103@gObjMonste@18:

; 2704 : 		}
; 2705 : 
; 2706 : 		return;
; 2707 : 	}
; 2708 : 	
; 2709 : 	if ( lpObj->Class == 249 || lpTargetObj->Class == 249 ||	// Guard
; 2710 : 		lpObj->Class == 247 || lpTargetObj->Class == 247 )	// Guard

  00228	b9 f9 00 00 00	 mov	 ecx, 249		; 000000f9H
  0022d	66 3b c1	 cmp	 ax, cx
  00230	0f 84 cb 09 00
	00		 je	 $LN91@gObjMonste@18
  00236	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  00239	0f b7 8f 98 00
	00 00		 movzx	 ecx, WORD PTR [edi+152]
  00240	bb f9 00 00 00	 mov	 ebx, 249		; 000000f9H
  00245	66 3b cb	 cmp	 cx, bx
  00248	0f 84 b3 09 00
	00		 je	 $LN91@gObjMonste@18
  0024e	bb f7 00 00 00	 mov	 ebx, 247		; 000000f7H
  00253	66 3b c3	 cmp	 ax, bx
  00256	0f 84 a5 09 00
	00		 je	 $LN91@gObjMonste@18
  0025c	66 3b cb	 cmp	 cx, bx
  0025f	0f 84 9c 09 00
	00		 je	 $LN91@gObjMonste@18

; 2711 : 	{
; 2712 : 		return;
; 2713 : 	}
; 2714 : 
; 2715 : 	if ( lpObj->m_RecallMon >= 0 )

  00265	39 96 cc 02 00
	00		 cmp	 DWORD PTR [esi+716], edx
  0026b	0f 8d 90 09 00
	00		 jge	 $LN91@gObjMonste@18

; 2716 : 	{
; 2717 : 		return;
; 2718 : 	}
; 2719 : 	
; 2720 : 	if ( lpObj->Class == 131 )	// Castle Gate

  00271	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00276	66 3b c1	 cmp	 ax, cx
  00279	0f 84 82 09 00
	00		 je	 $LN91@gObjMonste@18

; 2721 : 	{
; 2722 : 		return;
; 2723 : 	}
; 2724 : 	
; 2725 : 	if ( BC_STATUE_RANGE(lpObj->Class-132) )	// Blood Castle Statue

  0027f	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  00284	3b c2		 cmp	 eax, edx
  00286	7c 12		 jl	 SHORT $LN129@gObjMonste@18
  00288	33 c9		 xor	 ecx, ecx
  0028a	83 f8 02	 cmp	 eax, 2
  0028d	0f 9e c1	 setle	 cl
  00290	8b c1		 mov	 eax, ecx
  00292	3b c2		 cmp	 eax, edx
  00294	0f 85 67 09 00
	00		 jne	 $LN91@gObjMonste@18
$LN129@gObjMonste@18:

; 2726 : 	{
; 2727 : 		return;
; 2728 : 	}
; 2729 : 	
; 2730 : 	if ( CC_MAP_RANGE(lpObj->MapNumber) )

  0029a	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  002a0	3c 12		 cmp	 al, 18			; 00000012H
  002a2	72 37		 jb	 SHORT $LN87@gObjMonste@18
  002a4	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  002a9	3a c8		 cmp	 cl, al
  002ab	1b c9		 sbb	 ecx, ecx
  002ad	41		 inc	 ecx
  002ae	3b ca		 cmp	 ecx, edx
  002b0	74 29		 je	 SHORT $LN87@gObjMonste@18

; 2731 : 	{
; 2732 : 		g_ChaosCastle.SearchNDropMonsterItem(lpObj->MapNumber-MAP_INDEX_CHAOSCASTLE1, lpObj->m_Index, lpTargetObj->m_Index);

  002b2	8b 17		 mov	 edx, DWORD PTR [edi]
  002b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002b6	52		 push	 edx
  002b7	0f b6 d0	 movzx	 edx, al
  002ba	51		 push	 ecx
  002bb	83 ea 12	 sub	 edx, 18			; 00000012H
  002be	52		 push	 edx
  002bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  002c4	e8 00 00 00 00	 call	 ?SearchNDropMonsterItem@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::SearchNDropMonsterItem

; 2733 : 		gObjDel(lpObj->m_Index);

  002c9	8b 06		 mov	 eax, DWORD PTR [esi]
  002cb	50		 push	 eax
  002cc	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  002d1	83 c4 04	 add	 esp, 4
  002d4	5f		 pop	 edi
  002d5	5e		 pop	 esi
  002d6	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  002d7	8b e5		 mov	 esp, ebp
  002d9	5d		 pop	 ebp
  002da	c3		 ret	 0
$LN87@gObjMonste@18:

; 2734 : 		return;
; 2735 : 	}
; 2736 : 	
; 2737 : 	if ( lpObj->m_bIsInMonsterHerd )

  002db	39 96 24 0f 00
	00		 cmp	 DWORD PTR [esi+3876], edx
  002e1	74 1a		 je	 SHORT $LN84@gObjMonste@18

; 2738 : 	{
; 2739 : 		MonsterHerd * lpMH = lpObj->m_lpMonsterHerd;

  002e3	8b 8e 2c 0f 00
	00		 mov	 ecx, DWORD PTR [esi+3884]

; 2740 : 
; 2741 : 		if ( lpMH )

  002e9	3b ca		 cmp	 ecx, edx
  002eb	74 10		 je	 SHORT $LN84@gObjMonste@18

; 2742 : 		{
; 2743 : 			if ( lpMH->MonsterHerdItemDrop(lpObj) )

  002ed	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ef	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  002f2	56		 push	 esi
  002f3	ff d0		 call	 eax
  002f5	85 c0		 test	 eax, eax
  002f7	0f 85 04 09 00
	00		 jne	 $LN91@gObjMonste@18
$LN84@gObjMonste@18:

; 2744 : 			{
; 2745 : 				return;
; 2746 : 			}
; 2747 : 		}
; 2748 : 	}
; 2749 : 	
; 2750 : 	int itemrate = lpObj->m_ItemRate;

  002fd	0f bf 86 28 03
	00 00		 movsx	 eax, WORD PTR [esi+808]

; 2751 : 	int moneyrate = lpObj->m_MoneyRate;

  00304	0f bf 8e 2a 03
	00 00		 movsx	 ecx, WORD PTR [esi+810]

; 2752 : 
; 2753 : 	if ( itemrate < 1 )

  0030b	bb 01 00 00 00	 mov	 ebx, 1
  00310	89 45 08	 mov	 DWORD PTR _itemrate$[ebp], eax
  00313	89 4d dc	 mov	 DWORD PTR _moneyrate$[ebp], ecx
  00316	3b c3		 cmp	 eax, ebx
  00318	7d 03		 jge	 SHORT $LN83@gObjMonste@18

; 2754 : 		itemrate = 1;

  0031a	89 5d 08	 mov	 DWORD PTR _itemrate$[ebp], ebx
$LN83@gObjMonste@18:

; 2755 : 
; 2756 : 	if ( moneyrate < 1 )

  0031d	3b cb		 cmp	 ecx, ebx
  0031f	7d 03		 jge	 SHORT $LN82@gObjMonste@18

; 2757 : 		moneyrate = 1;

  00321	89 5d dc	 mov	 DWORD PTR _moneyrate$[ebp], ebx
$LN82@gObjMonste@18:

; 2758 : 
; 2759 : 	if ( lpObj->Class == 44 ) // Dragon

  00324	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0032b	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0032e	0f 85 e8 00 00
	00		 jne	 $LN81@gObjMonste@18

; 2760 : 	{
; 2761 : 		dur = 255.0f;
; 2762 : 		x = lpObj->X;

  00334	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 2763 : 		y = lpObj->Y;

  0033b	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 2764 : 		level = 0;
; 2765 : 
; 2766 : 		if ( (rand()%4) > 0 )

  00342	e8 00 00 00 00	 call	 _rand
  00347	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0034c	79 05		 jns	 SHORT $LN150@gObjMonste@18
  0034e	48		 dec	 eax
  0034f	83 c8 fc	 or	 eax, -4			; fffffffcH
  00352	40		 inc	 eax
$LN150@gObjMonste@18:
  00353	85 c0		 test	 eax, eax
  00355	7e 66		 jle	 SHORT $LN80@gObjMonste@18

; 2767 : 		{
; 2768 : 			for ( int n=0;n<4;n++)

  00357	c7 45 08 04 00
	00 00		 mov	 DWORD PTR tv295[ebp], 4
  0035e	8b ff		 npad	 2
$LL79@gObjMonste@18:

; 2769 : 			{
; 2770 : 				int x = lpObj->X-2;

  00360	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 2771 : 				int y = lpObj->Y-2;

  00367	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]
  0036e	83 ef 02	 sub	 edi, 2
  00371	83 eb 02	 sub	 ebx, 2

; 2772 : 				x+= rand()%3;

  00374	e8 00 00 00 00	 call	 _rand
  00379	99		 cdq
  0037a	b9 03 00 00 00	 mov	 ecx, 3
  0037f	f7 f9		 idiv	 ecx
  00381	03 fa		 add	 edi, edx

; 2773 : 				y+= rand()%3;

  00383	e8 00 00 00 00	 call	 _rand
  00388	99		 cdq
  00389	b9 03 00 00 00	 mov	 ecx, 3
  0038e	f7 f9		 idiv	 ecx

; 2774 : 
; 2775 : 				MapC[lpObj->MapNumber].MoneyItemDrop(10000, x, y);

  00390	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00397	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  0039d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  003a3	03 da		 add	 ebx, edx
  003a5	53		 push	 ebx
  003a6	57		 push	 edi
  003a7	68 10 27 00 00	 push	 10000			; 00002710H
  003ac	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
  003b1	ff 4d 08	 dec	 DWORD PTR tv295[ebp]
  003b4	75 aa		 jne	 SHORT $LL79@gObjMonste@18
  003b6	5f		 pop	 edi
  003b7	5e		 pop	 esi
  003b8	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  003b9	8b e5		 mov	 esp, ebp
  003bb	5d		 pop	 ebp
  003bc	c3		 ret	 0
$LN80@gObjMonste@18:

; 2776 : 			}
; 2777 : 
; 2778 : 			return;
; 2779 : 		}
; 2780 : 		
; 2781 : 		if ( (rand()%3) < 2 )

  003bd	e8 00 00 00 00	 call	 _rand
  003c2	99		 cdq
  003c3	b9 03 00 00 00	 mov	 ecx, 3
  003c8	f7 f9		 idiv	 ecx

; 2782 : 		{
; 2783 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  003ca	56		 push	 esi
  003cb	83 fa 02	 cmp	 edx, 2
  003ce	7d 43		 jge	 SHORT $LN76@gObjMonste@18
  003d0	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2784 : 			type = ItemGetNumberMake(14, 13);

  003d5	6a 0d		 push	 13			; 0000000dH
$LN160@gObjMonste@18:
  003d7	6a 0e		 push	 14			; 0000000eH
  003d9	89 45 08	 mov	 DWORD PTR _MaxHitUser$158821[ebp], eax
  003dc	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 2785 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2786 : 				Option1, Option2, Option3, MaxHitUser, 0, 0);

  003e1	8b 55 08	 mov	 edx, DWORD PTR _MaxHitUser$158821[ebp]
  003e4	6a 00		 push	 0
  003e6	6a 00		 push	 0
  003e8	52		 push	 edx
  003e9	6a 00		 push	 0
  003eb	6a 00		 push	 0
  003ed	6a 00		 push	 0
  003ef	68 ff 00 00 00	 push	 255			; 000000ffH
  003f4	6a 00		 push	 0
  003f6	50		 push	 eax
  003f7	53		 push	 ebx
  003f8	57		 push	 edi
$LN157@gObjMonste@18:
  003f9	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00400	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00402	50		 push	 eax
  00403	51		 push	 ecx
  00404	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00409	83 c4 40	 add	 esp, 64			; 00000040H
  0040c	5f		 pop	 edi
  0040d	5e		 pop	 esi
  0040e	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  0040f	8b e5		 mov	 esp, ebp
  00411	5d		 pop	 ebp
  00412	c3		 ret	 0
$LN76@gObjMonste@18:

; 2787 : 
; 2788 : 			return;
; 2789 : 		}
; 2790 : 
; 2791 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00413	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2792 : 		type = ItemGetNumberMake(14, 14);

  00418	6a 0e		 push	 14			; 0000000eH

; 2793 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2794 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);
; 2795 : 
; 2796 : 		return;

  0041a	eb bb		 jmp	 SHORT $LN160@gObjMonste@18
$LN81@gObjMonste@18:

; 2797 : 	}
; 2798 : 
; 2799 : 	if ( lpObj->Class == 43 ) // Golden Budge Dragon

  0041c	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0041f	75 58		 jne	 SHORT $LN75@gObjMonste@18

; 2800 : 	{
; 2801 : 		dur = 255.0f;
; 2802 : 		x = lpObj->X;

  00421	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 2803 : 		y = lpObj->Y;

  00428	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 2804 : 		level = 0;
; 2805 : 		type = ItemGetNumberMake(14, 11);

  0042f	6a 0b		 push	 11			; 0000000bH
  00431	6a 0e		 push	 14			; 0000000eH
  00433	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00438	83 c4 08	 add	 esp, 8

; 2806 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 2807 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2808 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);

  0043b	6a 00		 push	 0
  0043d	6a 00		 push	 0
  0043f	56		 push	 esi
  00440	89 45 08	 mov	 DWORD PTR _type$[ebp], eax
  00443	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00448	83 c4 04	 add	 esp, 4
  0044b	50		 push	 eax
  0044c	6a 00		 push	 0
  0044e	6a 00		 push	 0
  00450	6a 00		 push	 0
  00452	68 ff 00 00 00	 push	 255			; 000000ffH
  00457	6a 00		 push	 0
$LN158@gObjMonste@18:
  00459	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0045c	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00463	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00465	52		 push	 edx
  00466	53		 push	 ebx
  00467	57		 push	 edi
  00468	50		 push	 eax
  00469	51		 push	 ecx
  0046a	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  0046f	83 c4 34	 add	 esp, 52			; 00000034H
  00472	5f		 pop	 edi
  00473	5e		 pop	 esi
  00474	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  00475	8b e5		 mov	 esp, ebp
  00477	5d		 pop	 ebp
  00478	c3		 ret	 0
$LN75@gObjMonste@18:

; 2809 : 
; 2810 : 		return;
; 2811 : 	}
; 2812 : 
; 2813 : 	if ( lpObj->Class == 53 ) // Golden Titan

  00479	83 f8 35	 cmp	 eax, 53			; 00000035H
  0047c	75 3a		 jne	 SHORT $LN74@gObjMonste@18

; 2814 : 	{
; 2815 : 		dur = 255.0f;
; 2816 : 		x = lpObj->X;

  0047e	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 2817 : 		y = lpObj->Y;

  00485	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]

; 2818 : 		level = 9;
; 2819 : 		type = ItemGetNumberMake(14, 11);

  0048c	6a 0b		 push	 11			; 0000000bH
  0048e	6a 0e		 push	 14			; 0000000eH
  00490	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00495	83 c4 08	 add	 esp, 8

; 2820 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);
; 2821 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2822 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);

  00498	6a 00		 push	 0
  0049a	6a 00		 push	 0
  0049c	56		 push	 esi
  0049d	89 45 08	 mov	 DWORD PTR _type$[ebp], eax
  004a0	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  004a5	83 c4 04	 add	 esp, 4
  004a8	50		 push	 eax
  004a9	6a 00		 push	 0
  004ab	6a 00		 push	 0
  004ad	6a 00		 push	 0
  004af	68 ff 00 00 00	 push	 255			; 000000ffH
  004b4	6a 09		 push	 9

; 2823 : 
; 2824 : 		return;

  004b6	eb a1		 jmp	 SHORT $LN158@gObjMonste@18
$LN74@gObjMonste@18:

; 2825 : 	}
; 2826 : 
; 2827 : 	if ( lpObj->Class == 55 )	// Death King

  004b8	83 f8 37	 cmp	 eax, 55			; 00000037H
  004bb	0f 85 b9 00 00
	00		 jne	 $LN73@gObjMonste@18

; 2828 : 	{
; 2829 : 		if ( AttackEvent55BagOpen(lpObj)==1 )

  004c1	56		 push	 esi
  004c2	e8 00 00 00 00	 call	 ?AttackEvent55BagOpen@@YAHPAUOBJECTSTRUCT@@@Z ; AttackEvent55BagOpen
  004c7	83 c4 04	 add	 esp, 4
  004ca	3b c3		 cmp	 eax, ebx
  004cc	0f 84 2f 07 00
	00		 je	 $LN91@gObjMonste@18

; 2830 : 			return;
; 2831 : 
; 2832 : 		itemrate = 1;

  004d2	89 5d 08	 mov	 DWORD PTR _itemrate$[ebp], ebx
$LN64@gObjMonste@18:

; 2885 : 	}
; 2886 : 
; 2887 : 	if ( gEventMonsterItemDrop(lpObj, lpTargetObj) )

  004d5	57		 push	 edi
  004d6	56		 push	 esi
  004d7	e8 00 00 00 00	 call	 ?gEventMonsterItemDrop@@YAHPAUOBJECTSTRUCT@@0@Z ; gEventMonsterItemDrop
  004dc	83 c4 08	 add	 esp, 8
  004df	85 c0		 test	 eax, eax
  004e1	0f 85 1a 07 00
	00		 jne	 $LN91@gObjMonste@18

; 2888 : 		return;
; 2889 : 
; 2890 : 	if ( g_QuestInfo.MonsterItemDrop(lpObj) )

  004e7	56		 push	 esi
  004e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  004ed	e8 00 00 00 00	 call	 ?MonsterItemDrop@CQuestInfo@@QAEHPAUOBJECTSTRUCT@@@Z ; CQuestInfo::MonsterItemDrop
  004f2	85 c0		 test	 eax, eax
  004f4	0f 85 07 07 00
	00		 jne	 $LN91@gObjMonste@18

; 2891 : 		return;
; 2892 : 
; 2893 : 	if ( lpTargetObj->Level <= 20 )

  004fa	66 83 bf 9c 00
	00 00 14	 cmp	 WORD PTR [edi+156], 20	; 00000014H
  00502	7f 62		 jg	 SHORT $LN60@gObjMonste@18

; 2894 : 	{
; 2895 : 		if ( (rand()%10000) < 2000 )

  00504	e8 00 00 00 00	 call	 _rand
  00509	99		 cdq
  0050a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  0050f	f7 f9		 idiv	 ecx
  00511	81 fa d0 07 00
	00		 cmp	 edx, 2000		; 000007d0H
  00517	7d 4d		 jge	 SHORT $LN60@gObjMonste@18

; 2896 : 		{
; 2897 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00519	56		 push	 esi
  0051a	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2898 : 			x = lpObj->X;
; 2899 : 			y = lpObj->Y;

  0051f	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00526	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 2900 : 			dur = 1.0f;
; 2901 : 			level = 0;
; 2902 : 			type = ItemGetNumberMake(14, 0);	// Apple

  0052d	6a 00		 push	 0
  0052f	6a 0e		 push	 14			; 0000000eH
  00531	8b f8		 mov	 edi, eax
  00533	89 55 fc	 mov	 DWORD PTR _y$[ebp], edx
  00536	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 2903 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2904 : 				Option1, Option2, Option3, MaxHitUser, 0, 0);

  0053b	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00542	6a 00		 push	 0
  00544	8b 16		 mov	 edx, DWORD PTR [esi]
  00546	6a 00		 push	 0
  00548	57		 push	 edi
  00549	6a 00		 push	 0
  0054b	6a 00		 push	 0
  0054d	6a 00		 push	 0
  0054f	6a 01		 push	 1
  00551	6a 00		 push	 0
  00553	50		 push	 eax
  00554	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  00557	50		 push	 eax
  00558	53		 push	 ebx
  00559	51		 push	 ecx
  0055a	52		 push	 edx
  0055b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00560	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  00563	83 c4 40	 add	 esp, 64			; 00000040H
$LN60@gObjMonste@18:

; 2905 : 		}
; 2906 : 	}
; 2907 : 
; 2908 : 	if(gServerInfo.m_Data.iDropItemMonsterRate[0] == 0)

  00566	83 3d 18 01 00
	00 00		 cmp	 DWORD PTR ?gServerInfo@@3VCServerInfo@@A+280, 0
  0056d	0f 85 3f 01 00
	00		 jne	 $LN59@gObjMonste@18

; 2909 : 	{
; 2910 : 		ExtDropPer = 0;

  00573	33 db		 xor	 ebx, ebx

; 2911 : 	}
; 2912 : 	else

  00575	e9 46 01 00 00	 jmp	 $LN58@gObjMonste@18
$LN73@gObjMonste@18:

; 2833 : 	}
; 2834 : 	else if ( lpObj->Class == 78 ) // Golden Goblin

  0057a	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0057d	75 54		 jne	 SHORT $LN70@gObjMonste@18

; 2835 : 	{
; 2836 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0057f	56		 push	 esi
  00580	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2837 : 		x = lpObj->X;
; 2838 : 		y = lpObj->Y;

  00585	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  0058c	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 2839 : 		dur = 255.0f;
; 2840 : 		level = 8;
; 2841 : 		type = ItemGetNumberMake(14, 11);

  00593	6a 0b		 push	 11			; 0000000bH
  00595	6a 0e		 push	 14			; 0000000eH
  00597	8b f8		 mov	 edi, eax
  00599	89 55 fc	 mov	 DWORD PTR _y$[ebp], edx
  0059c	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 2842 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2843 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);

  005a1	6a 00		 push	 0
  005a3	6a 00		 push	 0
  005a5	57		 push	 edi
  005a6	6a 00		 push	 0
  005a8	6a 00		 push	 0
  005aa	6a 00		 push	 0
  005ac	68 ff 00 00 00	 push	 255			; 000000ffH
  005b1	6a 08		 push	 8
$LN159@gObjMonste@18:
  005b3	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  005ba	8b 16		 mov	 edx, DWORD PTR [esi]
  005bc	50		 push	 eax
  005bd	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  005c0	50		 push	 eax
  005c1	53		 push	 ebx
  005c2	51		 push	 ecx
  005c3	52		 push	 edx
  005c4	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  005c9	83 c4 40	 add	 esp, 64			; 00000040H
  005cc	5f		 pop	 edi
  005cd	5e		 pop	 esi
  005ce	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  005cf	8b e5		 mov	 esp, ebp
  005d1	5d		 pop	 ebp
  005d2	c3		 ret	 0
$LN70@gObjMonste@18:

; 2844 : 
; 2845 : 		return;
; 2846 : 	}
; 2847 : 	else if ( lpObj->Class == 79 )	// Golden Derkon

  005d3	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  005d6	75 54		 jne	 SHORT $LN68@gObjMonste@18

; 2848 : 	{
; 2849 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  005d8	56		 push	 esi
  005d9	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2850 : 		x = lpObj->X;

  005de	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]
  005e5	8b f8		 mov	 edi, eax

; 2851 : 		y = lpObj->Y;

  005e7	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]

; 2852 : 		dur = 255.0f;
; 2853 : 		level = 10;
; 2854 : 		type = ItemGetNumberMake(14, 11);

  005ee	6a 0b		 push	 11			; 0000000bH
  005f0	6a 0e		 push	 14			; 0000000eH
  005f2	89 45 fc	 mov	 DWORD PTR _y$[ebp], eax
  005f5	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 2855 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2856 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);

  005fa	8b 4d fc	 mov	 ecx, DWORD PTR _y$[ebp]
  005fd	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  00604	6a 00		 push	 0
  00606	6a 00		 push	 0
  00608	57		 push	 edi
  00609	6a 00		 push	 0
  0060b	6a 00		 push	 0
  0060d	6a 00		 push	 0
  0060f	68 ff 00 00 00	 push	 255			; 000000ffH
  00614	6a 0a		 push	 10			; 0000000aH
  00616	50		 push	 eax
  00617	8b 06		 mov	 eax, DWORD PTR [esi]
  00619	51		 push	 ecx
  0061a	53		 push	 ebx
  0061b	52		 push	 edx
  0061c	50		 push	 eax
  0061d	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00622	83 c4 40	 add	 esp, 64			; 00000040H
  00625	5f		 pop	 edi
  00626	5e		 pop	 esi
  00627	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  00628	8b e5		 mov	 esp, ebp
  0062a	5d		 pop	 ebp
  0062b	c3		 ret	 0
$LN68@gObjMonste@18:

; 2857 : 
; 2858 : 		return;	
; 2859 : 	}
; 2860 : 	else if ( lpObj->Class == 80 )	//Golden Lizard King

  0062c	83 f8 50	 cmp	 eax, 80			; 00000050H
  0062f	75 3f		 jne	 SHORT $LN66@gObjMonste@18

; 2861 : 	{
; 2862 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00631	56		 push	 esi
  00632	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2863 : 		x = lpObj->X;
; 2864 : 		y = lpObj->Y;

  00637	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  0063e	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 2865 : 		dur = 255.0f;
; 2866 : 		level = 11;
; 2867 : 		type = ItemGetNumberMake(14, 11);

  00645	6a 0b		 push	 11			; 0000000bH
  00647	6a 0e		 push	 14			; 0000000eH
  00649	8b f8		 mov	 edi, eax
  0064b	89 4d fc	 mov	 DWORD PTR _y$[ebp], ecx
  0064e	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 2868 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2869 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);

  00653	8b 55 fc	 mov	 edx, DWORD PTR _y$[ebp]
  00656	6a 00		 push	 0
  00658	6a 00		 push	 0
  0065a	57		 push	 edi
  0065b	6a 00		 push	 0
  0065d	6a 00		 push	 0
  0065f	6a 00		 push	 0
  00661	68 ff 00 00 00	 push	 255			; 000000ffH
  00666	6a 0b		 push	 11			; 0000000bH
  00668	50		 push	 eax
  00669	52		 push	 edx
  0066a	53		 push	 ebx

; 2870 : 
; 2871 : 		return;	

  0066b	e9 89 fd ff ff	 jmp	 $LN157@gObjMonste@18
$LN66@gObjMonste@18:

; 2872 : 	}
; 2873 : 	else if ( lpObj->Class == 82 )	// Golden Tantalos

  00670	83 f8 52	 cmp	 eax, 82			; 00000052H
  00673	0f 85 5c fe ff
	ff		 jne	 $LN64@gObjMonste@18

; 2874 : 	{
; 2875 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00679	56		 push	 esi
  0067a	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 2876 : 		x = lpObj->X;
; 2877 : 		y = lpObj->Y;

  0067f	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00686	0f bf 9e 04 01
	00 00		 movsx	 ebx, WORD PTR [esi+260]

; 2878 : 		dur = 255.0f;
; 2879 : 		level = 12;
; 2880 : 		type = ItemGetNumberMake(14, 11);

  0068d	6a 0b		 push	 11			; 0000000bH
  0068f	6a 0e		 push	 14			; 0000000eH
  00691	8b f8		 mov	 edi, eax
  00693	89 55 fc	 mov	 DWORD PTR _y$[ebp], edx
  00696	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 2881 : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 2882 : 			Option1, Option2, Option3, MaxHitUser, 0, 0);

  0069b	6a 00		 push	 0
  0069d	6a 00		 push	 0
  0069f	57		 push	 edi
  006a0	6a 00		 push	 0
  006a2	6a 00		 push	 0
  006a4	6a 00		 push	 0
  006a6	68 ff 00 00 00	 push	 255			; 000000ffH
  006ab	6a 0c		 push	 12			; 0000000cH

; 2883 : 
; 2884 : 		return;	

  006ad	e9 01 ff ff ff	 jmp	 $LN159@gObjMonste@18
$LN59@gObjMonste@18:

; 2913 : 	{
; 2914 : 		ExtDropPer = rand()%gServerInfo.m_Data.iDropItemMonsterRate[0];

  006b2	e8 00 00 00 00	 call	 _rand
  006b7	99		 cdq
  006b8	f7 3d 18 01 00
	00		 idiv	 DWORD PTR ?gServerInfo@@3VCServerInfo@@A+280
  006be	8b da		 mov	 ebx, edx
$LN58@gObjMonste@18:

; 2915 : 	}
; 2916 : 
; 2917 : 	int ItemDropPer = gVip.GetDropRate(lpObj->m_Vip);

  006c0	8b 86 3c 15 00
	00		 mov	 eax, DWORD PTR [esi+5436]
  006c6	50		 push	 eax
  006c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gVip@@3VCVip@@A ; gVip
  006cc	e8 00 00 00 00	 call	 ?GetDropRate@CVip@@QAEMH@Z ; CVip::GetDropRate
  006d1	e8 00 00 00 00	 call	 __ftol2_sse

; 2918 : 	ItemDropPer += gVip.GetDropRate(lpObj->m_Vip) * lpTargetObj->SetOpImproveItemDropRate / 100;

  006d6	8b 8e 3c 15 00
	00		 mov	 ecx, DWORD PTR [esi+5436]
  006dc	51		 push	 ecx
  006dd	b9 00 00 00 00	 mov	 ecx, OFFSET ?gVip@@3VCVip@@A ; gVip
  006e2	89 45 f0	 mov	 DWORD PTR _ItemDropPer$[ebp], eax
  006e5	e8 00 00 00 00	 call	 ?GetDropRate@CVip@@QAEMH@Z ; CVip::GetDropRate
  006ea	0f b6 97 81 0f
	00 00		 movzx	 edx, BYTE PTR [edi+3969]
  006f1	89 55 e0	 mov	 DWORD PTR tv1298[ebp], edx
  006f4	db 45 e0	 fild	 DWORD PTR tv1298[ebp]
  006f7	de c9		 fmulp	 ST(1), ST(0)
  006f9	dc 35 00 00 00
	00		 fdiv	 QWORD PTR __real@4059000000000000
  006ff	da 45 f0	 fiadd	 DWORD PTR _ItemDropPer$[ebp]
  00702	e8 00 00 00 00	 call	 __ftol2_sse
  00707	8b f8		 mov	 edi, eax
  00709	89 7d f0	 mov	 DWORD PTR _ItemDropPer$[ebp], edi

; 2919 : 
; 2920 : 	if ( ExtDropPer == TRUE )

  0070c	83 fb 01	 cmp	 ebx, 1
  0070f	0f 85 cb 00 00
	00		 jne	 $LN57@gObjMonste@18

; 2921 : 	{
; 2922 : 		DropItem = g_MonsterItemMng.GetItem(lpObj->Level-25);

  00715	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  0071c	83 e8 19	 sub	 eax, 25			; 00000019H
  0071f	50		 push	 eax
  00720	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  00725	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  0072a	8b f8		 mov	 edi, eax
  0072c	89 7d ec	 mov	 DWORD PTR _DropItem$[ebp], edi

; 2923 : 
; 2924 : 		if ( !DropItem )

  0072f	85 ff		 test	 edi, edi
  00731	74 36		 je	 SHORT $LN36@gObjMonste@18

; 2925 : 			item_drop = FALSE;
; 2926 : 		else
; 2927 : 		{
; 2928 : 			int foundChangeupitem=0;
; 2929 : 			
; 2930 : 			for ( int i=0;i<MAX_TYPE_PLAYER-1;i++)	// #error Delete the -1

  00733	33 c0		 xor	 eax, eax
$LL54@gObjMonste@18:

; 2931 : 			{
; 2932 : 				if ( DropItem->m_RequireClass[i] > 1 )

  00735	80 7c 38 50 01	 cmp	 BYTE PTR [eax+edi+80], 1
  0073a	77 08		 ja	 SHORT $LN124@gObjMonste@18

; 2925 : 			item_drop = FALSE;
; 2926 : 		else
; 2927 : 		{
; 2928 : 			int foundChangeupitem=0;
; 2929 : 			
; 2930 : 			for ( int i=0;i<MAX_TYPE_PLAYER-1;i++)	// #error Delete the -1

  0073c	40		 inc	 eax
  0073d	83 f8 04	 cmp	 eax, 4
  00740	7c f3		 jl	 SHORT $LL54@gObjMonste@18

; 2931 : 			{
; 2932 : 				if ( DropItem->m_RequireClass[i] > 1 )

  00742	eb 13		 jmp	 SHORT $LN130@gObjMonste@18
$LN124@gObjMonste@18:

; 2933 : 				{
; 2934 : 					foundChangeupitem = TRUE;
; 2935 : 					break;
; 2936 : 				}
; 2937 : 			}
; 2938 : 
; 2939 : 			if ( foundChangeupitem )
; 2940 : 				ExtDropPer = rand()%100;

  00744	e8 00 00 00 00	 call	 _rand
  00749	99		 cdq
  0074a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0074f	f7 f9		 idiv	 ecx
  00751	8b da		 mov	 ebx, edx

; 2941 : 
; 2942 : 			if ( ExtDropPer )

  00753	85 db		 test	 ebx, ebx
  00755	74 12		 je	 SHORT $LN36@gObjMonste@18
$LN130@gObjMonste@18:

; 2943 : 				if ( (rand()%itemrate) < ItemDropPer )

  00757	e8 00 00 00 00	 call	 _rand
  0075c	99		 cdq
  0075d	f7 7d 08	 idiv	 DWORD PTR _itemrate$[ebp]
  00760	3b 55 f0	 cmp	 edx, DWORD PTR _ItemDropPer$[ebp]
  00763	0f 8c a7 00 00
	00		 jl	 $LN153@gObjMonste@18
$LN36@gObjMonste@18:

; 3083 : 	}
; 3084 : 	else if ( lpObj->Money < 1 )

  00769	83 be b0 00 00
	00 01		 cmp	 DWORD PTR [esi+176], 1
  00770	0f 8c 8b 04 00
	00		 jl	 $LN91@gObjMonste@18

; 3085 : 	{
; 3086 : 		return;
; 3087 : 	}
; 3088 : 	else if ( (rand()%moneyrate) < 10 )

  00776	e8 00 00 00 00	 call	 _rand
  0077b	99		 cdq
  0077c	f7 7d dc	 idiv	 DWORD PTR _moneyrate$[ebp]
  0077f	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00782	0f 8d 71 03 00
	00		 jge	 $LN140@gObjMonste@18

; 3089 : 	{
; 3090 : 		int x = lpObj->X;
; 3091 : 		int y = lpObj->Y;
; 3092 : 
; 3093 : 		double money = lpObj->Money;
; 3094 : 		float percent = 100;
; 3095 : 		money *= gServerInfo.m_Data.fRateZen;
; 3096 : 
; 3097 : 		percent += lpTargetObj->MonsterDieGetMoney;
; 3098 : 
; 3099 : 		money = (money * percent) / 100.0f;

  00788	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0078b	db 86 b0 00 00
	00		 fild	 DWORD PTR [esi+176]
  00791	0f bf 82 16 01
	00 00		 movsx	 eax, WORD PTR [edx+278]
  00798	89 45 08	 mov	 DWORD PTR tv1197[ebp], eax
  0079b	d8 0d 80 00 00
	00		 fmul	 DWORD PTR ?gServerInfo@@3VCServerInfo@@A+128
  007a1	0f bf 8e 04 01
	00 00		 movsx	 ecx, WORD PTR [esi+260]
  007a8	db 45 08	 fild	 DWORD PTR tv1197[ebp]
  007ab	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4059000000000000
  007b1	0f bf be 06 01
	00 00		 movsx	 edi, WORD PTR [esi+262]
  007b8	dc c1		 fadd	 ST(1), ST(0)
  007ba	d9 c9		 fxch	 ST(1)
  007bc	d9 5d 08	 fstp	 DWORD PTR tv1196[ebp]
  007bf	d9 45 08	 fld	 DWORD PTR tv1196[ebp]
  007c2	de ca		 fmulp	 ST(2), ST(0)
  007c4	de f9		 fdivp	 ST(1), ST(0)

; 3100 : 
; 3101 : 		if(money > MAX_ZEN)

  007c6	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@41ddcd6500000000
  007cc	d8 d1		 fcom	 ST(1)
  007ce	df e0		 fnstsw	 ax
  007d0	f6 c4 05	 test	 ah, 5
  007d3	0f 8a cd 02 00
	00		 jp	 $LN144@gObjMonste@18

; 3102 : 		{
; 3103 : 			money = MAX_ZEN;

  007d9	dd d9		 fstp	 ST(1)
  007db	e9 c8 02 00 00	 jmp	 $LN12@gObjMonste@18
$LN57@gObjMonste@18:

; 2944 : 					item_drop=TRUE;
; 2945 : 		}
; 2946 : 	}
; 2947 : 	else
; 2948 : 	{
; 2949 : 		if ( (rand()%itemrate) < ItemDropPer )

  007e0	e8 00 00 00 00	 call	 _rand
  007e5	99		 cdq
  007e6	f7 7d 08	 idiv	 DWORD PTR _itemrate$[ebp]
  007e9	3b d7		 cmp	 edx, edi
  007eb	0f 8d 78 ff ff
	ff		 jge	 $LN36@gObjMonste@18

; 2950 : 		{
; 2951 : 			DropItem = g_MonsterItemMng.GetItem(lpObj->Level);

  007f1	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  007f8	52		 push	 edx
  007f9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterItemMng@@3VCMonsterItemMng@@A ; g_MonsterItemMng
  007fe	e8 00 00 00 00	 call	 ?GetItem@CMonsterItemMng@@QAEPAVCItem@@H@Z ; CMonsterItemMng::GetItem
  00803	8b f8		 mov	 edi, eax
  00805	89 45 ec	 mov	 DWORD PTR _DropItem$[ebp], eax

; 2952 : 
; 2953 : 			if ( !DropItem )

  00808	85 ff		 test	 edi, edi
  0080a	0f 84 59 ff ff
	ff		 je	 $LN36@gObjMonste@18
$LN153@gObjMonste@18:

; 2954 : 				item_drop = FALSE;
; 2955 : 			else
; 2956 : 				item_drop = TRUE;
; 2957 : 
; 2958 : 		}
; 2959 : 	}
; 2960 : 
; 2961 : 	if ( item_drop )
; 2962 : 	{
; 2963 : 		if ( !DropItem->IsItem() )

  00810	8b cf		 mov	 ecx, edi
  00812	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 1
  00819	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0081e	85 c0		 test	 eax, eax
  00820	75 03		 jne	 SHORT $LN141@gObjMonste@18

; 2964 : 		{
; 2965 : 			item_drop = FALSE;

  00822	89 45 08	 mov	 DWORD PTR _item_drop$[ebp], eax
$LN141@gObjMonste@18:

; 2966 : 		}
; 2967 : 
; 2968 : 		int I;
; 2969 : 
; 2970 : 		if ( DropItem->m_Type >= ITEMGET(15,0)  && DropItem->m_Type <= ITEMGET(16,0) )
; 2971 : 		{
; 2972 : 			I = 0;
; 2973 : 		}
; 2974 : 
; 2975 : 		if ( DS_MAP_RANGE(lpObj->MapNumber ) )

  00825	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  0082b	3c 09		 cmp	 al, 9
  0082d	74 0d		 je	 SHORT $LN133@gObjMonste@18
  0082f	33 c9		 xor	 ecx, ecx
  00831	3c 20		 cmp	 al, 32			; 00000020H
  00833	0f 94 c1	 sete	 cl
  00836	8b c1		 mov	 eax, ecx
  00838	85 c0		 test	 eax, eax
  0083a	74 29		 je	 SHORT $LN142@gObjMonste@18
$LN133@gObjMonste@18:

; 2976 : 		{
; 2977 : 			if ( !IsCanNotItemDtopInDevilSquare(DropItem->m_Type) )

  0083c	0f bf 57 06	 movsx	 edx, WORD PTR [edi+6]
  00840	52		 push	 edx
  00841	e8 00 00 00 00	 call	 ?IsCanNotItemDtopInDevilSquare@@YAHH@Z ; IsCanNotItemDtopInDevilSquare
  00846	83 c4 04	 add	 esp, 4
  00849	85 c0		 test	 eax, eax
  0084b	75 18		 jne	 SHORT $LN142@gObjMonste@18

; 2978 : 			{
; 2979 : 				if ( (rand()%10) )

  0084d	e8 00 00 00 00	 call	 _rand
  00852	99		 cdq
  00853	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00858	f7 f9		 idiv	 ecx
  0085a	85 d2		 test	 edx, edx
  0085c	74 07		 je	 SHORT $LN142@gObjMonste@18

; 2980 : 				{
; 2981 : 					item_drop = FALSE;

  0085e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _item_drop$[ebp], 0
$LN142@gObjMonste@18:

; 2982 : 				}
; 2983 : 			}
; 2984 : 		}
; 2985 : 
; 2986 : 		if ( DropItem->m_Type == ITEMGET(13,14) && lpObj->MapNumber != MAP_INDEX_ICARUS) // Loch Feather

  00865	0f b7 47 06	 movzx	 eax, WORD PTR [edi+6]
  00869	ba 0e 1a 00 00	 mov	 edx, 6670		; 00001a0eH
  0086e	66 3b c2	 cmp	 ax, dx
  00871	75 0d		 jne	 SHORT $LN37@gObjMonste@18
  00873	80 be 09 01 00
	00 0a		 cmp	 BYTE PTR [esi+265], 10	; 0000000aH
  0087a	0f 85 e9 fe ff
	ff		 jne	 $LN36@gObjMonste@18
$LN37@gObjMonste@18:

; 2987 : 			item_drop = FALSE;
; 2988 : 	}
; 2989 : 
; 2990 : 	if ( item_drop)

  00880	83 7d 08 00	 cmp	 DWORD PTR _item_drop$[ebp], 0
  00884	0f 84 df fe ff
	ff		 je	 $LN36@gObjMonste@18

; 2991 : 	{
; 2992 : 		type = DropItem->m_Type;
; 2993 : 		level = DropItem->m_Level;

  0088a	0f bf 4f 08	 movsx	 ecx, WORD PTR [edi+8]
  0088e	98		 cwde
  0088f	89 45 d4	 mov	 DWORD PTR tv1188[ebp], eax
  00892	89 4d e4	 mov	 DWORD PTR _level$[ebp], ecx

; 2994 : 
; 2995 : 		if ( ExtDropPer == TRUE )

  00895	83 fb 01	 cmp	 ebx, 1
  00898	75 16		 jne	 SHORT $LN35@gObjMonste@18

; 2996 : 		{
; 2997 : 			dur = ItemGetDurability(DropItem->m_Type, 0, 1, 0);

  0089a	6a 00		 push	 0
  0089c	53		 push	 ebx
  0089d	6a 00		 push	 0
  0089f	50		 push	 eax
  008a0	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  008a5	89 45 08	 mov	 DWORD PTR tv1265[ebp], eax
  008a8	db 45 08	 fild	 DWORD PTR tv1265[ebp]
  008ab	83 c4 10	 add	 esp, 16			; 00000010H

; 2998 : 		}
; 2999 : 		else

  008ae	eb 03		 jmp	 SHORT $LN154@gObjMonste@18
$LN35@gObjMonste@18:

; 3000 : 		{
; 3001 : 			dur = DropItem->m_Durability;

  008b0	d9 47 24	 fld	 DWORD PTR [edi+36]
$LN154@gObjMonste@18:

; 3002 : 		}
; 3003 : 
; 3004 : 		x = lpObj->X;

  008b3	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  008ba	d9 5d e8	 fstp	 DWORD PTR _dur$[ebp]

; 3005 : 		y = lpObj->Y;

  008bd	0f bf 86 06 01
	00 00		 movsx	 eax, WORD PTR [esi+262]
  008c4	89 55 dc	 mov	 DWORD PTR _x$[ebp], edx
  008c7	89 45 fc	 mov	 DWORD PTR _y$[ebp], eax

; 3006 : 
; 3007 : 		int option1rand;
; 3008 : 		int option2rand;
; 3009 : 		int option3rand;
; 3010 : 		int optionc;
; 3011 : 
; 3012 : 		if ( ExtDropPer == TRUE )

  008ca	83 fb 01	 cmp	 ebx, 1
  008cd	75 48		 jne	 SHORT $LN33@gObjMonste@18

; 3013 : 		{
; 3014 : 			option1rand = gServerInfo.m_Data.iDropItemMonsterRate[1];

  008cf	8b 3d 1c 01 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+284

; 3015 : 			option2rand = gServerInfo.m_Data.iDropItemMonsterRate[2];

  008d5	8b 1d 20 01 00
	00		 mov	 ebx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+288

; 3016 : 			option3rand=rand()%100;

  008db	e8 00 00 00 00	 call	 _rand
  008e0	99		 cdq
  008e1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  008e6	f7 f9		 idiv	 ecx
  008e8	89 55 08	 mov	 DWORD PTR _option3rand$158878[ebp], edx

; 3017 : 			optionc=rand()%3;

  008eb	e8 00 00 00 00	 call	 _rand
  008f0	99		 cdq
  008f1	b9 03 00 00 00	 mov	 ecx, 3
  008f6	f7 f9		 idiv	 ecx
  008f8	89 55 e0	 mov	 DWORD PTR _optionc$158879[ebp], edx

; 3018 : 			NOption = NewOptionRand(lpObj->Level);

  008fb	0f bf 96 9c 00
	00 00		 movsx	 edx, WORD PTR [esi+156]
  00902	52		 push	 edx
  00903	e8 00 00 00 00	 call	 ?NewOptionRand@@YAEH@Z	; NewOptionRand
  00908	83 c4 04	 add	 esp, 4
  0090b	88 45 f0	 mov	 BYTE PTR _NOption$[ebp], al

; 3019 : 			level = 0;

  0090e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0

; 3020 : 		}
; 3021 : 		else

  00915	eb 30		 jmp	 SHORT $LN32@gObjMonste@18
$LN33@gObjMonste@18:

; 3022 : 		{
; 3023 : 			option1rand = gServerInfo.m_Data.iDropItemMonsterRate[3];

  00917	8b 3d 24 01 00
	00		 mov	 edi, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+292

; 3024 : 			option2rand = gServerInfo.m_Data.iDropItemMonsterRate[4];

  0091d	8b 1d 28 01 00
	00		 mov	 ebx, DWORD PTR ?gServerInfo@@3VCServerInfo@@A+296

; 3025 : 			option3rand=rand()%100;

  00923	e8 00 00 00 00	 call	 _rand
  00928	99		 cdq
  00929	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0092e	f7 f9		 idiv	 ecx
  00930	89 55 08	 mov	 DWORD PTR _option3rand$158878[ebp], edx

; 3026 : 			optionc=rand()%3;

  00933	e8 00 00 00 00	 call	 _rand
  00938	99		 cdq
  00939	b9 03 00 00 00	 mov	 ecx, 3
  0093e	f7 f9		 idiv	 ecx

; 3027 : 			NOption = 0;

  00940	c6 45 f0 00	 mov	 BYTE PTR _NOption$[ebp], 0
  00944	89 55 e0	 mov	 DWORD PTR _optionc$158879[ebp], edx
$LN32@gObjMonste@18:

; 3028 : 		}
; 3029 : 
; 3030 : 		if ( (rand()%100) < option1rand )

  00947	e8 00 00 00 00	 call	 _rand
  0094c	99		 cdq
  0094d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00952	f7 f9		 idiv	 ecx
  00954	3b d7		 cmp	 edx, edi
  00956	7d 07		 jge	 SHORT $LN136@gObjMonste@18

; 3031 : 			Option1 = 1;

  00958	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1
$LN136@gObjMonste@18:

; 3032 : 
; 3033 : 		if ( (rand()%100) < option2rand )

  0095f	e8 00 00 00 00	 call	 _rand
  00964	99		 cdq
  00965	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0096a	f7 f9		 idiv	 ecx
  0096c	3b d3		 cmp	 edx, ebx
  0096e	7d 07		 jge	 SHORT $LN137@gObjMonste@18

; 3034 : 			Option2 = 1;

  00970	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN137@gObjMonste@18:

; 3035 : 
; 3036 : 		switch ( optionc )

  00977	8b 45 e0	 mov	 eax, DWORD PTR _optionc$158879[ebp]
  0097a	83 e8 00	 sub	 eax, 0
  0097d	74 1e		 je	 SHORT $LN27@gObjMonste@18
  0097f	48		 dec	 eax
  00980	74 0e		 je	 SHORT $LN25@gObjMonste@18
  00982	48		 dec	 eax
  00983	75 23		 jne	 SHORT $LN138@gObjMonste@18

; 3046 : 			case 2:
; 3047 : 				if ( option3rand < 12 )

  00985	83 7d 08 0c	 cmp	 DWORD PTR _option3rand$158878[ebp], 12 ; 0000000cH
  00989	7d 1d		 jge	 SHORT $LN138@gObjMonste@18

; 3048 : 					Option3=1;

  0098b	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 3049 : 				break;

  0098e	eb 1b		 jmp	 SHORT $LN26@gObjMonste@18
$LN25@gObjMonste@18:

; 3041 : 				break;
; 3042 : 			case 1:
; 3043 : 				if ( option3rand < 8 )

  00990	83 7d 08 08	 cmp	 DWORD PTR _option3rand$158878[ebp], 8
  00994	7d 12		 jge	 SHORT $LN138@gObjMonste@18

; 3044 : 					Option3=2;

  00996	bb 02 00 00 00	 mov	 ebx, 2

; 3045 : 				break;

  0099b	eb 0e		 jmp	 SHORT $LN26@gObjMonste@18
$LN27@gObjMonste@18:

; 3037 : 		{
; 3038 : 			case 0:
; 3039 : 				if ( option3rand < 4 )

  0099d	83 7d 08 04	 cmp	 DWORD PTR _option3rand$158878[ebp], 4

; 3040 : 					Option3=3;

  009a1	bb 03 00 00 00	 mov	 ebx, 3
  009a6	7c 03		 jl	 SHORT $LN26@gObjMonste@18
$LN138@gObjMonste@18:
  009a8	8b 5d d8	 mov	 ebx, DWORD PTR _Option3$[ebp]
$LN26@gObjMonste@18:

; 3050 : 		}
; 3051 : 
; 3052 : 		if ( lpObj->Class == 43 ) // Golden Budge Dragon

  009ab	66 83 be 98 00
	00 00 2b	 cmp	 WORD PTR [esi+152], 43	; 0000002bH
  009b3	75 15		 jne	 SHORT $LN139@gObjMonste@18

; 3053 : 		{
; 3054 : 			Option1 = DropItem->m_Option1;

  009b5	8b 45 ec	 mov	 eax, DWORD PTR _DropItem$[ebp]
  009b8	0f b6 50 78	 movzx	 edx, BYTE PTR [eax+120]

; 3055 : 			Option2 = DropItem->m_Option2;

  009bc	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]

; 3056 : 			Option3 = DropItem->m_Option3;

  009c0	0f b6 58 7a	 movzx	 ebx, BYTE PTR [eax+122]
  009c4	89 55 f4	 mov	 DWORD PTR _Option1$[ebp], edx
  009c7	89 4d f8	 mov	 DWORD PTR _Option2$[ebp], ecx
$LN139@gObjMonste@18:

; 3057 : 		}
; 3058 : 
; 3059 : 		if ( type == ITEMGET(12,15) ||	// Chaos
; 3060 : 			 type == ITEMGET(14,13) ||	// Bless
; 3061 : 			 type == ITEMGET(14,14) ||	// Soul
; 3062 : 			 type == ITEMGET(14,31) ||	// Guardian
; 3063 : 			 type == ITEMGET(14,16))	// Life

  009ca	8b 7d d4	 mov	 edi, DWORD PTR tv1188[ebp]
  009cd	81 ff 0f 18 00
	00		 cmp	 edi, 6159		; 0000180fH
  009d3	74 20		 je	 SHORT $LN19@gObjMonste@18
  009d5	81 ff 0d 1c 00
	00		 cmp	 edi, 7181		; 00001c0dH
  009db	74 18		 je	 SHORT $LN19@gObjMonste@18
  009dd	81 ff 0e 1c 00
	00		 cmp	 edi, 7182		; 00001c0eH
  009e3	74 10		 je	 SHORT $LN19@gObjMonste@18
  009e5	81 ff 1f 1c 00
	00		 cmp	 edi, 7199		; 00001c1fH
  009eb	74 08		 je	 SHORT $LN19@gObjMonste@18
  009ed	81 ff 10 1c 00
	00		 cmp	 edi, 7184		; 00001c10H
  009f3	75 0b		 jne	 SHORT $LN20@gObjMonste@18
$LN19@gObjMonste@18:

; 3064 : 		{
; 3065 : 			Option1=0;

  009f5	33 db		 xor	 ebx, ebx
  009f7	89 5d f4	 mov	 DWORD PTR _Option1$[ebp], ebx

; 3066 : 			Option2=0;

  009fa	89 5d f8	 mov	 DWORD PTR _Option2$[ebp], ebx

; 3067 : 			Option3=0;
; 3068 : 			NOption=0;

  009fd	88 5d f0	 mov	 BYTE PTR _NOption$[ebp], bl
$LN20@gObjMonste@18:

; 3069 : 		}
; 3070 : 
; 3071 : 		int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00a00	56		 push	 esi
  00a01	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 3072 : 
; 3073 : 		if ( DropItem->m_serial )
; 3074 : 		{
; 3075 : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y, type, level, dur,
; 3076 : 				Option1, Option2, Option3, MaxHitUser, NOption, 0);

  00a06	d9 45 e8	 fld	 DWORD PTR _dur$[ebp]
  00a09	8b 55 ec	 mov	 edx, DWORD PTR _DropItem$[ebp]
  00a0c	83 c4 04	 add	 esp, 4
  00a0f	80 7a 04 00	 cmp	 BYTE PTR [edx+4], 0
  00a13	6a 00		 push	 0
  00a15	74 52		 je	 SHORT $LN18@gObjMonste@18
  00a17	8b 4d f0	 mov	 ecx, DWORD PTR _NOption$[ebp]
  00a1a	d9 7d 0a	 fnstcw	 WORD PTR tv1218[ebp]
  00a1d	8b 55 f8	 mov	 edx, DWORD PTR _Option2$[ebp]
  00a20	51		 push	 ecx
  00a21	50		 push	 eax
  00a22	8b 45 f4	 mov	 eax, DWORD PTR _Option1$[ebp]
  00a25	53		 push	 ebx
  00a26	52		 push	 edx
  00a27	50		 push	 eax
  00a28	0f b7 45 0a	 movzx	 eax, WORD PTR tv1218[ebp]
  00a2c	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00a31	89 45 d4	 mov	 DWORD PTR tv1215[ebp], eax
  00a34	8b 45 e4	 mov	 eax, DWORD PTR _level$[ebp]
  00a37	d9 6d d4	 fldcw	 WORD PTR tv1215[ebp]
  00a3a	db 5d d4	 fistp	 DWORD PTR tv1213[ebp]
  00a3d	8a 4d d4	 mov	 cl, BYTE PTR tv1213[ebp]
  00a40	0f b6 d1	 movzx	 edx, cl
  00a43	8b 4d fc	 mov	 ecx, DWORD PTR _y$[ebp]
  00a46	d9 6d 0a	 fldcw	 WORD PTR tv1218[ebp]
  00a49	52		 push	 edx
  00a4a	8b 55 dc	 mov	 edx, DWORD PTR _x$[ebp]
  00a4d	50		 push	 eax
  00a4e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00a55	57		 push	 edi
  00a56	51		 push	 ecx
  00a57	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00a59	52		 push	 edx
  00a5a	50		 push	 eax
  00a5b	51		 push	 ecx
  00a5c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00a61	83 c4 34	 add	 esp, 52			; 00000034H

; 3077 : 		}
; 3078 : 		else

  00a64	e9 90 00 00 00	 jmp	 $LN140@gObjMonste@18
$LN18@gObjMonste@18:

; 3079 : 		{
; 3080 : 			MapC[lpObj->MapNumber].MonsterItemDrop(type, level, dur, x, y, 
; 3081 : 				Option1, Option2, Option3, NOption, 0, MaxHitUser, 0, 0);

  00a69	8b 55 f0	 mov	 edx, DWORD PTR _NOption$[ebp]
  00a6c	8b 4d f4	 mov	 ecx, DWORD PTR _Option1$[ebp]
  00a6f	6a 00		 push	 0
  00a71	50		 push	 eax
  00a72	8b 45 f8	 mov	 eax, DWORD PTR _Option2$[ebp]
  00a75	6a 00		 push	 0
  00a77	52		 push	 edx
  00a78	8b 55 fc	 mov	 edx, DWORD PTR _y$[ebp]
  00a7b	53		 push	 ebx
  00a7c	50		 push	 eax
  00a7d	8b 45 dc	 mov	 eax, DWORD PTR _x$[ebp]
  00a80	51		 push	 ecx
  00a81	52		 push	 edx
  00a82	50		 push	 eax
  00a83	51		 push	 ecx
  00a84	8b 4d e4	 mov	 ecx, DWORD PTR _level$[ebp]
  00a87	d9 1c 24	 fstp	 DWORD PTR [esp]
  00a8a	51		 push	 ecx
  00a8b	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00a92	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00a98	57		 push	 edi
  00a99	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00a9f	e8 00 00 00 00	 call	 ?MonsterItemDrop@MapClass@@QAEHHHMHHEEEEEHKE@Z ; MapClass::MonsterItemDrop

; 3082 : 		}

  00aa4	eb 53		 jmp	 SHORT $LN140@gObjMonste@18
$LN144@gObjMonste@18:

; 3102 : 		{
; 3103 : 			money = MAX_ZEN;

  00aa6	dd d8		 fstp	 ST(0)
$LN12@gObjMonste@18:

; 3104 : 		}
; 3105 : 
; 3106 : 		/*float money = lpObj->Money;
; 3107 : 		money += (money/100.0f)*lpTargetObj->MonsterDieGetMoney;
; 3108 : 		money +=7.0f;*/
; 3109 : 
; 3110 : 		if ( DS_MAP_RANGE(lpObj->MapNumber) )

  00aa8	8a 9e 09 01 00
	00		 mov	 bl, BYTE PTR [esi+265]
  00aae	80 fb 09	 cmp	 bl, 9
  00ab1	74 0c		 je	 SHORT $LN134@gObjMonste@18
  00ab3	33 c0		 xor	 eax, eax
  00ab5	80 fb 20	 cmp	 bl, 32			; 00000020H
  00ab8	0f 94 c0	 sete	 al
  00abb	85 c0		 test	 eax, eax
  00abd	74 1e		 je	 SHORT $LN11@gObjMonste@18
$LN134@gObjMonste@18:

; 3111 : 		{
; 3112 : 			int MaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00abf	56		 push	 esi
  00ac0	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser

; 3113 : 			gObj[MaxHitUser].m_nEventMoney += (int)money;

  00ac5	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00acb	83 c4 04	 add	 esp, 4
  00ace	8d b8 fc 0c 00
	00		 lea	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+3324]
  00ad4	e8 00 00 00 00	 call	 __ftol2_sse
  00ad9	01 07		 add	 DWORD PTR [edi], eax

; 3114 : 		}
; 3115 : 		else

  00adb	eb 1c		 jmp	 SHORT $LN140@gObjMonste@18
$LN11@gObjMonste@18:

; 3116 : 		{
; 3117 : 			MapC[lpObj->MapNumber].MoneyItemDrop(money, x, y);

  00add	57		 push	 edi
  00ade	51		 push	 ecx
  00adf	e8 00 00 00 00	 call	 __ftol2_sse
  00ae4	0f b6 cb	 movzx	 ecx, bl
  00ae7	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00aed	50		 push	 eax
  00aee	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00af4	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
$LN140@gObjMonste@18:

; 3118 : 		}
; 3119 : 	}
; 3120 : 
; 3121 : 	if ( lpObj->Money < 1 )

  00af9	83 be b0 00 00
	00 01		 cmp	 DWORD PTR [esi+176], 1
  00b00	0f 8c fb 00 00
	00		 jl	 $LN91@gObjMonste@18

; 3122 : 		return;
; 3123 : 
; 3124 : 	if ( DS_MAP_RANGE(lpObj->MapNumber) )

  00b06	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  00b0c	3c 09		 cmp	 al, 9
  00b0e	0f 84 ed 00 00
	00		 je	 $LN91@gObjMonste@18
  00b14	33 c9		 xor	 ecx, ecx
  00b16	3c 20		 cmp	 al, 32			; 00000020H
  00b18	0f 94 c1	 sete	 cl
  00b1b	8b c1		 mov	 eax, ecx
  00b1d	85 c0		 test	 eax, eax
  00b1f	0f 85 dc 00 00
	00		 jne	 $LN91@gObjMonste@18

; 3125 : 		return;
; 3126 : 	
; 3127 : 	if ( (rand()%400) == 1 )

  00b25	e8 00 00 00 00	 call	 _rand
  00b2a	99		 cdq
  00b2b	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  00b30	f7 f9		 idiv	 ecx
  00b32	83 fa 01	 cmp	 edx, 1
  00b35	75 61		 jne	 SHORT $LN4@gObjMonste@18

; 3128 : 	{
; 3129 : 		for (int n=0;n<4;n++)

  00b37	c7 45 08 04 00
	00 00		 mov	 DWORD PTR tv709[ebp], 4
  00b3e	8b ff		 npad	 2
$LL6@gObjMonste@18:

; 3130 : 		{
; 3131 : 			int x = lpObj->X-2;

  00b40	0f bf be 04 01
	00 00		 movsx	 edi, WORD PTR [esi+260]

; 3132 : 			int y = lpObj->Y-2;

  00b47	0f bf 9e 06 01
	00 00		 movsx	 ebx, WORD PTR [esi+262]
  00b4e	83 ef 02	 sub	 edi, 2
  00b51	83 eb 02	 sub	 ebx, 2

; 3133 : 			x+= rand()%3;

  00b54	e8 00 00 00 00	 call	 _rand
  00b59	99		 cdq
  00b5a	b9 03 00 00 00	 mov	 ecx, 3
  00b5f	f7 f9		 idiv	 ecx
  00b61	03 fa		 add	 edi, edx

; 3134 : 			y+= rand()%3;

  00b63	e8 00 00 00 00	 call	 _rand
  00b68	99		 cdq
  00b69	b9 03 00 00 00	 mov	 ecx, 3
  00b6e	f7 f9		 idiv	 ecx

; 3135 : 
; 3136 : 			MapC[lpObj->MapNumber].MoneyItemDrop(lpObj->Money, x, y);

  00b70	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  00b77	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00b7d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00b83	03 da		 add	 ebx, edx
  00b85	8b 96 b0 00 00
	00		 mov	 edx, DWORD PTR [esi+176]
  00b8b	53		 push	 ebx
  00b8c	57		 push	 edi
  00b8d	52		 push	 edx
  00b8e	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop
  00b93	ff 4d 08	 dec	 DWORD PTR tv709[ebp]
  00b96	75 a8		 jne	 SHORT $LL6@gObjMonste@18
$LN4@gObjMonste@18:

; 3137 : 		}
; 3138 : 	}
; 3139 : 
; 3140 : 	if ( gEvent1ItemDropTodayPercent > 0 )

  00b98	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gEvent1ItemDropTodayPercent@@3HA, 0 ; gEvent1ItemDropTodayPercent
  00b9f	7e 60		 jle	 SHORT $LN91@gObjMonste@18

; 3141 : 	{
; 3142 : 		if ( (rand()%gEvent1ItemDropTodayPercent) == 0 )

  00ba1	e8 00 00 00 00	 call	 _rand
  00ba6	99		 cdq
  00ba7	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?gEvent1ItemDropTodayPercent@@3HA ; gEvent1ItemDropTodayPercent
  00bad	85 d2		 test	 edx, edx
  00baf	75 50		 jne	 SHORT $LN91@gObjMonste@18

; 3143 : 		{
; 3144 : 			if ( gEvent1ItemDropTodayCount < gEvent1ItemDropTodayMax )

  00bb1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gEvent1ItemDropTodayCount@@3HA ; gEvent1ItemDropTodayCount
  00bb6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gEvent1ItemDropTodayMax@@3HA ; gEvent1ItemDropTodayMax
  00bbc	7d 43		 jge	 SHORT $LN91@gObjMonste@18

; 3145 : 			{
; 3146 : 				gEvent1ItemDropTodayCount++;

  00bbe	ff 05 00 00 00
	00		 inc	 DWORD PTR ?gEvent1ItemDropTodayCount@@3HA ; gEvent1ItemDropTodayCount

; 3147 : 				type = ItemGetNumberMake(14, 12);	// Heart

  00bc4	6a 0c		 push	 12			; 0000000cH
  00bc6	6a 0e		 push	 14			; 0000000eH
  00bc8	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake

; 3148 : 				dur = 0;
; 3149 : 				x = lpObj->X;
; 3150 : 				y = lpObj->Y;
; 3151 : 				level = 1;
; 3152 : 				ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, x, y,
; 3153 : 					type, level, dur, 0, 0, 0, -1, 0, 0);

  00bcd	0f b6 8e 06 01
	00 00		 movzx	 ecx, BYTE PTR [esi+262]
  00bd4	0f b6 96 04 01
	00 00		 movzx	 edx, BYTE PTR [esi+260]
  00bdb	6a 00		 push	 0
  00bdd	6a 00		 push	 0
  00bdf	6a ff		 push	 -1
  00be1	6a 00		 push	 0
  00be3	6a 00		 push	 0
  00be5	6a 00		 push	 0
  00be7	6a 00		 push	 0
  00be9	6a 01		 push	 1
  00beb	50		 push	 eax
  00bec	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00bf3	51		 push	 ecx
  00bf4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00bf6	52		 push	 edx
  00bf7	50		 push	 eax
  00bf8	51		 push	 ecx
  00bf9	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEE@Z ; ItemSerialCreateSend
  00bfe	83 c4 3c	 add	 esp, 60			; 0000003cH
$LN91@gObjMonste@18:
  00c01	5f		 pop	 edi
  00c02	5e		 pop	 esi
  00c03	5b		 pop	 ebx

; 3154 : 			}
; 3155 : 		}
; 3156 : 	}
; 3157 : 
; 3158 : }

  00c04	8b e5		 mov	 esp, ebp
  00c06	5d		 pop	 ebp
  00c07	c3		 ret	 0
?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z ENDP	; gObjMonsterDieGiveItem
_TEXT	ENDS
PUBLIC	??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5B@ ; `string'
PUBLIC	??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5M@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ; gObjMonsterStateProc
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z:PROC	; GCStateInfoSend
EXTRN	?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; retResistance
EXTRN	?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z:PROC	; gObjBackSpring2
EXTRN	?gObjMemFree@@YAFH@Z:PROC			; gObjMemFree
EXTRN	?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjBackSpring
EXTRN	?SetSaintStatue@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::SetSaintStatue
EXTRN	?CheckBossKillCount@CBloodCastle@@QAE_NH@Z:PROC	; CBloodCastle::CheckBossKillCount
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z:PROC ; CBloodCastle::GetCurrentLiveUserCount
EXTRN	?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::ReleaseCastleBridge
EXTRN	?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z:PROC ; CBloodCastle::SendBridgeAnyMsg
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z:PROC ; CBloodCastle::CheckMonsterKillCount
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?gObjMonsterCallKill@@YAXH@Z:PROC		; gObjMonsterCallKill
EXTRN	?CreateKalimaGate2@CKalimaGate@@QAEHHHEE@Z:PROC	; CKalimaGate::CreateKalimaGate2
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	?CheckWall2@MapClass@@QAEEHHHH@Z:PROC		; MapClass::CheckWall2
;	COMDAT ??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5B@
CONST	SEGMENT
??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5B@ DB '['
	DB	'Blood Castle] (%d) All of the Boss Monster Terminated -> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5M@
CONST	SEGMENT
??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5M@ DB '['
	DB	'Blood Castle] (%d) All of the Monster Terminated -> %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
tv1047 = -28						; size = 4
_EnemyMap$158126 = -28					; size = 4
_map$158100 = -28					; size = 4
tv1251 = -24						; size = 4
tv1070 = -24						; size = 4
tv1003 = -24						; size = 4
_pMsg$158149 = -20					; size = 14
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_aMsgSubCode$ = 20					; size = 4
?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z PROC	; gObjMonsterStateProc, COMDAT

; 737  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 738  : 	if ( lpObj->m_iMonsterBattleDelay > 0 )

  00014	80 be 2b 02 00
	00 00		 cmp	 BYTE PTR [esi+555], 0
  0001b	57		 push	 edi
  0001c	8b 7d 10	 mov	 edi, DWORD PTR _aIndex$[ebp]
  0001f	0f 8f ab 01 00
	00		 jg	 $LN72@gObjMonste@19

; 739  : 	{
; 740  : 		return;
; 741  : 	}
; 742  : 
; 743  : 	switch ( aMsgCode )

  00025	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00028	83 f8 39	 cmp	 eax, 57			; 00000039H
  0002b	0f 87 9f 01 00
	00		 ja	 $LN72@gObjMonste@19
  00031	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN91@gObjMonste@19[eax]
  00038	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN99@gObjMonste@19[eax*4]
$LN71@gObjMonste@19:

; 744  : 	{
; 745  : 		case 0:
; 746  : 
; 747  : 			if ( lpObj->m_Attribute == 0 )

  0003f	66 83 be 26 03
	00 00 00	 cmp	 WORD PTR [esi+806], 0
  00047	0f 84 83 01 00
	00		 je	 $LN72@gObjMonste@19

; 748  : 			{
; 749  : 				return;
; 750  : 			}
; 751  : 			
; 752  : 			if ( gObj[aIndex].Live == FALSE || gObj[aIndex].m_State != 2)

  0004d	53		 push	 ebx
  0004e	8b df		 mov	 ebx, edi
  00050	69 db 64 15 00
	00		 imul	 ebx, 5476		; 00001564H
  00056	80 bb 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+98], 0
  0005d	0f 84 6c 01 00
	00		 je	 $LN92@gObjMonste@19
  00063	83 bb bc 01 00
	00 02		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+444], 2
  0006a	0f 85 5f 01 00
	00		 jne	 $LN92@gObjMonste@19

; 753  : 			{
; 754  : 				return;
; 755  : 			}
; 756  : 
; 757  : 			if ( lpObj->m_ActState.Emotion == 0 )

  00070	8b 8e b4 01 00
	00		 mov	 ecx, DWORD PTR [esi+436]
  00076	8b c1		 mov	 eax, ecx
  00078	c1 e8 04	 shr	 eax, 4
  0007b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0007e	75 11		 jne	 SHORT $LN67@gObjMonste@19

; 758  : 			{
; 759  : 				lpObj->m_ActState.Emotion = 1;

  00080	81 e1 1f ff ff
	ff		 and	 ecx, -225		; ffffff1fH
  00086	83 c9 10	 or	 ecx, 16			; 00000010H
  00089	89 8e b4 01 00
	00		 mov	 DWORD PTR [esi+436], ecx

; 760  : 				lpObj->m_ActState.EmotionCount = 10;

  0008f	eb 05		 jmp	 SHORT $LN94@gObjMonste@19
$LN67@gObjMonste@19:

; 761  : 			}
; 762  : 			else if ( lpObj->m_ActState.Emotion == 1 )

  00091	83 f8 01	 cmp	 eax, 1
  00094	75 07		 jne	 SHORT $LN65@gObjMonste@19
$LN94@gObjMonste@19:

; 763  : 			{
; 764  : 				lpObj->m_ActState.EmotionCount = 10;

  00096	c6 86 b5 01 00
	00 0a		 mov	 BYTE PTR [esi+437], 10	; 0000000aH
$LN65@gObjMonste@19:

; 765  : 			}
; 766  : 
; 767  : 			if ( lpObj->m_ActState.Attack == 0 && lpObj->PathStartEnd == 0)

  0009d	f6 86 b4 01 00
	00 02		 test	 BYTE PTR [esi+436], 2
  000a4	0f 85 36 01 00
	00		 jne	 $LN64@gObjMonste@19
  000aa	80 be 30 01 00
	00 00		 cmp	 BYTE PTR [esi+304], 0
  000b1	0f 85 29 01 00
	00		 jne	 $LN64@gObjMonste@19

; 768  : 			{
; 769  : 				if ( OBJMAX_RANGE(aIndex) )

  000b7	85 ff		 test	 edi, edi
  000b9	0f 88 10 01 00
	00		 js	 $LN92@gObjMonste@19
  000bf	33 c0		 xor	 eax, eax
  000c1	81 ff e7 1c 00
	00		 cmp	 edi, 7399		; 00001ce7H
  000c7	0f 9e c0	 setle	 al
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 fd 00 00
	00		 je	 $LN92@gObjMonste@19

; 770  : 				{
; 771  : 					int map = gObj[aIndex].MapNumber;

  000d2	0f b6 8b 09 01
	00 00		 movzx	 ecx, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+265]

; 772  : 					BYTE attr;
; 773  : 					int dis = gObjCalDistance(lpObj, &gObj[aIndex]);

  000d9	8d 83 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  000df	50		 push	 eax
  000e0	56		 push	 esi
  000e1	89 4d e4	 mov	 DWORD PTR _map$158100[ebp], ecx
  000e4	89 45 e8	 mov	 DWORD PTR tv1003[ebp], eax
  000e7	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance

; 774  : 					int range;
; 775  : 
; 776  : 					if ( lpObj->m_AttackType >= 100 )
; 777  : 					{
; 778  : 						range = lpObj->m_AttackRange +2;

  000ec	0f bf 8e 20 03
	00 00		 movsx	 ecx, WORD PTR [esi+800]
  000f3	83 c4 08	 add	 esp, 8
  000f6	66 83 be 22 03
	00 00 64	 cmp	 WORD PTR [esi+802], 100	; 00000064H
  000fe	7c 03		 jl	 SHORT $LN61@gObjMonste@19
  00100	83 c1 02	 add	 ecx, 2
$LN61@gObjMonste@19:

; 779  : 					}
; 780  : 					else
; 781  : 					{
; 782  : 						range = lpObj->m_AttackRange;
; 783  : 					}
; 784  : 
; 785  : 					if ( dis <= range )

  00103	3b c1		 cmp	 eax, ecx
  00105	7f 36		 jg	 SHORT $LN60@gObjMonste@19

; 786  : 					{
; 787  : 						if ( gObj[aIndex].m_RecallMon >= 0 )

  00107	83 bb cc 02 00
	00 00		 cmp	 DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+716], 0
  0010e	7c 19		 jl	 SHORT $LN59@gObjMonste@19
$LN96@gObjMonste@19:

; 788  : 						{
; 789  : 							if ( lpObj->m_RecallMon >= 0 )

  00110	83 be cc 02 00
	00 00		 cmp	 DWORD PTR [esi+716], 0
  00117	0f 8c 81 00 00
	00		 jl	 $LN95@gObjMonste@19

; 790  : 							{
; 791  : 								if ( gObj[aIndex].Type == OBJ_MONSTER )

  0011d	66 83 bb 60 00
	00 00 02	 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+96], 2
  00125	75 7e		 jne	 SHORT $LN47@gObjMonste@19

; 792  : 								{
; 793  : 									lpObj->TargetNumber = aIndex;
; 794  : 								}
; 795  : 							}
; 796  : 							else

  00127	eb 75		 jmp	 SHORT $LN95@gObjMonste@19
$LN59@gObjMonste@19:

; 797  : 							{
; 798  : 								lpObj->TargetNumber = aIndex;
; 799  : 							}
; 800  : 						}
; 801  : 						else if ( (rand()%100) < 90 )

  00129	e8 00 00 00 00	 call	 _rand
  0012e	99		 cdq
  0012f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00134	f7 f9		 idiv	 ecx
  00136	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  00139	7d 6a		 jge	 SHORT $LN47@gObjMonste@19

; 802  : 						{
; 803  : 							if ( lpObj->m_RecallMon >= 0 )
; 804  : 							{
; 805  : 								if ( gObj[aIndex].Type == OBJ_MONSTER )
; 806  : 								{
; 807  : 									lpObj->TargetNumber = aIndex;
; 808  : 								}
; 809  : 							}
; 810  : 							else

  0013b	eb d3		 jmp	 SHORT $LN96@gObjMonste@19
$LN60@gObjMonste@19:

; 811  : 							{
; 812  : 								lpObj->TargetNumber = aIndex;
; 813  : 							}
; 814  : 						}
; 815  : 					}
; 816  : 					else
; 817  : 					{
; 818  : 						BYTE wall = 0;
; 819  : 
; 820  : 						wall = MapC[map].CheckWall2(lpObj->X, lpObj->Y, gObj[aIndex].X, gObj[aIndex].Y);

  0013d	8b 45 e4	 mov	 eax, DWORD PTR _map$158100[ebp]

; 821  : 
; 822  : 						if ( wall == 1 )

  00140	0f bf 93 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  00147	69 c0 08 07 05
	00		 imul	 eax, 329480		; 00050708H
  0014d	8d 88 00 00 00
	00		 lea	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A[eax]
  00153	0f bf 83 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  0015a	52		 push	 edx
  0015b	0f bf 96 06 01
	00 00		 movsx	 edx, WORD PTR [esi+262]
  00162	50		 push	 eax
  00163	0f bf 86 04 01
	00 00		 movsx	 eax, WORD PTR [esi+260]
  0016a	52		 push	 edx
  0016b	50		 push	 eax
  0016c	89 4d e4	 mov	 DWORD PTR tv1047[ebp], ecx
  0016f	e8 00 00 00 00	 call	 ?CheckWall2@MapClass@@QAEEHHHH@Z ; MapClass::CheckWall2
  00174	3c 01		 cmp	 al, 1
  00176	75 2d		 jne	 SHORT $LN47@gObjMonste@19

; 823  : 						{
; 824  : 							attr = MapC[map].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);
; 825  : 
; 826  : 							if ( (attr&1) != 1 )

  00178	0f bf 8b 06 01
	00 00		 movsx	 ecx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+262]
  0017f	0f bf 93 04 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx+260]
  00186	51		 push	 ecx
  00187	8b 4d e4	 mov	 ecx, DWORD PTR tv1047[ebp]
  0018a	52		 push	 edx
  0018b	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00190	a8 01		 test	 al, 1
  00192	75 11		 jne	 SHORT $LN47@gObjMonste@19

; 827  : 							{
; 828  : 								if ( lpObj->TargetNumber < 0 )

  00194	66 83 be d4 02
	00 00 00	 cmp	 WORD PTR [esi+724], 0
  0019c	7d 07		 jge	 SHORT $LN47@gObjMonste@19
$LN95@gObjMonste@19:

; 829  : 								{
; 830  : 									lpObj->TargetNumber = aIndex;

  0019e	66 89 be d4 02
	00 00		 mov	 WORD PTR [esi+724], di
$LN47@gObjMonste@19:

; 831  : 								}
; 832  : 							}
; 833  : 						}
; 834  : 					}
; 835  : 
; 836  : 
; 837  : 					if ( lpObj->m_bIsInMonsterHerd != false && lpObj->TargetNumber == aIndex )

  001a5	83 be 24 0f 00
	00 00		 cmp	 DWORD PTR [esi+3876], 0
  001ac	74 21		 je	 SHORT $LN92@gObjMonste@19
  001ae	0f bf 86 d4 02
	00 00		 movsx	 eax, WORD PTR [esi+724]
  001b5	3b c7		 cmp	 eax, edi
  001b7	75 16		 jne	 SHORT $LN92@gObjMonste@19

; 838  : 					{
; 839  : 						if ( lpObj->m_lpMonsterHerd )

  001b9	8b 8e 2c 0f 00
	00		 mov	 ecx, DWORD PTR [esi+3884]
  001bf	85 c9		 test	 ecx, ecx
  001c1	74 0c		 je	 SHORT $LN92@gObjMonste@19

; 840  : 						{
; 841  : 							lpObj->m_lpMonsterHerd->BeenAttacked (lpObj, &gObj[aIndex]);

  001c3	8b 45 e8	 mov	 eax, DWORD PTR tv1003[ebp]
  001c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c8	8b 52 38	 mov	 edx, DWORD PTR [edx+56]
  001cb	50		 push	 eax
  001cc	56		 push	 esi
  001cd	ff d2		 call	 edx
$LN92@gObjMonste@19:
  001cf	5b		 pop	 ebx
$LN72@gObjMonste@19:
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  001d2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c3		 ret	 0
$LN64@gObjMonste@19:

; 842  : 						}
; 843  : 					}
; 844  : 				}
; 845  : 			}
; 846  : 			else
; 847  : 			{
; 848  : 				if ( (rand() % 2 )== 1 && lpObj->PathStartEnd == 0)

  001e0	e8 00 00 00 00	 call	 _rand
  001e5	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  001ea	79 05		 jns	 SHORT $LN93@gObjMonste@19
  001ec	48		 dec	 eax
  001ed	83 c8 fe	 or	 eax, -2			; fffffffeH
  001f0	40		 inc	 eax
$LN93@gObjMonste@19:
  001f1	83 f8 01	 cmp	 eax, 1
  001f4	0f 85 ad 00 00
	00		 jne	 $LN43@gObjMonste@19
  001fa	80 be 30 01 00
	00 00		 cmp	 BYTE PTR [esi+304], 0
  00201	0f 85 a0 00 00
	00		 jne	 $LN43@gObjMonste@19

; 849  : 				{
; 850  : 					int IndexEnemy = lpObj->TargetNumber;

  00207	0f bf 86 d4 02
	00 00		 movsx	 eax, WORD PTR [esi+724]

; 851  : 					int EnemyMap = gObj[IndexEnemy].MapNumber;

  0020e	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00214	89 45 e8	 mov	 DWORD PTR tv1070[ebp], eax
  00217	0f b6 80 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]

; 852  : 
; 853  : 					int enemydis = gObjCalDistance(lpObj, &gObj[aIndex]);

  0021e	8d 8b 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[ebx]
  00224	51		 push	 ecx
  00225	56		 push	 esi
  00226	89 45 e4	 mov	 DWORD PTR _EnemyMap$158126[ebp], eax
  00229	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance

; 854  : 					int range;
; 855  : 
; 856  : 					if ( lpObj->m_AttackType >= 100 )
; 857  : 					{
; 858  : 						range = lpObj->m_AttackRange + 2;

  0022e	0f bf 8e 20 03
	00 00		 movsx	 ecx, WORD PTR [esi+800]
  00235	83 c4 08	 add	 esp, 8
  00238	66 83 be 22 03
	00 00 64	 cmp	 WORD PTR [esi+802], 100	; 00000064H
  00240	7c 03		 jl	 SHORT $LN41@gObjMonste@19
  00242	83 c1 02	 add	 ecx, 2
$LN41@gObjMonste@19:

; 859  : 					}
; 860  : 					else
; 861  : 					{
; 862  : 						range = lpObj->m_AttackRange;
; 863  : 					}
; 864  : 
; 865  : 					if ( enemydis <= range )

  00245	3b c1		 cmp	 eax, ecx

; 866  : 					{
; 867  : 						lpObj->m_ActState.Attack = 1;
; 868  : 						lpObj->TargetNumber = aIndex;
; 869  : 					}
; 870  : 					else

  00247	7e 3f		 jle	 SHORT $LN98@gObjMonste@19

; 871  : 					{
; 872  : 						if ( MapC[EnemyMap].CheckWall2(lpObj->X, lpObj->Y, gObj[IndexEnemy].X, gObj[IndexEnemy].Y) == 1 )

  00249	8b 45 e8	 mov	 eax, DWORD PTR tv1070[ebp]
  0024c	0f bf 90 06 01
	00 00		 movsx	 edx, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+262]
  00253	0f bf 80 04 01
	00 00		 movsx	 eax, WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+260]
  0025a	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  00261	52		 push	 edx
  00262	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00269	50		 push	 eax
  0026a	51		 push	 ecx
  0026b	8b 4d e4	 mov	 ecx, DWORD PTR _EnemyMap$158126[ebp]
  0026e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00274	52		 push	 edx
  00275	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0027b	e8 00 00 00 00	 call	 ?CheckWall2@MapClass@@QAEEHHHH@Z ; MapClass::CheckWall2
  00280	3c 01		 cmp	 al, 1
  00282	0f 85 47 ff ff
	ff		 jne	 $LN92@gObjMonste@19
$LN98@gObjMonste@19:

; 873  : 						{
; 874  : 							lpObj->m_ActState.Attack = 1;

  00288	83 8e b4 01 00
	00 02		 or	 DWORD PTR [esi+436], 2
  0028f	5b		 pop	 ebx

; 875  : 							lpObj->TargetNumber = aIndex;

  00290	66 89 be d4 02
	00 00		 mov	 WORD PTR [esi+724], di
  00297	5f		 pop	 edi
  00298	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  00299	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029c	33 cd		 xor	 ecx, ebp
  0029e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a3	8b e5		 mov	 esp, ebp
  002a5	5d		 pop	 ebp
  002a6	c3		 ret	 0
$LN43@gObjMonste@19:

; 876  : 						}
; 877  : 					}
; 878  : 				}
; 879  : 				else
; 880  : 				{
; 881  : 					int MaxLife = lpObj->MaxLife;
; 882  : 					MaxLife >>= 1;
; 883  : 
; 884  : 					if ( MaxLife > lpObj->Life )

  002a7	d9 86 c0 00 00
	00		 fld	 DWORD PTR [esi+192]
  002ad	e8 00 00 00 00	 call	 __ftol2_sse
  002b2	d1 f8		 sar	 eax, 1
  002b4	89 45 e8	 mov	 DWORD PTR tv1251[ebp], eax
  002b7	db 45 e8	 fild	 DWORD PTR tv1251[ebp]
  002ba	d9 86 bc 00 00
	00		 fld	 DWORD PTR [esi+188]
  002c0	de d9		 fcompp
  002c2	df e0		 fnstsw	 ax
  002c4	f6 c4 05	 test	 ah, 5
  002c7	0f 8a 02 ff ff
	ff		 jp	 $LN92@gObjMonste@19

; 885  : 					{
; 886  : 						if ( lpObj->m_Attribute != 2 )

  002cd	66 83 be 26 03
	00 00 02	 cmp	 WORD PTR [esi+806], 2
  002d5	0f 84 f4 fe ff
	ff		 je	 $LN92@gObjMonste@19

; 887  : 						{
; 888  : 							lpObj->m_ActState.Emotion = 2;

  002db	8b 86 b4 01 00
	00		 mov	 eax, DWORD PTR [esi+436]
  002e1	25 2f ff ff ff	 and	 eax, -209		; ffffff2fH
  002e6	5b		 pop	 ebx
  002e7	83 c8 20	 or	 eax, 32			; 00000020H
  002ea	89 86 b4 01 00
	00		 mov	 DWORD PTR [esi+436], eax
  002f0	5f		 pop	 edi

; 889  : 							lpObj->m_ActState.EmotionCount = 2;

  002f1	c6 86 b5 01 00
	00 02		 mov	 BYTE PTR [esi+437], 2
  002f8	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  002f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002fc	33 cd		 xor	 ecx, ebp
  002fe	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00303	8b e5		 mov	 esp, ebp
  00305	5d		 pop	 ebp
  00306	c3		 ret	 0
$LN34@gObjMonste@19:

; 890  : 						}
; 891  : 					}
; 892  : 				}
; 893  : 			}
; 894  : 			break;
; 895  : 		case 1:
; 896  : #if ( GS_CASTLE == 1 )
; 897  : 			if ( lpObj->m_btCsNpcType )
; 898  : 			{
; 899  : 				switch ( lpObj->m_btCsNpcType )
; 900  : 				{
; 901  : 					case 1:	g_CastleSiege.DelNPC(lpObj->m_Index, lpObj->Class, lpObj->m_iCsNpcExistVal, TRUE);	break;
; 902  : 					case 2:	g_CastleSiege.DelNPC(lpObj->m_Index, lpObj->Class, lpObj->m_iCsNpcExistVal, FALSE);break;
; 903  : 					case 3:	g_CastleSiege.DelNPC(lpObj->m_Index, lpObj->Class, lpObj->m_iCsNpcExistVal, FALSE);	break;
; 904  : 				}
; 905  : 
; 906  : 				if ( lpObj->Class == 287 || lpObj->Class == 286 )
; 907  : 					g_CsNPC_Mercenary.DeleteMercenary(lpObj->m_Index);
; 908  : 
; 909  : 				if ( lpObj->Class == 278 )
; 910  : 					g_CsNPC_LifeStone.DeleteLifeStone(lpObj->m_Index);
; 911  : 
; 912  : 				gObjDel(lpObj->m_Index);
; 913  : 			}
; 914  : #endif
; 915  : 
; 916  : 			if ( KALIMA_MAP_RANGE(lpObj->MapNumber)  )

  00307	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  0030d	80 f9 18	 cmp	 cl, 24			; 00000018H
  00310	72 69		 jb	 SHORT $LN32@gObjMonste@19
  00312	80 f9 1d	 cmp	 cl, 29			; 0000001dH
  00315	76 0c		 jbe	 SHORT $LN89@gObjMonste@19
  00317	33 c0		 xor	 eax, eax
  00319	80 f9 24	 cmp	 cl, 36			; 00000024H
  0031c	0f 94 c0	 sete	 al
  0031f	85 c0		 test	 eax, eax
  00321	74 58		 je	 SHORT $LN32@gObjMonste@19
$LN89@gObjMonste@19:

; 917  : 			{
; 918  : 				if ( lpObj->Class == 161 || lpObj->Class == 181 || lpObj->Class == 189 || lpObj->Class == 197 || lpObj->Class == 267 )

  00323	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0032a	ba a1 00 00 00	 mov	 edx, 161		; 000000a1H
  0032f	66 3b c2	 cmp	 ax, dx
  00332	74 28		 je	 SHORT $LN31@gObjMonste@19
  00334	ba b5 00 00 00	 mov	 edx, 181		; 000000b5H
  00339	66 3b c2	 cmp	 ax, dx
  0033c	74 1e		 je	 SHORT $LN31@gObjMonste@19
  0033e	ba bd 00 00 00	 mov	 edx, 189		; 000000bdH
  00343	66 3b c2	 cmp	 ax, dx
  00346	74 14		 je	 SHORT $LN31@gObjMonste@19
  00348	ba c5 00 00 00	 mov	 edx, 197		; 000000c5H
  0034d	66 3b c2	 cmp	 ax, dx
  00350	74 0a		 je	 SHORT $LN31@gObjMonste@19
  00352	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  00357	66 3b c2	 cmp	 ax, dx
  0035a	75 1f		 jne	 SHORT $LN32@gObjMonste@19
$LN31@gObjMonste@19:

; 919  : 				{
; 920  : 					g_KalimaGate.CreateKalimaGate2(aIndex, lpObj->MapNumber, lpObj->X, lpObj->Y);

  0035c	0f b6 86 06 01
	00 00		 movzx	 eax, BYTE PTR [esi+262]
  00363	0f b6 96 04 01
	00 00		 movzx	 edx, BYTE PTR [esi+260]
  0036a	50		 push	 eax
  0036b	0f b6 c1	 movzx	 eax, cl
  0036e	52		 push	 edx
  0036f	50		 push	 eax
  00370	57		 push	 edi
  00371	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00376	e8 00 00 00 00	 call	 ?CreateKalimaGate2@CKalimaGate@@QAEHHHEE@Z ; CKalimaGate::CreateKalimaGate2
$LN32@gObjMonste@19:

; 921  : 				}
; 922  : 			}
; 923  : 
; 924  : 			gObjMonsterDieGiveItem(lpObj, &gObj[aIndex] );

  0037b	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  00381	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00387	57		 push	 edi
  00388	56		 push	 esi
  00389	e8 00 00 00 00	 call	 ?gObjMonsterDieGiveItem@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterDieGiveItem

; 925  : 			lpObj->NextActionTime = 500;
; 926  : 
; 927  : 			if ( lpObj->m_RecallMon >= 0 )

  0038e	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR [esi+716]
  00394	83 c4 08	 add	 esp, 8
  00397	c7 86 1c 02 00
	00 f4 01 00 00	 mov	 DWORD PTR [esi+540], 500 ; 000001f4H
  003a1	85 c0		 test	 eax, eax
  003a3	78 09		 js	 SHORT $LN30@gObjMonste@19

; 928  : 			{
; 929  : 				gObjMonsterCallKill(lpObj->m_RecallMon);

  003a5	50		 push	 eax
  003a6	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  003ab	83 c4 04	 add	 esp, 4
$LN30@gObjMonste@19:

; 930  : 			}
; 931  : 
; 932  : 			if (  BC_MAP_RANGE(lpObj->MapNumber) != FALSE && lpObj->Type >= OBJ_MONSTER)

  003ae	8a 86 09 01 00
	00		 mov	 al, BYTE PTR [esi+265]
  003b4	3c 0b		 cmp	 al, 11			; 0000000bH
  003b6	0f 82 14 fe ff
	ff		 jb	 $LN72@gObjMonste@19
  003bc	b9 11 00 00 00	 mov	 ecx, 17			; 00000011H
  003c1	3a c8		 cmp	 cl, al
  003c3	1b c9		 sbb	 ecx, ecx
  003c5	41		 inc	 ecx
  003c6	0f 84 04 fe ff
	ff		 je	 $LN72@gObjMonste@19
  003cc	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  003d1	0f 82 f9 fd ff
	ff		 jb	 $LN72@gObjMonste@19

; 933  : 			{
; 934  : 				if ( lpObj->Class == 89 || lpObj->Class == 95 || lpObj->Class == 112 || lpObj->Class == 118 || lpObj->Class == 124 || lpObj->Class == 130 || lpObj->Class == 143)

  003d7	0f b7 8e 98 00
	00 00		 movzx	 ecx, WORD PTR [esi+152]
  003de	83 f9 59	 cmp	 ecx, 89			; 00000059H
  003e1	74 39		 je	 SHORT $LN27@gObjMonste@19
  003e3	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  003e6	74 34		 je	 SHORT $LN27@gObjMonste@19
  003e8	83 f9 70	 cmp	 ecx, 112		; 00000070H
  003eb	74 2f		 je	 SHORT $LN27@gObjMonste@19
  003ed	83 f9 76	 cmp	 ecx, 118		; 00000076H
  003f0	74 2a		 je	 SHORT $LN27@gObjMonste@19
  003f2	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  003f5	74 25		 je	 SHORT $LN27@gObjMonste@19
  003f7	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  003fc	66 3b ca	 cmp	 cx, dx
  003ff	74 1b		 je	 SHORT $LN27@gObjMonste@19
  00401	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  00406	66 3b ca	 cmp	 cx, dx
  00409	74 11		 je	 SHORT $LN27@gObjMonste@19

; 937  : 				}
; 938  : 				else
; 939  : 				{
; 940  : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_KILL_COUNT++;

  0040b	0f b6 c0	 movzx	 eax, al
  0040e	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00411	c1 e0 09	 shl	 eax, 9
  00414	8d 80 78 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+376]
  0041a	eb 0f		 jmp	 SHORT $LN97@gObjMonste@19
$LN27@gObjMonste@19:

; 935  : 				{
; 936  : 					g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT++;

  0041c	0f b6 c0	 movzx	 eax, al
  0041f	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00422	c1 e0 09	 shl	 eax, 9
  00425	8d 80 88 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+392]
$LN97@gObjMonste@19:
  0042b	ff 00		 inc	 DWORD PTR [eax]

; 941  : 				}
; 942  : 
; 943  : 				if ( g_BloodCastle.CheckMonsterKillCount(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1) != false )

  0042d	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00434	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00437	50		 push	 eax
  00438	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0043d	e8 00 00 00 00	 call	 ?CheckMonsterKillCount@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckMonsterKillCount
  00442	84 c0		 test	 al, al
  00444	0f 84 80 01 00
	00		 je	 $LN22@gObjMonste@19

; 944  : 				{
; 945  : 					if (g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_bBC_MONSTER_KILL_COMPLETE == false )

  0044a	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00451	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00454	c1 e0 09	 shl	 eax, 9
  00457	80 b8 60 01 00
	00 00		 cmp	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+352], 0
  0045e	8d 80 60 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+352]
  00464	0f 85 1a 01 00
	00		 jne	 $LN23@gObjMonste@19

; 946  : 					{
; 947  : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_bBC_MONSTER_KILL_COMPLETE = true;

  0046a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 948  : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_MAX_COUNT = -1;

  0046d	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]

; 949  : 
; 950  : 						PMSG_STATEBLOODCASTLE pMsg;
; 951  : 
; 952  : 						PHeadSetB((LPBYTE)&pMsg, 0x9B, sizeof(PMSG_STATEBLOODCASTLE));

  00474	6a 0e		 push	 14			; 0000000eH
  00476	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00479	8d 55 ec	 lea	 edx, DWORD PTR _pMsg$158149[ebp]
  0047c	c1 e1 09	 shl	 ecx, 9
  0047f	68 9b 00 00 00	 push	 155			; 0000009bH
  00484	52		 push	 edx
  00485	c7 81 74 01 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+372], -1
  0048f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 953  : 
; 954  : 						pMsg.btPlayState = BC_STATE_PLAYEND;
; 955  : 						pMsg.wRemainSec = 0;
; 956  : 						pMsg.wMaxKillMonster = 0;
; 957  : 						pMsg.wCurKillMonster = 0;
; 958  : 						pMsg.wUserHaveWeapon = 0;
; 959  : 						pMsg.btWeaponNum = -1;
; 960  : 
; 961  : 						g_BloodCastle.SendBridgeAnyMsg( (UCHAR *)&pMsg, pMsg.h.size, lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1);

  00494	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0049b	33 d2		 xor	 edx, edx
  0049d	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a0	89 55 f4	 mov	 DWORD PTR _pMsg$158149[ebp+8], edx
  004a3	0f b6 55 ed	 movzx	 edx, BYTE PTR _pMsg$158149[ebp+1]
  004a7	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  004aa	33 c0		 xor	 eax, eax
  004ac	51		 push	 ecx
  004ad	89 45 f0	 mov	 DWORD PTR _pMsg$158149[ebp+4], eax
  004b0	52		 push	 edx
  004b1	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$158149[ebp]
  004b4	50		 push	 eax
  004b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004ba	c6 45 ef 03	 mov	 BYTE PTR _pMsg$158149[ebp+3], 3
  004be	c6 45 f8 ff	 mov	 BYTE PTR _pMsg$158149[ebp+12], 255 ; 000000ffH
  004c2	e8 00 00 00 00	 call	 ?SendBridgeAnyMsg@CBloodCastle@@QAEXPAEHH@Z ; CBloodCastle::SendBridgeAnyMsg

; 962  : 						g_BloodCastle.ReleaseCastleBridge(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1);

  004c7	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  004ce	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  004d1	51		 push	 ecx
  004d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004d7	e8 00 00 00 00	 call	 ?ReleaseCastleBridge@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleBridge

; 963  : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_dwBC_TICK_DOOR_OPEN = GetTickCount() + 3000;

  004dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004e2	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  004e9	83 ea 0b	 sub	 edx, 11			; 0000000bH
  004ec	05 b8 0b 00 00	 add	 eax, 3000		; 00000bb8H
  004f1	c1 e2 09	 shl	 edx, 9
  004f4	89 82 80 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+384], eax

; 964  : 
; 965  : 						LogAdd(LOG_BLACK, "[Blood Castle] (%d) All of the Monster Terminated -> %d", lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1,
; 966  : 							g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_KILL_COUNT);

  004fa	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00501	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  00504	c1 e1 09	 shl	 ecx, 9
  00507	8b 91 78 01 00
	00		 mov	 edx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+376]
  0050d	52		 push	 edx
  0050e	83 c0 f6	 add	 eax, -10		; fffffff6H
  00511	50		 push	 eax
  00512	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@FKJGCAAF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5M@
  00517	6a 00		 push	 0
  00519	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd

; 967  : 
; 968  : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = g_BloodCastle.GetCurrentLiveUserCount(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1)*2;

  0051e	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00525	83 c4 10	 add	 esp, 16			; 00000010H
  00528	83 e8 0b	 sub	 eax, 11			; 0000000bH
  0052b	50		 push	 eax
  0052c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00531	e8 00 00 00 00	 call	 ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentLiveUserCount
  00536	0f b6 8e 09 01
	00 00		 movzx	 ecx, BYTE PTR [esi+265]
  0053d	03 c0		 add	 eax, eax
  0053f	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00542	c1 e1 09	 shl	 ecx, 9
  00545	89 81 84 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+388], eax

; 969  : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  0054b	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  00552	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00555	c1 e2 09	 shl	 edx, 9
  00558	c7 82 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392], 0

; 970  : 
; 971  : 						if ( g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT > 10) 

  00562	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00569	83 e8 0b	 sub	 eax, 11			; 0000000bH
  0056c	c1 e0 09	 shl	 eax, 9
  0056f	83 b8 84 01 00
	00 0a		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+388], 10 ; 0000000aH
  00576	8d 80 84 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+388]
  0057c	7e 06		 jle	 SHORT $LN23@gObjMonste@19

; 972  : 						{
; 973  : 							g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = 10;

  0057e	c7 00 0a 00 00
	00		 mov	 DWORD PTR [eax], 10	; 0000000aH
$LN23@gObjMonste@19:

; 974  : 						}
; 975  : 					}
; 976  : 
; 977  : 					if (g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_SUCCESS_MSG_COUNT < 1 )

  00584	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0058b	83 e8 0b	 sub	 eax, 11			; 0000000bH
  0058e	c1 e0 09	 shl	 eax, 9
  00591	8b 88 7c 01 00
	00		 mov	 ecx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+380]
  00597	8d 80 7c 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+380]
  0059d	83 f9 01	 cmp	 ecx, 1
  005a0	7d 28		 jge	 SHORT $LN22@gObjMonste@19

; 978  : 					{
; 979  : 						g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_MONSTER_SUCCESS_MSG_COUNT++;

  005a2	41		 inc	 ecx
  005a3	89 08		 mov	 DWORD PTR [eax], ecx

; 980  : 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1, lMsg.Get(MSGGET(4, 144))); 

  005a5	68 90 04 00 00	 push	 1168			; 00000490H
  005aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005af	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  005b4	50		 push	 eax
  005b5	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  005bc	83 e8 0b	 sub	 eax, 11			; 0000000bH
  005bf	50		 push	 eax
  005c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  005c5	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
$LN22@gObjMonste@19:

; 981  : 					}
; 982  : 					
; 983  : 				}
; 984  : 
; 985  : 				if ( g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_bBC_MONSTER_KILL_COMPLETE != false )

  005ca	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  005d1	83 c0 f5	 add	 eax, -11		; fffffff5H
  005d4	8b c8		 mov	 ecx, eax
  005d6	c1 e1 09	 shl	 ecx, 9
  005d9	80 b9 60 01 00
	00 00		 cmp	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+352], 0
  005e0	0f 84 ea fb ff
	ff		 je	 $LN72@gObjMonste@19

; 986  : 				{
; 987  : 					if ( g_BloodCastle.CheckBossKillCount(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1) != false )

  005e6	50		 push	 eax
  005e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  005ec	e8 00 00 00 00	 call	 ?CheckBossKillCount@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckBossKillCount
  005f1	84 c0		 test	 al, al
  005f3	0f 84 d7 fb ff
	ff		 je	 $LN72@gObjMonste@19

; 988  : 					{
; 989  : 						if ( g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_bBC_BOSS_MONSTER_KILL_COMPLETE == false )

  005f9	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00600	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00603	c1 e0 09	 shl	 eax, 9
  00606	80 b8 61 01 00
	00 00		 cmp	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+353], 0
  0060d	8d 80 61 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+353]
  00613	75 56		 jne	 SHORT $LN19@gObjMonste@19

; 990  : 						{
; 991  : 							g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_bBC_BOSS_MONSTER_KILL_COMPLETE = true;

  00615	c6 00 01	 mov	 BYTE PTR [eax], 1

; 992  : 							g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = -1;

  00618	0f b6 96 09 01
	00 00		 movzx	 edx, BYTE PTR [esi+265]
  0061f	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00622	c1 e2 09	 shl	 edx, 9
  00625	c7 82 84 01 00
	00 ff ff ff ff	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], -1

; 993  : 
; 994  : 							g_BloodCastle.SetSaintStatue(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1);

  0062f	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00636	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00639	50		 push	 eax
  0063a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0063f	e8 00 00 00 00	 call	 ?SetSaintStatue@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetSaintStatue

; 995  : 
; 996  : 							LogAdd(LOG_BLACK, "[Blood Castle] (%d) All of the Boss Monster Terminated -> %d",
; 997  : 								lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1, g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT);

  00644	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0064b	8d 48 f5	 lea	 ecx, DWORD PTR [eax-11]
  0064e	c1 e1 09	 shl	 ecx, 9
  00651	8b 91 88 01 00
	00		 mov	 edx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+392]
  00657	52		 push	 edx
  00658	83 c0 f6	 add	 eax, -10		; fffffff6H
  0065b	50		 push	 eax
  0065c	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@OMDKGOEJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5All?5of?5the?5B@
  00661	6a 00		 push	 0
  00663	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00668	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@gObjMonste@19:

; 998  : 						}
; 999  : 
; 1000 : 						if ( g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT < 1 )

  0066b	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  00672	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00675	c1 e0 09	 shl	 eax, 9
  00678	8b 88 8c 01 00
	00		 mov	 ecx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+396]
  0067e	8d 80 8c 01 00
	00		 lea	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[eax+396]
  00684	83 f9 01	 cmp	 ecx, 1
  00687	0f 8d 43 fb ff
	ff		 jge	 $LN72@gObjMonste@19

; 1001 : 						{
; 1002 : 							g_BloodCastle.m_BridgeData[lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_SUCCESS_MSG_COUNT++;

  0068d	41		 inc	 ecx
  0068e	89 08		 mov	 DWORD PTR [eax], ecx

; 1003 : 							g_BloodCastle.SendNoticeMessage(lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1, lMsg.Get(MSGGET(4, 156)));

  00690	68 9c 04 00 00	 push	 1180			; 0000049cH
  00695	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0069a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0069f	50		 push	 eax
  006a0	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  006a7	83 e8 0b	 sub	 eax, 11			; 0000000bH
  006aa	50		 push	 eax
  006ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  006b0	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage
  006b5	5f		 pop	 edi
  006b6	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  006b7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006ba	33 cd		 xor	 ecx, ebp
  006bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006c1	8b e5		 mov	 esp, ebp
  006c3	5d		 pop	 ebp
  006c4	c3		 ret	 0
$LN17@gObjMonste@19:

; 1004 : 						}
; 1005 : 					}
; 1006 : 				}
; 1007 : 			}
; 1008 : 			
; 1009 : 			break;
; 1010 : 
; 1011 : 
; 1012 : 		case 2:
; 1013 : 			if ( gObj[aIndex].Live != FALSE )

  006c5	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  006cb	80 bf 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+98], 0
  006d2	0f 84 f8 fa ff
	ff		 je	 $LN72@gObjMonste@19

; 1014 : 			{
; 1015 : 				if ( BC_MAP_RANGE(gObj[aIndex].MapNumber) == FALSE )

  006d8	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+265]
  006df	3c 0b		 cmp	 al, 11			; 0000000bH
  006e1	72 0d		 jb	 SHORT $LN90@gObjMonste@19
  006e3	b1 11		 mov	 cl, 17			; 00000011H
  006e5	3a c8		 cmp	 cl, al
  006e7	1b c0		 sbb	 eax, eax
  006e9	40		 inc	 eax
  006ea	0f 85 e0 fa ff
	ff		 jne	 $LN72@gObjMonste@19
$LN90@gObjMonste@19:

; 1016 : 				{
; 1017 : 					if ( gObj[aIndex].Class != 131 || ((  (lpObj->Class-132)<0)?FALSE:((lpObj->Class-132)>2)?FALSE:TRUE)==FALSE )

  006f0	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  006f5	66 39 97 98 00
	00 00		 cmp	 WORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+152], dx
  006fc	75 20		 jne	 SHORT $LN13@gObjMonste@19
  006fe	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00705	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  0070a	78 12		 js	 SHORT $LN13@gObjMonste@19
  0070c	33 c9		 xor	 ecx, ecx
  0070e	83 f8 02	 cmp	 eax, 2
  00711	0f 9e c1	 setle	 cl
  00714	8b c1		 mov	 eax, ecx
  00716	85 c0		 test	 eax, eax
  00718	0f 85 b2 fa ff
	ff		 jne	 $LN72@gObjMonste@19
$LN13@gObjMonste@19:

; 1018 : 					{
; 1019 : 						gObjBackSpring(lpObj, &gObj[aIndex]);

  0071e	8d 97 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  00724	52		 push	 edx
  00725	56		 push	 esi
  00726	e8 00 00 00 00	 call	 ?gObjBackSpring@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjBackSpring
  0072b	83 c4 08	 add	 esp, 8
  0072e	5f		 pop	 edi
  0072f	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  00730	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00733	33 cd		 xor	 ecx, ebp
  00735	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0073a	8b e5		 mov	 esp, ebp
  0073c	5d		 pop	 ebp
  0073d	c3		 ret	 0
$LN12@gObjMonste@19:

; 1020 : 					}
; 1021 : 				}
; 1022 : 			}
; 1023 : 
; 1024 : 			break;
; 1025 : 
; 1026 : 		case 3:
; 1027 : 			lpObj->TargetNumber = -1;

  0073e	83 c8 ff	 or	 eax, -1

; 1028 : 			lpObj->LastAttackerID = -1;

  00741	0b c8		 or	 ecx, eax

; 1029 : 			lpObj->m_ActState.Emotion = 0;
; 1030 : 			lpObj->m_ActState.Attack = 0;
; 1031 : 			lpObj->m_ActState.Move = 0;

  00743	81 a6 b4 01 00
	00 09 ff ff ff	 and	 DWORD PTR [esi+436], -247 ; ffffff09H
  0074d	5f		 pop	 edi
  0074e	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax
  00755	66 89 8e da 02
	00 00		 mov	 WORD PTR [esi+730], cx

; 1032 : 			lpObj->NextActionTime = 1000;

  0075c	c7 86 1c 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+540], 1000 ; 000003e8H
  00766	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  00767	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0076a	33 cd		 xor	 ecx, ebp
  0076c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00771	8b e5		 mov	 esp, ebp
  00773	5d		 pop	 ebp
  00774	c3		 ret	 0
$LN11@gObjMonste@19:

; 1033 : 			break;
; 1034 : 
; 1035 : 		case 4:
; 1036 : 			lpObj->m_ActState.Emotion = 3;

  00775	8b 96 b4 01 00
	00		 mov	 edx, DWORD PTR [esi+436]
  0077b	81 e2 3f ff ff
	ff		 and	 edx, -193		; ffffff3fH
  00781	83 ca 30	 or	 edx, 48			; 00000030H
  00784	89 96 b4 01 00
	00		 mov	 DWORD PTR [esi+436], edx
  0078a	5f		 pop	 edi

; 1037 : 			lpObj->m_ActState.EmotionCount = 1;

  0078b	c6 86 b5 01 00
	00 01		 mov	 BYTE PTR [esi+437], 1
  00792	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  00793	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00796	33 cd		 xor	 ecx, ebp
  00798	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0079d	8b e5		 mov	 esp, ebp
  0079f	5d		 pop	 ebp
  007a0	c3		 ret	 0
$LN10@gObjMonste@19:

; 1038 : 			break;
; 1039 : 
; 1040 : 		case 5:
; 1041 : 			gObjMemFree(lpObj->m_Index);

  007a1	8b 06		 mov	 eax, DWORD PTR [esi]
  007a3	50		 push	 eax
  007a4	e8 00 00 00 00	 call	 ?gObjMemFree@@YAFH@Z	; gObjMemFree
  007a9	83 c4 04	 add	 esp, 4
  007ac	5f		 pop	 edi
  007ad	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  007ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007b1	33 cd		 xor	 ecx, ebp
  007b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007b8	8b e5		 mov	 esp, ebp
  007ba	5d		 pop	 ebp
  007bb	c3		 ret	 0
$LN9@gObjMonste@19:

; 1042 : 			break;
; 1043 : 
; 1044 : 		case 6:
; 1045 : 			if ( gObj[aIndex].Live != FALSE )

  007bc	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  007c2	80 bf 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+98], 0
  007c9	0f 84 01 fa ff
	ff		 je	 $LN72@gObjMonste@19

; 1046 : 			{
; 1047 : 				gObjBackSpring2(lpObj, &gObj[aIndex], 2);

  007cf	6a 02		 push	 2
  007d1	8d 8f 00 00 00
	00		 lea	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  007d7	51		 push	 ecx
  007d8	56		 push	 esi
  007d9	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  007de	83 c4 0c	 add	 esp, 12			; 0000000cH
  007e1	5f		 pop	 edi
  007e2	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  007e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007e6	33 cd		 xor	 ecx, ebp
  007e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ed	8b e5		 mov	 esp, ebp
  007ef	5d		 pop	 ebp
  007f0	c3		 ret	 0
$LN7@gObjMonste@19:

; 1048 : 			}
; 1049 : 
; 1050 : 			break;
; 1051 : 
; 1052 : 		case 7:
; 1053 : 			if ( gObj[aIndex].Live != FALSE )

  007f1	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  007f7	80 bf 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi+98], 0
  007fe	0f 84 cc f9 ff
	ff		 je	 $LN72@gObjMonste@19

; 1054 : 			{
; 1055 : 				gObjBackSpring2(lpObj, &gObj[aIndex], 3);

  00804	6a 03		 push	 3
  00806	8d 97 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[edi]
  0080c	52		 push	 edx
  0080d	56		 push	 esi
  0080e	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  00813	83 c4 0c	 add	 esp, 12			; 0000000cH
  00816	5f		 pop	 edi
  00817	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  00818	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081b	33 cd		 xor	 ecx, ebp
  0081d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00822	8b e5		 mov	 esp, ebp
  00824	5d		 pop	 ebp
  00825	c3		 ret	 0
$LN5@gObjMonste@19:

; 1056 : 			}
; 1057 : 			break;
; 1058 : 
; 1059 : 		case 55:
; 1060 : 			gObjAttack(lpObj, &gObj[aIndex], NULL, FALSE, 0, 0, FALSE);

  00826	6a 00		 push	 0
  00828	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0082e	6a 00		 push	 0
  00830	6a 00		 push	 0
  00832	6a 00		 push	 0
  00834	6a 00		 push	 0
  00836	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0083c	57		 push	 edi
  0083d	56		 push	 esi
  0083e	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAUOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00843	83 c4 1c	 add	 esp, 28			; 0000001cH
  00846	5f		 pop	 edi
  00847	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  00848	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084b	33 cd		 xor	 ecx, ebp
  0084d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00852	8b e5		 mov	 esp, ebp
  00854	5d		 pop	 ebp
  00855	c3		 ret	 0
$LN4@gObjMonste@19:

; 1061 : 			break;
; 1062 : 
; 1063 : 		case 56:
; 1064 : 			{
; 1065 : 				LPOBJ lpTargetObj = &gObj[aIndex];

  00856	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  0085c	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1066 : 
; 1067 : 				if ( lpTargetObj->m_PoisonType == 0 )

  00862	80 bf 25 02 00
	00 00		 cmp	 BYTE PTR [edi+549], 0
  00869	0f 85 61 f9 ff
	ff		 jne	 $LN72@gObjMonste@19

; 1068 : 				{
; 1069 : 					if ( retResistance(lpTargetObj, 1) == 0 )

  0086f	6a 01		 push	 1
  00871	57		 push	 edi
  00872	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  00877	83 c4 08	 add	 esp, 8
  0087a	85 c0		 test	 eax, eax
  0087c	0f 85 4e f9 ff
	ff		 jne	 $LN72@gObjMonste@19

; 1070 : 					{
; 1071 : 						lpTargetObj->m_PoisonType = 1;
; 1072 : 						lpTargetObj->m_PoisonBeattackCount = aMsgSubCode;

  00882	8a 45 14	 mov	 al, BYTE PTR _aMsgSubCode$[ebp]

; 1073 : 						lpTargetObj->lpAttackObj = lpObj;
; 1074 : 						lpTargetObj->m_ViewSkillState |= 1;

  00885	83 8f c4 01 00
	00 01		 or	 DWORD PTR [edi+452], 1
  0088c	88 87 27 02 00
	00		 mov	 BYTE PTR [edi+551], al
  00892	8b 87 c4 01 00
	00		 mov	 eax, DWORD PTR [edi+452]

; 1075 : 						GCStateInfoSend(lpTargetObj, 1, lpTargetObj->m_ViewSkillState);

  00898	50		 push	 eax
  00899	6a 01		 push	 1
  0089b	57		 push	 edi
  0089c	c6 87 25 02 00
	00 01		 mov	 BYTE PTR [edi+549], 1
  008a3	89 b7 38 02 00
	00		 mov	 DWORD PTR [edi+568], esi
  008a9	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  008ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  008b1	5f		 pop	 edi
  008b2	5e		 pop	 esi

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  008b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008b6	33 cd		 xor	 ecx, ebp
  008b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008bd	8b e5		 mov	 esp, ebp
  008bf	5d		 pop	 ebp
  008c0	c3		 ret	 0
$LN1@gObjMonste@19:

; 1076 : 					}
; 1077 : 				}
; 1078 : 			}
; 1079 : 			break;
; 1080 : 
; 1081 : 		case 57:
; 1082 : 			{
; 1083 : 				LPOBJ lpTargetObj = &gObj[aIndex];
; 1084 : 				gObjBackSpring2(lpTargetObj, lpObj, aMsgSubCode);

  008c1	8b 4d 14	 mov	 ecx, DWORD PTR _aMsgSubCode$[ebp]
  008c4	69 ff 64 15 00
	00		 imul	 edi, 5476		; 00001564H
  008ca	51		 push	 ecx
  008cb	56		 push	 esi
  008cc	81 c7 00 00 00
	00		 add	 edi, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  008d2	57		 push	 edi
  008d3	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ; gObjBackSpring2

; 1085 : 			}
; 1086 : 			break;
; 1087 : 	}
; 1088 : }

  008d8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008db	83 c4 0c	 add	 esp, 12			; 0000000cH
  008de	5f		 pop	 edi
  008df	33 cd		 xor	 ecx, ebp
  008e1	5e		 pop	 esi
  008e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008e7	8b e5		 mov	 esp, ebp
  008e9	5d		 pop	 ebp
  008ea	c3		 ret	 0
  008eb	90		 npad	 1
$LN99@gObjMonste@19:
  008ec	00 00 00 00	 DD	 $LN71@gObjMonste@19
  008f0	00 00 00 00	 DD	 $LN34@gObjMonste@19
  008f4	00 00 00 00	 DD	 $LN17@gObjMonste@19
  008f8	00 00 00 00	 DD	 $LN12@gObjMonste@19
  008fc	00 00 00 00	 DD	 $LN11@gObjMonste@19
  00900	00 00 00 00	 DD	 $LN10@gObjMonste@19
  00904	00 00 00 00	 DD	 $LN9@gObjMonste@19
  00908	00 00 00 00	 DD	 $LN7@gObjMonste@19
  0090c	00 00 00 00	 DD	 $LN5@gObjMonste@19
  00910	00 00 00 00	 DD	 $LN4@gObjMonste@19
  00914	00 00 00 00	 DD	 $LN1@gObjMonste@19
  00918	00 00 00 00	 DD	 $LN72@gObjMonste@19
$LN91@gObjMonste@19:
  0091c	00		 DB	 0
  0091d	01		 DB	 1
  0091e	02		 DB	 2
  0091f	03		 DB	 3
  00920	04		 DB	 4
  00921	05		 DB	 5
  00922	06		 DB	 6
  00923	07		 DB	 7
  00924	0b		 DB	 11			; 0000000bH
  00925	0b		 DB	 11			; 0000000bH
  00926	0b		 DB	 11			; 0000000bH
  00927	0b		 DB	 11			; 0000000bH
  00928	0b		 DB	 11			; 0000000bH
  00929	0b		 DB	 11			; 0000000bH
  0092a	0b		 DB	 11			; 0000000bH
  0092b	0b		 DB	 11			; 0000000bH
  0092c	0b		 DB	 11			; 0000000bH
  0092d	0b		 DB	 11			; 0000000bH
  0092e	0b		 DB	 11			; 0000000bH
  0092f	0b		 DB	 11			; 0000000bH
  00930	0b		 DB	 11			; 0000000bH
  00931	0b		 DB	 11			; 0000000bH
  00932	0b		 DB	 11			; 0000000bH
  00933	0b		 DB	 11			; 0000000bH
  00934	0b		 DB	 11			; 0000000bH
  00935	0b		 DB	 11			; 0000000bH
  00936	0b		 DB	 11			; 0000000bH
  00937	0b		 DB	 11			; 0000000bH
  00938	0b		 DB	 11			; 0000000bH
  00939	0b		 DB	 11			; 0000000bH
  0093a	0b		 DB	 11			; 0000000bH
  0093b	0b		 DB	 11			; 0000000bH
  0093c	0b		 DB	 11			; 0000000bH
  0093d	0b		 DB	 11			; 0000000bH
  0093e	0b		 DB	 11			; 0000000bH
  0093f	0b		 DB	 11			; 0000000bH
  00940	0b		 DB	 11			; 0000000bH
  00941	0b		 DB	 11			; 0000000bH
  00942	0b		 DB	 11			; 0000000bH
  00943	0b		 DB	 11			; 0000000bH
  00944	0b		 DB	 11			; 0000000bH
  00945	0b		 DB	 11			; 0000000bH
  00946	0b		 DB	 11			; 0000000bH
  00947	0b		 DB	 11			; 0000000bH
  00948	0b		 DB	 11			; 0000000bH
  00949	0b		 DB	 11			; 0000000bH
  0094a	0b		 DB	 11			; 0000000bH
  0094b	0b		 DB	 11			; 0000000bH
  0094c	0b		 DB	 11			; 0000000bH
  0094d	0b		 DB	 11			; 0000000bH
  0094e	0b		 DB	 11			; 0000000bH
  0094f	0b		 DB	 11			; 0000000bH
  00950	0b		 DB	 11			; 0000000bH
  00951	0b		 DB	 11			; 0000000bH
  00952	0b		 DB	 11			; 0000000bH
  00953	08		 DB	 8
  00954	09		 DB	 9
  00955	0a		 DB	 10			; 0000000aH
?gObjMonsterStateProc@@YAXPAUOBJECTSTRUCT@@HHH@Z ENDP	; gObjMonsterStateProc
_TEXT	ENDS
PUBLIC	?gObjMonsterProcess@@YAXPAUOBJECTSTRUCT@@@Z	; gObjMonsterProcess
EXTRN	?gObjTeleportMagicUse@@YAXHEE@Z:PROC		; gObjTeleportMagicUse
EXTRN	?MercenaryAct@CMercenary@@QAEXH@Z:PROC		; CMercenary::MercenaryAct
EXTRN	?g_CsNPC_Mercenary@@3VCMercenary@@A:QWORD	; g_CsNPC_Mercenary
EXTRN	?gBattleSoccerScoreUpdate@@YAHHH@Z:PROC		; gBattleSoccerScoreUpdate
EXTRN	?gCheckGoal@@YAHHHAAH@Z:PROC			; gCheckGoal
EXTRN	?KalimaGateAct@CKalimaGate@@QAEXH@Z:PROC	; CKalimaGate::KalimaGateAct
EXTRN	?KalimaGateAct2@CKalimaGate@@QAEXH@Z:PROC	; CKalimaGate::KalimaGateAct2
EXTRN	?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z:PROC	; gObjMsgProc
; Function compile flags: /Ogtp
;	COMDAT ?gObjMonsterProcess@@YAXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ground$158194 = 8					; size = 4
_lpObj$ = 8						; size = 4
?gObjMonsterProcess@@YAXPAUOBJECTSTRUCT@@@Z PROC	; gObjMonsterProcess, COMDAT

; 1096 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1097 : 	gObjMsgProc(lpObj);

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	56		 push	 esi
  00008	e8 00 00 00 00	 call	 ?gObjMsgProc@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMsgProc
  0000d	83 c4 04	 add	 esp, 4

; 1098 : 
; 1099 : 	if ( lpObj->Live == FALSE )

  00010	80 7e 62 00	 cmp	 BYTE PTR [esi+98], 0
  00014	0f 84 6a 03 00
	00		 je	 $LN25@gObjMonste@20

; 1100 : 	{
; 1101 : 		return;
; 1102 : 	}
; 1103 : 
; 1104 : 	if ( lpObj->m_iMonsterBattleDelay > 0 )

  0001a	8a 86 2b 02 00
	00		 mov	 al, BYTE PTR [esi+555]
  00020	84 c0		 test	 al, al
  00022	7e 08		 jle	 SHORT $LN50@gObjMonste@20

; 1105 : 	{
; 1106 : 		lpObj->m_iMonsterBattleDelay--;

  00024	fe c8		 dec	 al
  00026	88 86 2b 02 00
	00		 mov	 BYTE PTR [esi+555], al
$LN50@gObjMonste@20:

; 1107 : 	}
; 1108 : 
; 1109 : 	if ( (GetTickCount() - lpObj->CurActionTime ) < (lpObj->NextActionTime + lpObj->DelayActionTime) )

  0002c	57		 push	 edi
  0002d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00033	ff d7		 call	 edi
  00035	8b 8e 20 02 00
	00		 mov	 ecx, DWORD PTR [esi+544]
  0003b	2b 86 18 02 00
	00		 sub	 eax, DWORD PTR [esi+536]
  00041	03 8e 1c 02 00
	00		 add	 ecx, DWORD PTR [esi+540]
  00047	3b c1		 cmp	 eax, ecx
  00049	0f 82 34 03 00
	00		 jb	 $LN67@gObjMonste@20

; 1110 : 	{
; 1111 : 		return;
; 1112 : 	}
; 1113 : 
; 1114 : 	lpObj->CurActionTime = GetTickCount();

  0004f	ff d7		 call	 edi
  00051	89 86 18 02 00
	00		 mov	 DWORD PTR [esi+536], eax

; 1115 : 
; 1116 : 	if ( BC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  00057	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0005e	3c 0b		 cmp	 al, 11			; 0000000bH
  00060	72 37		 jb	 SHORT $LN62@gObjMonste@20
  00062	b2 11		 mov	 dl, 17			; 00000011H
  00064	3a d0		 cmp	 dl, al
  00066	1b c0		 sbb	 eax, eax
  00068	40		 inc	 eax
  00069	74 2e		 je	 SHORT $LN62@gObjMonste@20

; 1117 : 	{
; 1118 : 		if ( lpObj->Class == 131|| ((lpObj->Class-132<0)?FALSE:(lpObj->Class-132>2)?FALSE:TRUE) != FALSE )

  0006b	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  00072	b9 83 00 00 00	 mov	 ecx, 131		; 00000083H
  00077	66 3b c1	 cmp	 ax, cx
  0007a	0f 84 03 03 00
	00		 je	 $LN67@gObjMonste@20
  00080	05 7c ff ff ff	 add	 eax, -132		; ffffff7cH
  00085	78 12		 js	 SHORT $LN62@gObjMonste@20
  00087	33 d2		 xor	 edx, edx
  00089	83 f8 02	 cmp	 eax, 2
  0008c	0f 9e c2	 setle	 dl
  0008f	8b c2		 mov	 eax, edx
  00091	85 c0		 test	 eax, eax

; 1119 : 		{
; 1120 : 			return;

  00093	0f 85 ea 02 00
	00		 jne	 $LN67@gObjMonste@20
$LN62@gObjMonste@20:

; 1121 : 		}
; 1122 : 	}
; 1123 : 
; 1124 : 	if ( ((lpObj->m_Attribute < 51)?FALSE:(lpObj->m_Attribute > 58)?FALSE:TRUE) != FALSE )

  00099	0f b7 86 26 03
	00 00		 movzx	 eax, WORD PTR [esi+806]
  000a0	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  000a4	7c 35		 jl	 SHORT $LN66@gObjMonste@20
  000a6	33 c9		 xor	 ecx, ecx
  000a8	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  000ac	0f 9e c1	 setle	 cl
  000af	85 c9		 test	 ecx, ecx
  000b1	74 28		 je	 SHORT $LN66@gObjMonste@20

; 1125 : 	{
; 1126 : 		if ( lpObj->m_Attribute == 58 )

  000b3	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  000b7	75 11		 jne	 SHORT $LN44@gObjMonste@20

; 1127 : 		{
; 1128 : 			g_KalimaGate.KalimaGateAct2(lpObj->m_Index);

  000b9	8b 06		 mov	 eax, DWORD PTR [esi]
  000bb	50		 push	 eax
  000bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  000c1	e8 00 00 00 00	 call	 ?KalimaGateAct2@CKalimaGate@@QAEXH@Z ; CKalimaGate::KalimaGateAct2
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
$LN44@gObjMonste@20:

; 1129 : 			return;
; 1130 : 		}
; 1131 : 
; 1132 : 		g_KalimaGate.KalimaGateAct(lpObj->m_Index);

  000ca	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000cc	51		 push	 ecx
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  000d2	e8 00 00 00 00	 call	 ?KalimaGateAct@CKalimaGate@@QAEXH@Z ; CKalimaGate::KalimaGateAct
  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
$LN66@gObjMonste@20:

; 1133 : 		return;
; 1134 : 	}
; 1135 : 
; 1136 : #if ( GS_CASTLE == 1 )
; 1137 : 	if ( lpObj->Class == 283 )	return;
; 1138 : 	if ( lpObj->Class == 288 )	return;
; 1139 : 	if ( lpObj->Class == 278 )	return;
; 1140 : #endif
; 1141 : 
; 1142 : 	if ( lpObj->Class >= 100 && lpObj->Class <= 110 )

  000db	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  000e2	83 f8 64	 cmp	 eax, 100		; 00000064H
  000e5	72 13		 jb	 SHORT $LN43@gObjMonste@20
  000e7	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  000ea	77 0e		 ja	 SHORT $LN43@gObjMonste@20

; 1143 : 	{
; 1144 : 		gObjMonsterTrapAct(lpObj);

  000ec	56		 push	 esi
  000ed	e8 00 00 00 00	 call	 ?gObjMonsterTrapAct@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterTrapAct
  000f2	83 c4 04	 add	 esp, 4
  000f5	e9 8c 00 00 00	 jmp	 $LN33@gObjMonste@20
$LN43@gObjMonste@20:

; 1145 : 		
; 1146 : 	}
; 1147 : 	else if ( lpObj->Class == 200 )

  000fa	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  000ff	66 3b c2	 cmp	 ax, dx
  00102	75 39		 jne	 SHORT $LN41@gObjMonste@20

; 1148 : 	{
; 1149 : 		int ground;
; 1150 : 		int team = gCheckGoal(lpObj->X, lpObj->Y, ground);

  00104	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  0010b	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00112	8d 45 08	 lea	 eax, DWORD PTR _ground$158194[ebp]
  00115	50		 push	 eax
  00116	51		 push	 ecx
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ?gCheckGoal@@YAHHHAAH@Z	; gCheckGoal
  0011d	8b f8		 mov	 edi, eax
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1151 : 
; 1152 : 		if ( team >= 0 )

  00122	85 ff		 test	 edi, edi
  00124	78 60		 js	 SHORT $LN33@gObjMonste@20

; 1153 : 		{
; 1154 : 			gObjMonsterRegen(lpObj);

  00126	56		 push	 esi
  00127	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAUOBJECTSTRUCT@@@Z ; gObjMonsterRegen

; 1155 : 			gBattleSoccerScoreUpdate(ground, team);

  0012c	8b 45 08	 mov	 eax, DWORD PTR _ground$158194[ebp]
  0012f	57		 push	 edi
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?gBattleSoccerScoreUpdate@@YAHHH@Z ; gBattleSoccerScoreUpdate
  00136	83 c4 0c	 add	 esp, 12			; 0000000cH
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
$LN41@gObjMonste@20:

; 1156 : 			return;
; 1157 : 		}
; 1158 : 	}
; 1159 : 	else 
; 1160 : 	{
; 1161 : 		if ( lpObj->Class == 287 || lpObj->Class == 286 )

  0013d	b9 1f 01 00 00	 mov	 ecx, 287		; 0000011fH
  00142	66 3b c1	 cmp	 ax, cx
  00145	74 32		 je	 SHORT $LN37@gObjMonste@20
  00147	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  0014c	66 3b c2	 cmp	 ax, dx
  0014f	74 28		 je	 SHORT $LN37@gObjMonste@20

; 1164 : 		}
; 1165 : 		else if ( lpObj->m_bIsInMonsterHerd != false )

  00151	83 be 24 0f 00
	00 00		 cmp	 DWORD PTR [esi+3876], 0
  00158	74 14		 je	 SHORT $LN35@gObjMonste@20

; 1166 : 		{
; 1167 : 			if ( lpObj->m_lpMonsterHerd != NULL )

  0015a	8b 8e 2c 0f 00
	00		 mov	 ecx, DWORD PTR [esi+3884]
  00160	85 c9		 test	 ecx, ecx
  00162	74 22		 je	 SHORT $LN33@gObjMonste@20

; 1168 : 			{
; 1169 : 				lpObj->m_lpMonsterHerd->MonsterBaseAct(lpObj);

  00164	8b 01		 mov	 eax, DWORD PTR [ecx]
  00166	8b 50 40	 mov	 edx, DWORD PTR [eax+64]
  00169	56		 push	 esi
  0016a	ff d2		 call	 edx

; 1170 : 			}
; 1171 : 		}
; 1172 : 		else

  0016c	eb 18		 jmp	 SHORT $LN33@gObjMonste@20
$LN35@gObjMonste@20:

; 1173 : 		{
; 1174 : 			gObjMonsterBaseAct(lpObj);

  0016e	56		 push	 esi
  0016f	e8 00 00 00 00	 call	 ?gObjMonsterBaseAct@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterBaseAct
  00174	83 c4 04	 add	 esp, 4
  00177	eb 0d		 jmp	 SHORT $LN33@gObjMonste@20
$LN37@gObjMonste@20:

; 1162 : 		{
; 1163 : 			g_CsNPC_Mercenary.MercenaryAct(lpObj->m_Index);

  00179	8b 06		 mov	 eax, DWORD PTR [esi]
  0017b	50		 push	 eax
  0017c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Mercenary@@3VCMercenary@@A ; g_CsNPC_Mercenary
  00181	e8 00 00 00 00	 call	 ?MercenaryAct@CMercenary@@QAEXH@Z ; CMercenary::MercenaryAct
$LN33@gObjMonste@20:

; 1175 : 		}
; 1176 : 	}
; 1177 : 
; 1178 : 	if ( lpObj->m_Attribute == 100 )

  00186	66 83 be 26 03
	00 00 64	 cmp	 WORD PTR [esi+806], 100	; 00000064H
  0018e	53		 push	 ebx
  0018f	75 79		 jne	 SHORT $LN65@gObjMonste@20

; 1179 : 	{
; 1180 : 		if ( lpObj->m_RecallMon >= 0 && lpObj->m_RecallMon < OBJMAX )

  00191	8b 86 cc 02 00
	00		 mov	 eax, DWORD PTR [esi+716]
  00197	85 c0		 test	 eax, eax
  00199	78 6f		 js	 SHORT $LN65@gObjMonste@20
  0019b	3d e8 1c 00 00	 cmp	 eax, 7400		; 00001ce8H
  001a0	7d 68		 jge	 SHORT $LN65@gObjMonste@20

; 1181 : 		{
; 1182 : 			LPOBJ lpCallMonObj;
; 1183 : 			BOOL Success = FALSE;
; 1184 : 
; 1185 : 			lpCallMonObj = &gObj[lpObj->m_RecallMon];
; 1186 : 
; 1187 : 
; 1188 : 			if ( lpObj->MapNumber != lpCallMonObj->MapNumber )

  001a2	8a 8e 09 01 00
	00		 mov	 cl, BYTE PTR [esi+265]
  001a8	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  001ae	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001b3	8b f8		 mov	 edi, eax
  001b5	33 db		 xor	 ebx, ebx
  001b7	3a 8f 09 01 00
	00		 cmp	 cl, BYTE PTR [edi+265]
  001bd	74 05		 je	 SHORT $LN30@gObjMonste@20

; 1189 : 			{
; 1190 : 				Success = TRUE;

  001bf	bb 01 00 00 00	 mov	 ebx, 1
$LN30@gObjMonste@20:

; 1191 : 			}
; 1192 : 	
; 1193 : 			if ( gObjCalDistance(lpCallMonObj, lpObj)> 14 )

  001c4	56		 push	 esi
  001c5	57		 push	 edi
  001c6	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  001cb	83 c4 08	 add	 esp, 8
  001ce	83 f8 0e	 cmp	 eax, 14			; 0000000eH

; 1194 : 			{
; 1195 : 				Success = TRUE;
; 1196 : 			}
; 1197 : 
; 1198 : 			if ( Success == TRUE )

  001d1	7f 05		 jg	 SHORT $LN60@gObjMonste@20
  001d3	83 fb 01	 cmp	 ebx, 1
  001d6	75 32		 jne	 SHORT $LN65@gObjMonste@20
$LN60@gObjMonste@20:

; 1199 : 			{
; 1200 : 				gObjTeleportMagicUse(lpObj->m_Index, (BYTE)lpCallMonObj->X+1, lpCallMonObj->Y);

  001d8	0f b6 87 04 01
	00 00		 movzx	 eax, BYTE PTR [edi+260]
  001df	0f b6 97 06 01
	00 00		 movzx	 edx, BYTE PTR [edi+262]
  001e6	fe c0		 inc	 al
  001e8	52		 push	 edx
  001e9	8b 16		 mov	 edx, DWORD PTR [esi]
  001eb	0f b6 c8	 movzx	 ecx, al
  001ee	51		 push	 ecx
  001ef	52		 push	 edx
  001f0	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse

; 1201 : 				lpObj->MapNumber = lpCallMonObj->MapNumber;

  001f5	0f b6 87 09 01
	00 00		 movzx	 eax, BYTE PTR [edi+265]
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ff	5b		 pop	 ebx
  00200	5f		 pop	 edi
  00201	88 86 09 01 00
	00		 mov	 BYTE PTR [esi+265], al
  00207	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
$LN65@gObjMonste@20:

; 1202 : 
; 1203 : 				return;
; 1204 : 			}
; 1205 : 		}
; 1206 : 	}
; 1207 : 
; 1208 : 	if ( lpObj->m_ActState.Move != 0 )

  0020a	8b 86 b4 01 00
	00		 mov	 eax, DWORD PTR [esi+436]
  00210	a8 04		 test	 al, 4
  00212	74 24		 je	 SHORT $LN27@gObjMonste@20

; 1209 : 	{
; 1210 : 		if ( PathFindMoveMsgSend(lpObj ) == TRUE )

  00214	56		 push	 esi
  00215	e8 00 00 00 00	 call	 ?PathFindMoveMsgSend@@YAHPAUOBJECTSTRUCT@@@Z ; PathFindMoveMsgSend
  0021a	83 c4 04	 add	 esp, 4
  0021d	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  00222	83 f8 01	 cmp	 eax, 1
  00225	75 06		 jne	 SHORT $LN26@gObjMonste@20

; 1211 : 		{
; 1212 : 			lpObj->m_ActState.Move  = (DWORD)0;

  00227	21 8e b4 01 00
	00		 and	 DWORD PTR [esi+436], ecx
$LN26@gObjMonste@20:

; 1213 : 		}
; 1214 : 
; 1215 : 		lpObj->m_ActState.Move = (DWORD)0;

  0022d	21 8e b4 01 00
	00		 and	 DWORD PTR [esi+436], ecx
  00233	5b		 pop	 ebx
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
$LN27@gObjMonste@20:

; 1216 : 
; 1217 : 		return;
; 1218 : 	}
; 1219 : 
; 1220 : 	if ( lpObj->m_ActState.Attack == 1 )

  00238	a8 02		 test	 al, 2
  0023a	0f 84 42 01 00
	00		 je	 $LN68@gObjMonste@20

; 1221 : 	{
; 1222 : 		int AttackType = lpObj->m_AttackType;
; 1223 : 		int lc6 = 0;
; 1224 : 
; 1225 : 		if ( AttackType >= 100 )

  00240	66 83 be 22 03
	00 00 64	 cmp	 WORD PTR [esi+802], 100	; 00000064H
  00248	7c 11		 jl	 SHORT $LN61@gObjMonste@20

; 1226 : 		{
; 1227 : 			if ( (rand()%5) == 0 )

  0024a	e8 00 00 00 00	 call	 _rand
  0024f	99		 cdq
  00250	b9 05 00 00 00	 mov	 ecx, 5
  00255	f7 f9		 idiv	 ecx
  00257	85 d2		 test	 edx, edx

; 1228 : 			{
; 1229 : 				AttackType -= 100;
; 1230 : 				lc6 = TRUE;
; 1231 : 			}
; 1232 : 			else
; 1233 : 			{
; 1234 : 				AttackType = 0;
; 1235 : 			}
; 1236 : 		}
; 1237 : 
; 1238 : 		if ( lc6 != FALSE || lpObj->m_AttackType == 50)

  00259	74 6f		 je	 SHORT $LN20@gObjMonste@20
$LN61@gObjMonste@20:
  0025b	66 83 be 22 03
	00 00 32	 cmp	 WORD PTR [esi+802], 50	; 00000032H
  00263	74 65		 je	 SHORT $LN20@gObjMonste@20

; 1275 : 				}
; 1276 : 			}
; 1277 : 		}
; 1278 : 		else
; 1279 : 		{
; 1280 : 			if ( lpObj->TargetNumber >= 0 )

  00265	0f b7 86 d4 02
	00 00		 movzx	 eax, WORD PTR [esi+724]
  0026c	66 85 c0	 test	 ax, ax
  0026f	0f 88 06 01 00
	00		 js	 $LN11@gObjMonste@20

; 1281 : 			{
; 1282 : 				if ( gObj[lpObj->TargetNumber].Connected > PLAYER_LOGGED &&  gObj[lpObj->TargetNumber].CloseCount == -1 )

  00275	98		 cwde
  00276	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  0027c	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  00283	0f 86 d4 00 00
	00		 jbe	 $LN18@gObjMonste@20
  00289	80 b8 07 00 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+7], -1
  00290	0f 85 c7 00 00
	00		 jne	 $LN18@gObjMonste@20

; 1283 : 				{
; 1284 : 					if ( gObj[lpObj->TargetNumber].Live == FALSE )

  00296	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  0029d	75 0f		 jne	 SHORT $LN7@gObjMonste@20

; 1285 : 					{
; 1286 : 						lpObj->TargetNumber = -1;

  0029f	83 ca ff	 or	 edx, -1
  002a2	66 89 96 d4 02
	00 00		 mov	 WORD PTR [esi+724], dx

; 1287 : 						lpObj->m_ActState.Emotion = 0;
; 1288 : 						lpObj->m_ActState.Attack = 0;
; 1289 : 						lpObj->m_ActState.Move = 0;
; 1290 : 						lpObj->NextActionTime = 1000;

  002a9	e9 b9 00 00 00	 jmp	 $LN69@gObjMonste@20
$LN7@gObjMonste@20:

; 1291 : 					}
; 1292 : 					else if ( gObj[lpObj->TargetNumber].Teleport == 0 )

  002ae	80 b8 00 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+512], 0
  002b5	0f 85 c0 00 00
	00		 jne	 $LN11@gObjMonste@20

; 1293 : 					{
; 1294 : 						gObjMonsterAttack(lpObj, &gObj[lpObj->TargetNumber]);

  002bb	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  002c1	50		 push	 eax
  002c2	56		 push	 esi
  002c3	e8 00 00 00 00	 call	 ?gObjMonsterAttack@@YAXPAUOBJECTSTRUCT@@0@Z ; gObjMonsterAttack

; 1295 : 
; 1296 : 						if ( lpObj->Type == OBJ_MONSTER )
; 1297 : 						{
; 1298 : 							if ( lpObj->m_bIsInMonsterHerd != false )
; 1299 : 							{
; 1300 : 								if (lpObj->m_lpMonsterHerd != NULL )
; 1301 : 								{
; 1302 : 									lpObj->m_lpMonsterHerd->MonsterAttackAction(lpObj, &gObj[lpObj->TargetNumber]);
; 1303 : 								}
; 1304 : 							}
; 1305 : 						}
; 1306 : 					}
; 1307 : 						
; 1308 : 				}
; 1309 : 				else
; 1310 : 				{
; 1311 : 					lpObj->TargetNumber = -1;
; 1312 : 					lpObj->m_ActState.Emotion = 0;
; 1313 : 					lpObj->m_ActState.Attack = 0;
; 1314 : 					lpObj->m_ActState.Move = 0;
; 1315 : 					lpObj->NextActionTime = 1000;

  002c8	eb 4f		 jmp	 SHORT $LN73@gObjMonste@20
$LN20@gObjMonste@20:

; 1239 : 		{
; 1240 : 			if ( lpObj->TargetNumber >= 0 )

  002ca	0f b7 86 d4 02
	00 00		 movzx	 eax, WORD PTR [esi+724]
  002d1	66 85 c0	 test	 ax, ax
  002d4	0f 88 a1 00 00
	00		 js	 $LN11@gObjMonste@20

; 1241 : 			{
; 1242 : 				if ( gObj[lpObj->TargetNumber].Connected > PLAYER_LOGGED && gObj[lpObj->TargetNumber].CloseCount == -1 )

  002da	98		 cwde
  002db	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  002e1	80 b8 04 00 00
	00 02		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+4], 2
  002e8	76 73		 jbe	 SHORT $LN18@gObjMonste@20
  002ea	80 b8 07 00 00
	00 ff		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+7], -1
  002f1	75 6a		 jne	 SHORT $LN18@gObjMonste@20

; 1243 : 				{
; 1244 : 					if ( gObj[lpObj->TargetNumber].Live == FALSE )

  002f3	80 b8 62 00 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+98], 0
  002fa	75 0c		 jne	 SHORT $LN17@gObjMonste@20

; 1245 : 					{
; 1246 : 						lpObj->TargetNumber = -1;

  002fc	83 c9 ff	 or	 ecx, -1
  002ff	66 89 8e d4 02
	00 00		 mov	 WORD PTR [esi+724], cx

; 1247 : 						lpObj->m_ActState.Emotion = 0;
; 1248 : 						lpObj->m_ActState.Attack = 0;
; 1249 : 						lpObj->m_ActState.Move = 0;
; 1250 : 						lpObj->NextActionTime = 1000;

  00306	eb 5f		 jmp	 SHORT $LN69@gObjMonste@20
$LN17@gObjMonste@20:

; 1251 : 					}
; 1252 : 					else if ( gObj[lpObj->TargetNumber].Teleport == 0 ) // if is not dead

  00308	80 b8 00 02 00
	00 00		 cmp	 BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+512], 0
  0030f	75 6a		 jne	 SHORT $LN11@gObjMonste@20

; 1253 : 					{
; 1254 : 						gObjMonsterMagicAttack(lpObj, -1);

  00311	6a ff		 push	 -1
  00313	56		 push	 esi
  00314	e8 00 00 00 00	 call	 ?gObjMonsterMagicAttack@@YAXPAUOBJECTSTRUCT@@H@Z ; gObjMonsterMagicAttack
$LN73@gObjMonste@20:
  00319	83 c4 08	 add	 esp, 8

; 1255 : 
; 1256 : 						if ( lpObj->Type == OBJ_MONSTER )

  0031c	66 83 7e 60 02	 cmp	 WORD PTR [esi+96], 2
  00321	75 58		 jne	 SHORT $LN11@gObjMonste@20

; 1257 : 						{
; 1258 : 							if ( lpObj->m_bIsInMonsterHerd != false )

  00323	83 be 24 0f 00
	00 00		 cmp	 DWORD PTR [esi+3876], 0
  0032a	74 4f		 je	 SHORT $LN11@gObjMonste@20

; 1259 : 							{
; 1260 : 								if (lpObj->m_lpMonsterHerd != NULL )

  0032c	8b 8e 2c 0f 00
	00		 mov	 ecx, DWORD PTR [esi+3884]
  00332	85 c9		 test	 ecx, ecx
  00334	74 45		 je	 SHORT $LN11@gObjMonste@20

; 1261 : 								{
; 1262 : 									lpObj->m_lpMonsterHerd->MonsterAttackAction(lpObj, &gObj[lpObj->TargetNumber]);

  00336	0f bf 86 d4 02
	00 00		 movsx	 eax, WORD PTR [esi+724]
  0033d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0033f	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00345	8b 52 48	 mov	 edx, DWORD PTR [edx+72]
  00348	05 00 00 00 00	 add	 eax, OFFSET ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0034d	50		 push	 eax
  0034e	56		 push	 esi
  0034f	ff d2		 call	 edx

; 1316 : 				}
; 1317 : 			}
; 1318 : 		}
; 1319 : 
; 1320 : 		lpObj->m_ActState.Attack = 0;

  00351	83 a6 b4 01 00
	00 fd		 and	 DWORD PTR [esi+436], -3	; fffffffdH
  00358	5b		 pop	 ebx
  00359	5f		 pop	 edi
  0035a	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  0035b	5d		 pop	 ebp
  0035c	c3		 ret	 0
$LN18@gObjMonste@20:

; 1263 : 								}
; 1264 : 							}
; 1265 : 						}
; 1266 : 					}
; 1267 : 				}
; 1268 : 				else
; 1269 : 				{
; 1270 : 					lpObj->TargetNumber = -1;

  0035d	83 c8 ff	 or	 eax, -1
  00360	66 89 86 d4 02
	00 00		 mov	 WORD PTR [esi+724], ax
$LN69@gObjMonste@20:

; 1271 : 					lpObj->m_ActState.Emotion = 0;
; 1272 : 					lpObj->m_ActState.Attack = 0;
; 1273 : 					lpObj->m_ActState.Move = 0;

  00367	81 a6 b4 01 00
	00 09 ff ff ff	 and	 DWORD PTR [esi+436], -247 ; ffffff09H

; 1274 : 					lpObj->NextActionTime = 1000;

  00371	c7 86 1c 02 00
	00 e8 03 00 00	 mov	 DWORD PTR [esi+540], 1000 ; 000003e8H
$LN11@gObjMonste@20:

; 1316 : 				}
; 1317 : 			}
; 1318 : 		}
; 1319 : 
; 1320 : 		lpObj->m_ActState.Attack = 0;

  0037b	83 a6 b4 01 00
	00 fd		 and	 DWORD PTR [esi+436], -3	; fffffffdH
$LN68@gObjMonste@20:
  00382	5b		 pop	 ebx
$LN67@gObjMonste@20:
  00383	5f		 pop	 edi
$LN25@gObjMonste@20:
  00384	5e		 pop	 esi

; 1321 : 	}
; 1322 : }

  00385	5d		 pop	 ebp
  00386	c3		 ret	 0
?gObjMonsterProcess@@YAXPAUOBJECTSTRUCT@@@Z ENDP	; gObjMonsterProcess
_TEXT	ENDS
PUBLIC	??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG?$AA@		; `string'
PUBLIC	??_C@_0BH@OKJENIBI@?4?2Log?2KUNDUN_EVENT_LOG?$AA@ ; `string'
EXTRN	_atexit:PROC
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
;	COMDAT ??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG?$AA@
CONST	SEGMENT
??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG?$AA@ DB 'KUNDUN_EVENT_LOG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OKJENIBI@?4?2Log?2KUNDUN_EVENT_LOG?$AA@
CONST	SEGMENT
??_C@_0BH@OKJENIBI@?4?2Log?2KUNDUN_EVENT_LOG?$AA@ DB '.\Log\KUNDUN_EVENT_'
	DB	'LOG', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??__EKUNDUN_EVENT_LOG@@YAXXZ
text$yc	SEGMENT
??__EKUNDUN_EVENT_LOG@@YAXXZ PROC			; `dynamic initializer for 'KUNDUN_EVENT_LOG'', COMDAT

; 23   : CLogToFile KUNDUN_EVENT_LOG("KUNDUN_EVENT_LOG", ".\\Log\\KUNDUN_EVENT_LOG", 1);	// line : 68

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@OKJENIBI@?4?2Log?2KUNDUN_EVENT_LOG?$AA@
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BACGIKG@KUNDUN_EVENT_LOG?$AA@
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  00011	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  00016	68 00 00 00 00	 push	 OFFSET ??__FKUNDUN_EVENT_LOG@@YAXXZ ; `dynamic atexit destructor for 'KUNDUN_EVENT_LOG''
  0001b	e8 00 00 00 00	 call	 _atexit
  00020	59		 pop	 ecx
  00021	c3		 ret	 0
??__EKUNDUN_EVENT_LOG@@YAXXZ ENDP			; `dynamic initializer for 'KUNDUN_EVENT_LOG''
text$yc	ENDS
PUBLIC	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A	; gQeustNpcTeleport
_DATA	SEGMENT
?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A DD 00H	; gQeustNpcTeleport
	DB	28 DUP(00H)
	DD	0ffffffffH
; Function compile flags: /Ogtp
_DATA	ENDS
;	COMDAT ??__EgQeustNpcTeleport@@YAXXZ
text$yc	SEGMENT
??__EgQeustNpcTeleport@@YAXXZ PROC			; `dynamic initializer for 'gQeustNpcTeleport'', COMDAT

; 24   : CQeustNpcTeleport gQeustNpcTeleport;	// line : 91

  00000	68 04 00 00 00	 push	 OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+4
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  0000b	b8 02 00 00 00	 mov	 eax, 2
  00010	33 c9		 xor	 ecx, ecx
  00012	68 00 00 00 00	 push	 OFFSET ??__FgQeustNpcTeleport@@YAXXZ ; `dynamic atexit destructor for 'gQeustNpcTeleport''
  00017	89 0d 1c 00 00
	00		 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+28, ecx
  0001d	a3 24 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+36, eax
  00022	c7 05 28 00 00
	00 c6 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+40, 198 ; 000000c6H
  0002c	c7 05 2c 00 00
	00 2f 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+44, 47 ; 0000002fH
  00036	a3 30 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+48, eax
  0003b	89 0d 34 00 00
	00		 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+52, ecx
  00041	c7 05 38 00 00
	00 89 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+56, 137 ; 00000089H
  0004b	c7 05 3c 00 00
	00 57 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+60, 87 ; 00000057H
  00055	c7 05 40 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+64, 1
  0005f	c7 05 44 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+68, 3
  00069	c7 05 48 00 00
	00 a9 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+72, 169 ; 000000a9H
  00073	c7 05 4c 00 00
	00 59 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+76, 89 ; 00000059H
  0007d	a3 50 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+80, eax
  00082	c7 05 54 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+84, 7
  0008c	c7 05 58 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+88, 17 ; 00000011H
  00096	c7 05 5c 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+92, 25 ; 00000019H
  000a0	a3 60 00 00 00	 mov	 DWORD PTR ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+96, eax
  000a5	e8 00 00 00 00	 call	 _atexit
  000aa	59		 pop	 ecx
  000ab	c3		 ret	 0
??__EgQeustNpcTeleport@@YAXXZ ENDP			; `dynamic initializer for 'gQeustNpcTeleport''
text$yc	ENDS
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
; Function compile flags: /Ogtp
;	COMDAT ??__FKUNDUN_EVENT_LOG@@YAXXZ
text$yd	SEGMENT
??__FKUNDUN_EVENT_LOG@@YAXXZ PROC			; `dynamic atexit destructor for 'KUNDUN_EVENT_LOG'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?KUNDUN_EVENT_LOG@@3VCLogToFile@@A ; KUNDUN_EVENT_LOG
  00005	e9 00 00 00 00	 jmp	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
??__FKUNDUN_EVENT_LOG@@YAXXZ ENDP			; `dynamic atexit destructor for 'KUNDUN_EVENT_LOG''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__FgQeustNpcTeleport@@YAXXZ
text$yd	SEGMENT
??__FgQeustNpcTeleport@@YAXXZ PROC			; `dynamic atexit destructor for 'gQeustNpcTeleport'', COMDAT
  00000	68 04 00 00 00	 push	 OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A+4
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0000b	c3		 ret	 0
??__FgQeustNpcTeleport@@YAXXZ ENDP			; `dynamic atexit destructor for 'gQeustNpcTeleport''
text$yd	ENDS
PUBLIC	?KUNDUN_EVENT_LOG@@3VCLogToFile@@A		; KUNDUN_EVENT_LOG
_BSS	SEGMENT
?KUNDUN_EVENT_LOG@@3VCLogToFile@@A DB 010228H DUP (?)	; KUNDUN_EVENT_LOG
_BSS	ENDS
CRT$XCU	SEGMENT
_KUNDUN_EVENT_LOG$initializer$ DD FLAT:??__EKUNDUN_EVENT_LOG@@YAXXZ
_gQeustNpcTeleport$initializer$ DD FLAT:??__EgQeustNpcTeleport@@YAXXZ
CRT$XCU	ENDS
END
