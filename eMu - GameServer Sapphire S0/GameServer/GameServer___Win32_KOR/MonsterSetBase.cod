; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\MonsterSetBase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	char ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8a d8		 mov	 bl, al
  0002d	83 c4 04	 add	 esp, 4
  00030	80 fb ff	 cmp	 bl, -1
  00033	74 64		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8a d8		 mov	 bl, al
  00048	83 c4 04	 add	 esp, 4
  0004b	80 fb 2f	 cmp	 bl, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	80 fb ff	 cmp	 bl, -1
  00053	74 44		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8a d8		 mov	 bl, al
  00063	83 c4 04	 add	 esp, 4
  00066	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	0f be c3	 movsx	 eax, bl
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 a5		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  0007b	0f be c3	 movsx	 eax, bl
  0007e	8d 48 de	 lea	 ecx, DWORD PTR [eax-34]
  00081	56		 push	 esi
  00082	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00085	0f 87 2b 01 00
	00		 ja	 $LN6@GetToken
  0008b	0f b6 89 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN46@GetToken[ecx]
  00092	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[ecx*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00099	b8 02 00 00 00	 mov	 eax, 2
  0009e	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 cd		 xor	 ecx, ebp
  000a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000ad	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000b2	e9 99 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b7	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000bc	e9 8f 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000c1	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c6	e9 85 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000cb	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000d0	e9 7b 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000d5	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000da	e9 71 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000e5	52		 push	 edx
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  000f1	50		 push	 eax
  000f2	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f5	e8 00 00 00 00	 call	 _getc
  000fa	8a d8		 mov	 bl, al
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	80 fb ff	 cmp	 bl, -1
  00102	74 33		 je	 SHORT $LN12@GetToken
$LL13@GetToken:
  00104	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  00107	74 15		 je	 SHORT $LN11@GetToken
  00109	0f be cb	 movsx	 ecx, bl
  0010c	51		 push	 ecx
  0010d	e8 00 00 00 00	 call	 _isdigit
  00112	83 c4 04	 add	 esp, 4
  00115	85 c0		 test	 eax, eax
  00117	75 05		 jne	 SHORT $LN11@GetToken
  00119	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  0011c	75 19		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  0011e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  00124	88 1e		 mov	 BYTE PTR [esi], bl
  00126	52		 push	 edx

; 102  : 			p++;

  00127	46		 inc	 esi
  00128	e8 00 00 00 00	 call	 _getc
  0012d	8a d8		 mov	 bl, al
  0012f	83 c4 04	 add	 esp, 4
  00132	80 fb ff	 cmp	 bl, -1
  00135	75 cd		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = atof( TempString);	// Select the first Byte as Main ID

  00137	8d 45 98	 lea	 eax, DWORD PTR _TempString$[ebp]
  0013a	50		 push	 eax
  0013b	c6 06 00	 mov	 BYTE PTR [esi], 0
  0013e	e8 00 00 00 00	 call	 _atof
  00143	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00149	83 c4 04	 add	 esp, 4
  0014c	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  0014d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0015d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00160	33 cd		 xor	 ecx, ebp
  00162	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00171	51		 push	 ecx
  00172	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  00177	e8 00 00 00 00	 call	 _getc
  0017c	83 c4 04	 add	 esp, 4
  0017f	3c ff		 cmp	 al, -1
  00181	74 1e		 je	 SHORT $LN8@GetToken
$LL9@GetToken:
  00183	3c 22		 cmp	 al, 34			; 00000022H
  00185	0f 84 a1 00 00
	00		 je	 $LN7@GetToken
  0018b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 113  : 		{
; 114  : 			*p = ch;

  00191	88 06		 mov	 BYTE PTR [esi], al
  00193	52		 push	 edx

; 115  : 			p++;

  00194	46		 inc	 esi
  00195	e8 00 00 00 00	 call	 _getc
  0019a	83 c4 04	 add	 esp, 4
  0019d	3c ff		 cmp	 al, -1
  0019f	75 e2		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  001a1	3c 22		 cmp	 al, 34			; 00000022H
  001a3	0f 84 83 00 00
	00		 je	 $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001af	0f be d0	 movsx	 edx, al
  001b2	51		 push	 ecx
  001b3	52		 push	 edx

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001b4	eb 6e		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _isalpha
  001bc	83 c4 04	 add	 esp, 4
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 84 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001c7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  001cc	50		 push	 eax
  001cd	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001d3	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d8	e8 00 00 00 00	 call	 _getc
  001dd	8a d8		 mov	 bl, al
  001df	83 c4 04	 add	 esp, 4
  001e2	80 fb ff	 cmp	 bl, -1
  001e5	74 33		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e7	80 fb 2e	 cmp	 bl, 46			; 0000002eH
  001ea	74 15		 je	 SHORT $LN2@GetToken
  001ec	80 fb 5f	 cmp	 bl, 95			; 0000005fH
  001ef	74 10		 je	 SHORT $LN2@GetToken
  001f1	0f be cb	 movsx	 ecx, bl
  001f4	51		 push	 ecx
  001f5	e8 00 00 00 00	 call	 _isalnum
  001fa	83 c4 04	 add	 esp, 4
  001fd	85 c0		 test	 eax, eax
  001ff	74 19		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  00201	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  00207	88 1e		 mov	 BYTE PTR [esi], bl
  00209	52		 push	 edx

; 135  : 				p++;

  0020a	46		 inc	 esi
  0020b	e8 00 00 00 00	 call	 _getc
  00210	8a d8		 mov	 bl, al
  00212	83 c4 04	 add	 esp, 4
  00215	80 fb ff	 cmp	 bl, -1
  00218	75 cd		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0021a	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  0021f	0f be cb	 movsx	 ecx, bl
  00222	50		 push	 eax
  00223	51		 push	 ecx
$LN49@GetToken:
  00224	e8 00 00 00 00	 call	 _ungetc
  00229	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0022c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0022f	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00230	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0023a	33 c0		 xor	 eax, eax
  0023c	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  0023d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00240	33 cd		 xor	 ecx, ebp
  00242	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0024b	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00250	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	5e		 pop	 esi
  00254	33 cd		 xor	 ecx, ebp
  00256	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0025b	5b		 pop	 ebx
  0025c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00261	8b e5		 mov	 esp, ebp
  00263	5d		 pop	 ebp
  00264	c3		 ret	 0
  00265	8d 49 00	 npad	 3
$LN50@GetToken:
  00268	00 00 00 00	 DD	 $LN10@GetToken
  0026c	00 00 00 00	 DD	 $LN19@GetToken
  00270	00 00 00 00	 DD	 $LN17@GetToken
  00274	00 00 00 00	 DD	 $LN14@GetToken
  00278	00 00 00 00	 DD	 $LN18@GetToken
  0027c	00 00 00 00	 DD	 $LN16@GetToken
  00280	00 00 00 00	 DD	 $LN15@GetToken
  00284	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00288	00		 DB	 0
  00289	01		 DB	 1
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	02		 DB	 2
  00293	03		 DB	 3
  00294	03		 DB	 3
  00295	07		 DB	 7
  00296	03		 DB	 3
  00297	03		 DB	 3
  00298	03		 DB	 3
  00299	03		 DB	 3
  0029a	03		 DB	 3
  0029b	03		 DB	 3
  0029c	03		 DB	 3
  0029d	03		 DB	 3
  0029e	03		 DB	 3
  0029f	03		 DB	 3
  002a0	07		 DB	 7
  002a1	04		 DB	 4
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	07		 DB	 7
  002d2	07		 DB	 7
  002d3	07		 DB	 7
  002d4	07		 DB	 7
  002d5	07		 DB	 7
  002d6	07		 DB	 7
  002d7	07		 DB	 7
  002d8	07		 DB	 7
  002d9	07		 DB	 7
  002da	07		 DB	 7
  002db	07		 DB	 7
  002dc	07		 DB	 7
  002dd	07		 DB	 7
  002de	07		 DB	 7
  002df	07		 DB	 7
  002e0	07		 DB	 7
  002e1	05		 DB	 5
  002e2	07		 DB	 7
  002e3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	??_7CMonsterSetBase@@6B@			; CMonsterSetBase::`vftable'
PUBLIC	??0CMonsterSetBase@@QAE@XZ			; CMonsterSetBase::CMonsterSetBase
PUBLIC	??_R4CMonsterSetBase@@6B@			; CMonsterSetBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMonsterSetBase@@@8			; CMonsterSetBase `RTTI Type Descriptor'
PUBLIC	??_R3CMonsterSetBase@@8				; CMonsterSetBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMonsterSetBase@@8				; CMonsterSetBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMonsterSetBase@@8		; CMonsterSetBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMonsterSetBase@@UAEPAXI@Z:PROC		; CMonsterSetBase::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMonsterSetBase@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\monstersetbase.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMonsterSetBase@@8 DD FLAT:??_R0?AVCMonsterSetBase@@@8 ; CMonsterSetBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CMonsterSetBase@@8
rdata$r	SEGMENT
??_R2CMonsterSetBase@@8 DD FLAT:??_R1A@?0A@EA@CMonsterSetBase@@8 ; CMonsterSetBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMonsterSetBase@@8
rdata$r	SEGMENT
??_R3CMonsterSetBase@@8 DD 00H				; CMonsterSetBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMonsterSetBase@@@8
_DATA	SEGMENT
??_R0?AVCMonsterSetBase@@@8 DD FLAT:??_7type_info@@6B@	; CMonsterSetBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMonsterSetBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMonsterSetBase@@6B@
rdata$r	SEGMENT
??_R4CMonsterSetBase@@6B@ DD 00H			; CMonsterSetBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMonsterSetBase@@@8
	DD	FLAT:??_R3CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_7CMonsterSetBase@@6B@
CONST	SEGMENT
??_7CMonsterSetBase@@6B@ DD FLAT:??_R4CMonsterSetBase@@6B@ ; CMonsterSetBase::`vftable'
	DD	FLAT:??_ECMonsterSetBase@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CMonsterSetBase@@QAE@XZ
_TEXT	SEGMENT
??0CMonsterSetBase@@QAE@XZ PROC				; CMonsterSetBase::CMonsterSetBase, COMDAT
; _this$ = ecx

; 14   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMonsterSetBase@@6B@

; 15   : 	return;
; 16   : }

  00008	c3		 ret	 0
??0CMonsterSetBase@@QAE@XZ ENDP				; CMonsterSetBase::CMonsterSetBase
_TEXT	ENDS
PUBLIC	??1CMonsterSetBase@@UAE@XZ			; CMonsterSetBase::~CMonsterSetBase
; Function compile flags: /Ogtp
;	COMDAT ??1CMonsterSetBase@@UAE@XZ
_TEXT	SEGMENT
??1CMonsterSetBase@@UAE@XZ PROC				; CMonsterSetBase::~CMonsterSetBase, COMDAT
; _this$ = ecx

; 19   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMonsterSetBase@@6B@

; 20   : 	return;
; 21   : }

  00006	c3		 ret	 0
??1CMonsterSetBase@@UAE@XZ ENDP				; CMonsterSetBase::~CMonsterSetBase
_TEXT	ENDS
PUBLIC	?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z	; CMonsterSetBase::SetBoxPosition
; Function compile flags: /Ogtp
;	COMDAT ?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z
_TEXT	SEGMENT
_TableNum$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_ax$ = 16						; size = 4
_ay$ = 20						; size = 4
_aw$ = 24						; size = 4
_ah$ = 28						; size = 4
?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z PROC	; CMonsterSetBase::SetBoxPosition, COMDAT
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 26   : 	this->m_Mp[TableNum].m_MapNumber = mapnumber;

  00003	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]

; 27   : 	this->m_Mp[TableNum].m_W  = aw;

  00006	8a 55 18	 mov	 dl, BYTE PTR _aw$[ebp]
  00009	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0000c	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000f	8a 4d 0c	 mov	 cl, BYTE PTR _mapnumber$[ebp]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 28   : 	this->m_Mp[TableNum].m_H  = ah;

  00015	8a 4d 1c	 mov	 cl, BYTE PTR _ah$[ebp]
  00018	88 50 0d	 mov	 BYTE PTR [eax+13], dl

; 29   : 	this->m_Mp[TableNum].m_X  = ax;

  0001b	8a 55 10	 mov	 dl, BYTE PTR _ax$[ebp]
  0001e	88 48 0e	 mov	 BYTE PTR [eax+14], cl

; 30   : 	this->m_Mp[TableNum].m_Y  = ay;

  00021	8a 4d 14	 mov	 cl, BYTE PTR _ay$[ebp]
  00024	88 50 0a	 mov	 BYTE PTR [eax+10], dl
  00027	88 48 0b	 mov	 BYTE PTR [eax+11], cl

; 31   : }

  0002a	5d		 pop	 ebp
  0002b	c2 18 00	 ret	 24			; 00000018H
?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z ENDP	; CMonsterSetBase::SetBoxPosition
_TEXT	ENDS
PUBLIC	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	_rand:PROC
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN8@GetBoxPosi
	DD	FLAT:$LN9@GetBoxPosi
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z
_TEXT	SEGMENT
_tx$ = -44						; size = 4
_ty$ = -40						; size = 4
_count$ = -36						; size = 4
_h$ = -32						; size = 4
_w$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_mapnumber$ = 8						; size = 4
_ax$ = 12						; size = 4
_ay$ = 16						; size = 4
_aw$ = 20						; size = 4
_ah$ = 24						; size = 4
_mx$ = 28						; size = 4
_my$ = 32						; size = 4
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z PROC	; CMonsterSetBase::GetBoxPosition, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 35   : 	int count = 100 ; 

  00033	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00038	8b 5d 10	 mov	 ebx, DWORD PTR _ay$[ebp]
  0003b	eb 06		 jmp	 SHORT $LN4@GetBoxPosi
  0003d	8d 49 00	 npad	 3
$LL13@GetBoxPosi:
  00040	8b 45 dc	 mov	 eax, DWORD PTR _count$[ebp]
$LN4@GetBoxPosi:

; 36   : 	int w;
; 37   : 	int h;
; 38   : 	int tx; 
; 39   : 	int ty;
; 40   : 	BYTE attr;
; 41   : 
; 42   : 	while ( count-- != 0)

  00043	8b c8		 mov	 ecx, eax
  00045	48		 dec	 eax
  00046	89 45 dc	 mov	 DWORD PTR _count$[ebp], eax
  00049	85 c9		 test	 ecx, ecx
  0004b	0f 84 a6 00 00
	00		 je	 $LN3@GetBoxPosi

; 43   : 	{
; 44   : 		w = aw - ax;

  00051	8b 55 14	 mov	 edx, DWORD PTR _aw$[ebp]
  00054	8b 75 0c	 mov	 esi, DWORD PTR _ax$[ebp]
  00057	2b d6		 sub	 edx, esi
  00059	89 55 e4	 mov	 DWORD PTR _w$[ebp], edx

; 45   : 		h = ah - ay;

  0005c	8b 45 18	 mov	 eax, DWORD PTR _ah$[ebp]
  0005f	2b c3		 sub	 eax, ebx
  00061	89 45 e0	 mov	 DWORD PTR _h$[ebp], eax

; 46   : 
; 47   : 		__try

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 48   : 		{
; 49   : 			tx = ax + (rand()%w);

  0006b	e8 00 00 00 00	 call	 _rand
  00070	8b 4d e4	 mov	 ecx, DWORD PTR _w$[ebp]
  00073	99		 cdq
  00074	f7 f9		 idiv	 ecx
  00076	03 d6		 add	 edx, esi
  00078	89 55 d4	 mov	 DWORD PTR _tx$[ebp], edx

; 50   : 			ty = ay + (rand()%h);

  0007b	e8 00 00 00 00	 call	 _rand
  00080	8b 4d e0	 mov	 ecx, DWORD PTR _h$[ebp]
  00083	99		 cdq
  00084	f7 f9		 idiv	 ecx
  00086	8d 34 13	 lea	 esi, DWORD PTR [ebx+edx]
  00089	89 75 d8	 mov	 DWORD PTR _ty$[ebp], esi

; 51   : 		}

  0008c	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00093	eb 1c		 jmp	 SHORT $LN11@GetBoxPosi
$LN8@GetBoxPosi:
$LN15@GetBoxPosi:

; 52   : 		__except (w=1,h=1,1)

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	89 45 e4	 mov	 DWORD PTR _w$[ebp], eax
  0009d	89 45 e0	 mov	 DWORD PTR _h$[ebp], eax
$LN14@GetBoxPosi:
$LN10@GetBoxPosi:
  000a0	c3		 ret	 0
$LN9@GetBoxPosi:
  000a1	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 53   : 		{
; 54   : 
; 55   : 		}

  000a4	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000ab	8b 5d 10	 mov	 ebx, DWORD PTR _ay$[ebp]
  000ae	8b 75 d8	 mov	 esi, DWORD PTR _ty$[ebp]
$LN11@GetBoxPosi:

; 56   : 
; 57   : 		attr = MapC[mapnumber].GetAttr(tx, ty);

  000b1	56		 push	 esi
  000b2	8b 7d d4	 mov	 edi, DWORD PTR _tx$[ebp]
  000b5	57		 push	 edi
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _mapnumber$[ebp]
  000b9	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  000bf	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  000c5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 58   : 
; 59   : 		if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  000ca	a8 0d		 test	 al, 13			; 0000000dH
  000cc	0f 85 6e ff ff
	ff		 jne	 $LL13@GetBoxPosi

; 60   : 		{
; 61   : 			mx = tx;

  000d2	8b 55 1c	 mov	 edx, DWORD PTR _mx$[ebp]
  000d5	66 89 3a	 mov	 WORD PTR [edx], di

; 62   : 			my = ty;

  000d8	8b 45 20	 mov	 eax, DWORD PTR _my$[ebp]
  000db	66 89 30	 mov	 WORD PTR [eax], si

; 63   : 			return TRUE;

  000de	b8 01 00 00 00	 mov	 eax, 1

; 68   : }

  000e3	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000e6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ed	59		 pop	 ecx
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c2 1c 00	 ret	 28			; 0000001cH
$LN3@GetBoxPosi:

; 64   : 		}
; 65   : 	}
; 66   : 
; 67   : 	return false;

  000f7	33 c0		 xor	 eax, eax

; 68   : }

  000f9	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  000fc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00103	59		 pop	 ecx
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 1c 00	 ret	 28			; 0000001cH
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ENDP	; CMonsterSetBase::GetBoxPosition
_TEXT	ENDS
PUBLIC	??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@	; `string'
PUBLIC	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z	; CMonsterSetBase::GetPosition
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?GetLargeRand@@YAKXZ:PROC			; GetLargeRand
;	COMDAT ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@ DB 'ERROR : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@
CONST	SEGMENT
??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@ DB 'MonsterSetBase.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z
_TEXT	SEGMENT
_count$ = -4						; size = 4
_iRX$154227 = 8						; size = 4
_TableNum$ = 8						; size = 4
tv353 = 12						; size = 4
_MapNumber$ = 12					; size = 2
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z PROC		; CMonsterSetBase::GetPosition, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 72   : 	int count = 100;
; 73   : 	BYTE attr;
; 74   : 	int tx;
; 75   : 	int ty;
; 76   : 	int w;	int h;
; 77   : 	if ( TableNum < 0 || TableNum > OBJ_MAXMONSTER-1 )

  00004	8b 45 08	 mov	 eax, DWORD PTR _TableNum$[ebp]
  00007	c7 45 fc 64 00
	00 00		 mov	 DWORD PTR _count$[ebp], 100 ; 00000064H
  0000e	3d a7 16 00 00	 cmp	 eax, 5799		; 000016a7H
  00013	0f 87 6d 01 00
	00		 ja	 $LN19@GetPositio

; 81   : 	}
; 82   : 
; 83   : 	if ( this->m_Mp[TableNum].m_ArrangeType == 1 || this->m_Mp[TableNum].m_ArrangeType == 3 )

  00019	53		 push	 ebx
  0001a	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0001d	56		 push	 esi
  0001e	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  00021	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  00024	57		 push	 edi
  00025	3c 01		 cmp	 al, 1
  00027	0f 84 b5 00 00
	00		 je	 $LN32@GetPositio
  0002d	3c 03		 cmp	 al, 3
  0002f	0f 84 ad 00 00
	00		 je	 $LN32@GetPositio

; 111  : 				return TRUE;
; 112  : 			}
; 113  : 		}
; 114  : 	}
; 115  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 0 )

  00035	84 c0		 test	 al, al

; 116  : 	{
; 117  : 		x = this->m_Mp[TableNum].m_X;
; 118  : 		y = this->m_Mp[TableNum].m_Y;
; 119  : 		return true;

  00037	0f 84 83 00 00
	00		 je	 $LN38@GetPositio

; 120  : 	}
; 121  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 2 )

  0003d	3c 02		 cmp	 al, 2
  0003f	75 7b		 jne	 SHORT $LN8@GetPositio

; 122  : 	{
; 123  : 		while ( count-- != 0 )

  00041	0f bf 55 0c	 movsx	 edx, WORD PTR _MapNumber$[ebp]
  00045	69 d2 08 07 05
	00		 imul	 edx, 329480		; 00050708H
  0004b	8d 82 00 00 00
	00		 lea	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[edx]

; 134  : 			{
; 135  : 				x = Orx;

  00051	89 45 0c	 mov	 DWORD PTR tv353[ebp], eax
$LL7@GetPositio:

; 124  : 		{
; 125  : 			int Orx = this->m_Mp[TableNum].m_X -3;
; 126  : 			int Ory = this->m_Mp[TableNum].m_Y -3;

  00054	0f b6 7e 0a	 movzx	 edi, BYTE PTR [esi+10]
  00058	0f b6 5e 0b	 movzx	 ebx, BYTE PTR [esi+11]
  0005c	ff 4d fc	 dec	 DWORD PTR _count$[ebp]
  0005f	83 ef 03	 sub	 edi, 3
  00062	83 eb 03	 sub	 ebx, 3

; 127  : 
; 128  : 			Orx += rand() % 7;

  00065	e8 00 00 00 00	 call	 _rand
  0006a	99		 cdq
  0006b	b9 07 00 00 00	 mov	 ecx, 7
  00070	f7 f9		 idiv	 ecx
  00072	03 fa		 add	 edi, edx

; 129  : 			Ory += rand() % 7;

  00074	e8 00 00 00 00	 call	 _rand
  00079	99		 cdq
  0007a	b9 07 00 00 00	 mov	 ecx, 7
  0007f	f7 f9		 idiv	 ecx

; 130  : 
; 131  : 			attr = MapC[MapNumber].GetAttr(Orx, Ory);

  00081	8b 4d 0c	 mov	 ecx, DWORD PTR tv353[ebp]
  00084	03 da		 add	 ebx, edx
  00086	53		 push	 ebx
  00087	57		 push	 edi
  00088	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 132  : 
; 133  : 			if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  0008d	a8 0d		 test	 al, 13			; 0000000dH
  0008f	74 11		 je	 SHORT $LN25@GetPositio

; 122  : 	{
; 123  : 		while ( count-- != 0 )

  00091	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  00095	75 bd		 jne	 SHORT $LL7@GetPositio
$LN28@GetPositio:
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi

; 151  : 	}
; 152  : 
; 153  : 	return false;

  00099	33 c0		 xor	 eax, eax
  0009b	5b		 pop	 ebx

; 154  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 10 00	 ret	 16			; 00000010H
$LN25@GetPositio:

; 134  : 			{
; 135  : 				x = Orx;

  000a2	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]

; 136  : 				y = Ory;

  000a5	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  000a8	66 89 3a	 mov	 WORD PTR [edx], di
  000ab	5f		 pop	 edi
  000ac	66 89 18	 mov	 WORD PTR [eax], bx
  000af	5e		 pop	 esi

; 150  : 		return TRUE;

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	5b		 pop	 ebx

; 154  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c2 10 00	 ret	 16			; 00000010H
$LN8@GetPositio:

; 137  : 				return TRUE;
; 138  : 			}
; 139  : 		}
; 140  : 	}
; 141  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 3 )
; 142  : 	{
; 143  : 		return TRUE;
; 144  : 	}
; 145  : 
; 146  : 	else if ( this->m_Mp[TableNum].m_ArrangeType == 4 )

  000bc	3c 04		 cmp	 al, 4
  000be	75 d7		 jne	 SHORT $LN28@GetPositio
$LN38@GetPositio:

; 147  : 	{
; 148  : 		x = this->m_Mp[TableNum].m_X;

  000c0	0f b6 4e 0a	 movzx	 ecx, BYTE PTR [esi+10]
  000c4	8b 55 10	 mov	 edx, DWORD PTR _x$[ebp]
  000c7	66 89 0a	 mov	 WORD PTR [edx], cx

; 149  : 		y = this->m_Mp[TableNum].m_Y;

  000ca	0f b6 46 0b	 movzx	 eax, BYTE PTR [esi+11]
  000ce	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  000d1	5f		 pop	 edi
  000d2	5e		 pop	 esi
  000d3	66 89 01	 mov	 WORD PTR [ecx], ax

; 150  : 		return TRUE;

  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	5b		 pop	 ebx

; 154  : }

  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 10 00	 ret	 16			; 00000010H
$LN32@GetPositio:

; 84   : 	{
; 85   : 		while ( count-- != 0 )

  000e2	0f bf 55 0c	 movsx	 edx, WORD PTR _MapNumber$[ebp]
  000e6	69 d2 08 07 05
	00		 imul	 edx, 329480		; 00050708H
  000ec	8d 82 00 00 00
	00		 lea	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A[edx]

; 108  : 			{
; 109  : 				x = tx;

  000f2	89 45 0c	 mov	 DWORD PTR tv353[ebp], eax
  000f5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL16@GetPositio:

; 86   : 		{
; 87   : 			w = this->m_Mp[TableNum].m_W - this->m_Mp[TableNum].m_X;

  00100	0f b6 7e 0d	 movzx	 edi, BYTE PTR [esi+13]
  00104	0f b6 4e 0a	 movzx	 ecx, BYTE PTR [esi+10]

; 88   : 			h = this->m_Mp[TableNum].m_H - this->m_Mp[TableNum].m_Y;

  00108	0f b6 56 0b	 movzx	 edx, BYTE PTR [esi+11]
  0010c	0f b6 5e 0e	 movzx	 ebx, BYTE PTR [esi+14]
  00110	ff 4d fc	 dec	 DWORD PTR _count$[ebp]
  00113	2b f9		 sub	 edi, ecx
  00115	2b da		 sub	 ebx, edx

; 89   : 
; 90   : 			if ( w < 1 )

  00117	83 ff 01	 cmp	 edi, 1
  0011a	7d 05		 jge	 SHORT $LN14@GetPositio

; 91   : 			{
; 92   : 				w = 1;

  0011c	bf 01 00 00 00	 mov	 edi, 1
$LN14@GetPositio:

; 93   : 			}
; 94   : 
; 95   : 			if ( h < 1 )

  00121	83 fb 01	 cmp	 ebx, 1
  00124	7d 05		 jge	 SHORT $LN13@GetPositio

; 96   : 			{
; 97   : 				h = 1;

  00126	bb 01 00 00 00	 mov	 ebx, 1
$LN13@GetPositio:

; 98   : 			}
; 99   : 
; 100  : 			int iRX = GetLargeRand()%w;

  0012b	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  00130	33 d2		 xor	 edx, edx
  00132	f7 f7		 div	 edi
  00134	89 55 08	 mov	 DWORD PTR _iRX$154227[ebp], edx

; 101  : 			int iRY = GetLargeRand()%h;

  00137	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  0013c	33 d2		 xor	 edx, edx
  0013e	f7 f3		 div	 ebx

; 102  : 
; 103  : 			tx = this->m_Mp[TableNum].m_X +  iRX;
; 104  : 			ty = this->m_Mp[TableNum].m_Y +  iRY;

  00140	0f b6 5e 0b	 movzx	 ebx, BYTE PTR [esi+11]
  00144	0f b6 7e 0a	 movzx	 edi, BYTE PTR [esi+10]
  00148	03 7d 08	 add	 edi, DWORD PTR _iRX$154227[ebp]

; 105  : 			attr = MapC[MapNumber].GetAttr(tx, ty);

  0014b	8b 4d 0c	 mov	 ecx, DWORD PTR tv353[ebp]
  0014e	03 da		 add	 ebx, edx
  00150	53		 push	 ebx
  00151	57		 push	 edi
  00152	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr

; 106  : 
; 107  : 			if ( ((attr&1) != 1) && ((attr &4) != 4) && ((attr&8) != 8) )

  00157	a8 0d		 test	 al, 13			; 0000000dH
  00159	74 11		 je	 SHORT $LN26@GetPositio

; 84   : 	{
; 85   : 		while ( count-- != 0 )

  0015b	83 7d fc 00	 cmp	 DWORD PTR _count$[ebp], 0
  0015f	75 9f		 jne	 SHORT $LL16@GetPositio

; 151  : 	}
; 152  : 
; 153  : 	return false;

  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	33 c0		 xor	 eax, eax
  00165	5b		 pop	 ebx

; 154  : }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 10 00	 ret	 16			; 00000010H
$LN26@GetPositio:

; 108  : 			{
; 109  : 				x = tx;

  0016c	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]

; 110  : 				y = ty;

  0016f	8b 4d 14	 mov	 ecx, DWORD PTR _y$[ebp]
  00172	66 89 38	 mov	 WORD PTR [eax], di
  00175	5f		 pop	 edi
  00176	5e		 pop	 esi
  00177	66 89 19	 mov	 WORD PTR [ecx], bx

; 150  : 		return TRUE;

  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	5b		 pop	 ebx

; 154  : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 10 00	 ret	 16			; 00000010H
$LN19@GetPositio:

; 78   : 	{
; 79   : 		LogAdd(LOG_BLACK, "ERROR : %s %d", __FILE__, __LINE__ );

  00186	6a 4f		 push	 79			; 0000004fH
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd?$AA@
  00192	6a 00		 push	 0
  00194	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00199	83 c4 10	 add	 esp, 16			; 00000010H

; 80   : 		return false;

  0019c	33 c0		 xor	 eax, eax

; 154  : }

  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c2 10 00	 ret	 16			; 00000010H
?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ENDP		; CMonsterSetBase::GetPosition
_TEXT	ENDS
PUBLIC	??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z		; CMonsterSetBase::LoadSetBase
EXTRN	_fclose:PROC
EXTRN	?CheckMapCanMove@CMapServerManager@@QAEHH@Z:PROC ; CMapServerManager::CheckMapCanMove
EXTRN	?g_MapServerManager@@3VCMapServerManager@@A:BYTE ; g_MapServerManager
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@
CONST	SEGMENT
??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@ DB 'Mo'
	DB	'nster attribute max over %d (%s %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@ DB 'Monst'
	DB	'er attribute max over %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@ DB 'file open error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z
_TEXT	SEGMENT
$T154406 = -8						; size = 4
tv260 = -8						; size = 4
tv250 = -8						; size = 4
tv203 = -8						; size = 4
tv190 = -8						; size = 4
tv173 = -8						; size = 4
tv166 = -8						; size = 4
tv145 = -8						; size = 4
tv144 = -8						; size = 4
tv143 = -8						; size = 4
tv137 = -8						; size = 4
tv136 = -8						; size = 4
tv133 = -8						; size = 4
tv94 = -8						; size = 4
tv92 = -8						; size = 4
tv85 = -8						; size = 4
tv84 = -8						; size = 4
_Type$154260 = -4					; size = 4
_k$154281 = 8						; size = 4
_h$154270 = 8						; size = 4
_filename$ = 8						; size = 4
tv459 = 10						; size = 2
tv423 = 10						; size = 2
tv268 = 10						; size = 2
tv211 = 10						; size = 2
tv180 = 10						; size = 2
tv156 = 10						; size = 2
tv150 = 10						; size = 2
tv95 = 10						; size = 2
?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z PROC		; CMonsterSetBase::LoadSetBase, COMDAT
; _this$ = ecx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	57		 push	 edi

; 158  : 	int Token;
; 159  : 	int rcount;
; 160  : 	int copycount;
; 161  : 	BYTE Sdir;
; 162  : 
; 163  : 	SMDFile = fopen(filename, "r");

  00008	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00010	57		 push	 edi
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 _fopen
  00018	83 c4 08	 add	 esp, 8
  0001b	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax

; 164  : 
; 165  : 	if ( SMDFile == NULL )

  00020	85 c0		 test	 eax, eax
  00022	75 16		 jne	 SHORT $LN28@LoadSetBas

; 166  : 	{
; 167  : 		MsgBox("file open error %s", filename);

  00024	57		 push	 edi
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs?$AA@
  0002a	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0002f	83 c4 08	 add	 esp, 8
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 287  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN28@LoadSetBas:
  0003a	53		 push	 ebx

; 168  : 		return;
; 169  : 	}
; 170  : 
; 171  : 	this->m_Count = 0;

  0003b	c7 86 e4 0f 01
	00 00 00 00 00	 mov	 DWORD PTR [esi+69604], 0

; 172  : 
; 173  : 	while ( true )
; 174  : 	{
; 175  : 		Token = GetToken();

  00045	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 176  : 
; 177  : 		if ( Token == 2 )

  0004a	83 f8 02	 cmp	 eax, 2
  0004d	0f 84 c8 04 00
	00		 je	 $LN40@LoadSetBas
$LL27@LoadSetBas:

; 178  : 			break;
; 179  : 
; 180  : 		if ( Token == 1 )

  00053	83 f8 01	 cmp	 eax, 1
  00056	0f 85 b1 04 00
	00		 jne	 $LN56@LoadSetBas

; 181  : 		{
; 182  : 			int Type = TokenNumber;

  0005c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00062	e8 00 00 00 00	 call	 __ftol2_sse
  00067	8b d8		 mov	 ebx, eax
  00069	89 5d fc	 mov	 DWORD PTR _Type$154260[ebp], ebx

; 183  : 
; 184  : 			while ( true )
; 185  : 			{
; 186  : 				Token = GetToken();

  0006c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 187  : 
; 188  : 				if ( strcmp("end", TokenString) == 0 )

  00071	bf 00 00 00 00	 mov	 edi, OFFSET _TokenString
  00076	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0007b	eb 03 8d 49 00	 npad	 5
$LL42@LoadSetBas:
  00080	8a 08		 mov	 cl, BYTE PTR [eax]
  00082	3a 0f		 cmp	 cl, BYTE PTR [edi]
  00084	75 1a		 jne	 SHORT $LN43@LoadSetBas
  00086	84 c9		 test	 cl, cl
  00088	74 12		 je	 SHORT $LN44@LoadSetBas
  0008a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0008d	3a 4f 01	 cmp	 cl, BYTE PTR [edi+1]
  00090	75 0e		 jne	 SHORT $LN43@LoadSetBas
  00092	83 c0 02	 add	 eax, 2
  00095	83 c7 02	 add	 edi, 2
  00098	84 c9		 test	 cl, cl
  0009a	75 e4		 jne	 SHORT $LL42@LoadSetBas
$LN44@LoadSetBas:
  0009c	33 c0		 xor	 eax, eax
  0009e	eb 05		 jmp	 SHORT $LN45@LoadSetBas
$LN43@LoadSetBas:
  000a0	1b c0		 sbb	 eax, eax
  000a2	83 d8 ff	 sbb	 eax, -1
$LN45@LoadSetBas:
  000a5	85 c0		 test	 eax, eax
  000a7	0f 84 60 04 00
	00		 je	 $LN56@LoadSetBas
  000ad	eb 04		 jmp	 SHORT $LN23@LoadSetBas
  000af	90		 npad	 1
$LL54@LoadSetBas:
  000b0	8b 5d fc	 mov	 ebx, DWORD PTR _Type$154260[ebp]
$LN23@LoadSetBas:

; 189  : 					break;
; 190  : 				
; 191  : 				this->m_Mp[this->m_Count].m_Type = TokenNumber;

  000b3	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000b9	d9 7d 0a	 fnstcw	 WORD PTR tv150[ebp]
  000bc	0f b7 45 0a	 movzx	 eax, WORD PTR tv150[ebp]
  000c0	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000c5	89 45 f8	 mov	 DWORD PTR tv145[ebp], eax
  000c8	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  000ce	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000d1	d9 6d f8	 fldcw	 WORD PTR tv145[ebp]
  000d4	db 5d f8	 fistp	 DWORD PTR tv144[ebp]
  000d7	66 8b 4d f8	 mov	 cx, WORD PTR tv144[ebp]
  000db	66 89 4c 96 06	 mov	 WORD PTR [esi+edx*4+6], cx
  000e0	d9 6d 0a	 fldcw	 WORD PTR tv150[ebp]

; 192  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_MapNumber = TokenNumber;

  000e3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000e8	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  000ee	d9 7d 0a	 fnstcw	 WORD PTR tv423[ebp]
  000f1	0f b7 45 0a	 movzx	 eax, WORD PTR tv423[ebp]
  000f5	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000fa	89 45 f8	 mov	 DWORD PTR tv137[ebp], eax
  000fd	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00103	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00106	d9 6d f8	 fldcw	 WORD PTR tv137[ebp]
  00109	db 5d f8	 fistp	 DWORD PTR tv133[ebp]
  0010c	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv133[ebp]
  00110	88 4c 96 08	 mov	 BYTE PTR [esi+edx*4+8], cl
  00114	d9 6d 0a	 fldcw	 WORD PTR tv423[ebp]

; 193  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_Dis = TokenNumber;

  00117	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0011c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00122	d9 7d 0a	 fnstcw	 WORD PTR tv459[ebp]
  00125	0f b7 45 0a	 movzx	 eax, WORD PTR tv459[ebp]
  00129	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0012e	89 45 f8	 mov	 DWORD PTR tv94[ebp], eax
  00131	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00137	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0013a	d9 6d f8	 fldcw	 WORD PTR tv94[ebp]
  0013d	db 5d f8	 fistp	 DWORD PTR tv92[ebp]
  00140	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv92[ebp]
  00144	88 4c 96 09	 mov	 BYTE PTR [esi+edx*4+9], cl
  00148	d9 6d 0a	 fldcw	 WORD PTR tv459[ebp]

; 194  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_X = TokenNumber;

  0014b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00150	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00156	d9 7d 0a	 fnstcw	 WORD PTR tv95[ebp]
  00159	0f b7 45 0a	 movzx	 eax, WORD PTR tv95[ebp]
  0015d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00162	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00165	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0016b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0016e	d9 6d f8	 fldcw	 WORD PTR tv85[ebp]
  00171	db 5d f8	 fistp	 DWORD PTR tv84[ebp]
  00174	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv84[ebp]
  00178	88 4c 96 0a	 mov	 BYTE PTR [esi+edx*4+10], cl
  0017c	d9 6d 0a	 fldcw	 WORD PTR tv95[ebp]

; 195  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_Y = TokenNumber;

  0017f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00184	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0018a	d9 7d 0a	 fnstcw	 WORD PTR tv268[ebp]
  0018d	0f b7 45 0a	 movzx	 eax, WORD PTR tv268[ebp]
  00191	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00196	89 45 f8	 mov	 DWORD PTR tv260[ebp], eax
  00199	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0019f	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001a2	d9 6d f8	 fldcw	 WORD PTR tv260[ebp]
  001a5	db 5d f8	 fistp	 DWORD PTR tv250[ebp]
  001a8	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv250[ebp]
  001ac	88 4c 96 0b	 mov	 BYTE PTR [esi+edx*4+11], cl

; 196  : 				this->m_Mp[this->m_Count].m_ArrangeType = Type;

  001b0	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  001b6	d9 6d 0a	 fldcw	 WORD PTR tv268[ebp]
  001b9	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  001bc	88 5c 86 04	 mov	 BYTE PTR [esi+eax*4+4], bl

; 197  : 
; 198  : 				if ( Type == 1 || Type == 3 )

  001c0	83 fb 01	 cmp	 ebx, 1
  001c3	0f 84 bd 00 00
	00		 je	 $LN50@LoadSetBas
  001c9	83 fb 03	 cmp	 ebx, 3
  001cc	0f 84 b4 00 00
	00		 je	 $LN50@LoadSetBas

; 202  : 				}
; 203  : 				else if ( Type == 2 )
; 204  : 				{
; 205  : 					this->m_Mp[this->m_Count].m_W = 0;

  001d2	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  001d8	83 fb 02	 cmp	 ebx, 2
  001db	75 74		 jne	 SHORT $LN17@LoadSetBas
  001dd	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  001e0	c6 44 8e 0d 00	 mov	 BYTE PTR [esi+ecx*4+13], 0

; 206  : 					this->m_Mp[this->m_Count].m_H = 0;

  001e5	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  001eb	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001ee	c6 44 96 0e 00	 mov	 BYTE PTR [esi+edx*4+14], 0

; 207  : 
; 208  : 					int w = this->m_Mp[this->m_Count].m_X - 3;

  001f3	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  001f9	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  001fc	0f b6 5c 86 0a	 movzx	 ebx, BYTE PTR [esi+eax*4+10]
  00201	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]

; 209  : 					int h = this->m_Mp[this->m_Count].m_Y - 3;

  00204	0f b6 40 0b	 movzx	 eax, BYTE PTR [eax+11]
  00208	83 e8 03	 sub	 eax, 3
  0020b	83 eb 03	 sub	 ebx, 3
  0020e	89 45 08	 mov	 DWORD PTR _h$154270[ebp], eax

; 210  : 
; 211  : 					w += rand() % 7;

  00211	e8 00 00 00 00	 call	 _rand
  00216	99		 cdq
  00217	b9 07 00 00 00	 mov	 ecx, 7
  0021c	f7 f9		 idiv	 ecx
  0021e	03 da		 add	 ebx, edx

; 212  : 					h += rand() % 7;

  00220	e8 00 00 00 00	 call	 _rand
  00225	99		 cdq
  00226	b9 07 00 00 00	 mov	 ecx, 7
  0022b	f7 f9		 idiv	 ecx

; 213  : 
; 214  : 					this->m_Mp[this->m_Count].m_X = w;

  0022d	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00233	8b 4d 08	 mov	 ecx, DWORD PTR _h$154270[ebp]
  00236	03 ca		 add	 ecx, edx
  00238	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0023b	88 5c 96 0a	 mov	 BYTE PTR [esi+edx*4+10], bl

; 215  : 					this->m_Mp[this->m_Count].m_Y = h;

  0023f	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00245	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00248	88 4c 86 0b	 mov	 BYTE PTR [esi+eax*4+11], cl
  0024c	e9 9b 00 00 00	 jmp	 $LN14@LoadSetBas
$LN17@LoadSetBas:

; 216  : 				}
; 217  : 				else if ( Type == 4 )

  00251	83 fb 04	 cmp	 ebx, 4
  00254	75 18		 jne	 SHORT $LN15@LoadSetBas

; 218  : 				{
; 219  : 					this->m_Mp[this->m_Count].m_W = 0;

  00256	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00259	c6 44 8e 0d 00	 mov	 BYTE PTR [esi+ecx*4+13], 0

; 220  : 					this->m_Mp[this->m_Count].m_H = 0;

  0025e	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00264	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00267	c6 44 96 0e 00	 mov	 BYTE PTR [esi+edx*4+14], 0

; 221  : 				}
; 222  : 				else

  0026c	eb 7e		 jmp	 SHORT $LN14@LoadSetBas
$LN15@LoadSetBas:

; 223  : 				{
; 224  : 					this->m_Mp[this->m_Count].m_W = 0;

  0026e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00271	c6 44 86 0d 00	 mov	 BYTE PTR [esi+eax*4+13], 0

; 225  : 					this->m_Mp[this->m_Count].m_H = 0;

  00276	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0027c	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0027f	c6 44 8e 0e 00	 mov	 BYTE PTR [esi+ecx*4+14], 0
  00284	eb 66		 jmp	 SHORT $LN14@LoadSetBas
$LN50@LoadSetBas:

; 199  : 				{
; 200  : 					Token = GetToken();	this->m_Mp[this->m_Count].m_W = TokenNumber;

  00286	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0028b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00291	d9 7d 0a	 fnstcw	 WORD PTR tv211[ebp]
  00294	0f b7 45 0a	 movzx	 eax, WORD PTR tv211[ebp]
  00298	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0029d	89 45 f8	 mov	 DWORD PTR tv203[ebp], eax
  002a0	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  002a6	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  002a9	d9 6d f8	 fldcw	 WORD PTR tv203[ebp]
  002ac	db 5d f8	 fistp	 DWORD PTR tv190[ebp]
  002af	8a 55 f8	 mov	 dl, BYTE PTR tv190[ebp]
  002b2	88 54 86 0d	 mov	 BYTE PTR [esi+eax*4+13], dl
  002b6	d9 6d 0a	 fldcw	 WORD PTR tv211[ebp]

; 201  : 					Token = GetToken();	this->m_Mp[this->m_Count].m_H = TokenNumber;

  002b9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002be	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002c4	d9 7d 0a	 fnstcw	 WORD PTR tv180[ebp]
  002c7	0f b7 45 0a	 movzx	 eax, WORD PTR tv180[ebp]
  002cb	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002d0	89 45 f8	 mov	 DWORD PTR tv173[ebp], eax
  002d3	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  002d9	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  002dc	d9 6d f8	 fldcw	 WORD PTR tv173[ebp]
  002df	db 5d f8	 fistp	 DWORD PTR tv166[ebp]
  002e2	8a 4d f8	 mov	 cl, BYTE PTR tv166[ebp]
  002e5	88 4c 96 0e	 mov	 BYTE PTR [esi+edx*4+14], cl
  002e9	d9 6d 0a	 fldcw	 WORD PTR tv180[ebp]
$LN14@LoadSetBas:

; 226  : 				}
; 227  : 
; 228  : 				Token = GetToken();	this->m_Mp[this->m_Count].m_Dir = TokenNumber;

  002ec	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002f1	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  002f7	d9 7d 0a	 fnstcw	 WORD PTR tv156[ebp]
  002fa	0f b7 45 0a	 movzx	 eax, WORD PTR tv156[ebp]
  002fe	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00303	89 45 f8	 mov	 DWORD PTR tv143[ebp], eax
  00306	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0030c	8d 54 40 03	 lea	 edx, DWORD PTR [eax+eax*2+3]
  00310	d9 6d f8	 fldcw	 WORD PTR tv143[ebp]
  00313	db 5d f8	 fistp	 DWORD PTR tv136[ebp]
  00316	8a 4d f8	 mov	 cl, BYTE PTR tv136[ebp]
  00319	88 0c 96	 mov	 BYTE PTR [esi+edx*4], cl

; 229  : 				Sdir = this->m_Mp[this->m_Count].m_Dir;

  0031c	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00322	d9 6d 0a	 fldcw	 WORD PTR tv156[ebp]
  00325	8d 44 40 03	 lea	 eax, DWORD PTR [eax+eax*2+3]
  00329	8a 1c 86	 mov	 bl, BYTE PTR [esi+eax*4]

; 230  : 
; 231  : 				if ( this->m_Mp[this->m_Count].m_Dir == (BYTE)-1 )

  0032c	80 fb ff	 cmp	 bl, 255			; 000000ffH
  0032f	75 21		 jne	 SHORT $LN13@LoadSetBas

; 232  : 					this->m_Mp[this->m_Count].m_Dir = rand() % 8;

  00331	e8 00 00 00 00	 call	 _rand
  00336	8b c8		 mov	 ecx, eax
  00338	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  0033e	79 05		 jns	 SHORT $LN58@LoadSetBas
  00340	49		 dec	 ecx
  00341	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00344	41		 inc	 ecx
$LN58@LoadSetBas:
  00345	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0034b	8d 54 40 03	 lea	 edx, DWORD PTR [eax+eax*2+3]
  0034f	88 0c 96	 mov	 BYTE PTR [esi+edx*4], cl
$LN13@LoadSetBas:

; 233  : 
; 234  : 				if ( Type == 1 || Type == 3 )

  00352	8b 45 fc	 mov	 eax, DWORD PTR _Type$154260[ebp]
  00355	83 f8 01	 cmp	 eax, 1
  00358	74 09		 je	 SHORT $LN11@LoadSetBas
  0035a	83 f8 03	 cmp	 eax, 3
  0035d	0f 85 36 01 00
	00		 jne	 $LN51@LoadSetBas
$LN11@LoadSetBas:

; 235  : 				{
; 236  : 					BYTE w = this->m_Mp[this->m_Count].m_X;
; 237  : 					BYTE h = this->m_Mp[this->m_Count].m_Y;
; 238  : 					Token = GetToken();	rcount = TokenNumber;

  00363	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00368	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0036e	e8 00 00 00 00	 call	 __ftol2_sse

; 239  : 					copycount = this->m_Count;

  00373	8b 8e e4 0f 01
	00		 mov	 ecx, DWORD PTR [esi+69604]

; 240  : 
; 241  : 					if ( rcount > 1 )

  00379	83 f8 01	 cmp	 eax, 1
  0037c	0f 8e 17 01 00
	00		 jle	 $LN51@LoadSetBas

; 242  : 					{
; 243  : 						for ( int k = 0; k<rcount-1 ; k++ )

  00382	48		 dec	 eax
  00383	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _k$154281[ebp], 0
  0038a	89 45 f8	 mov	 DWORD PTR $T154406[ebp], eax
  0038d	85 c0		 test	 eax, eax
  0038f	0f 8e 04 01 00
	00		 jle	 $LN51@LoadSetBas
  00395	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00398	8d 3c 86	 lea	 edi, DWORD PTR [esi+eax*4]
  0039b	eb 03 8d 49 00	 npad	 5
$LL9@LoadSetBas:

; 244  : 						{
; 245  : 							if ( g_MapServerManager.CheckMapCanMove(this->m_Mp[copycount].m_MapNumber) == FALSE )

  003a0	0f b6 4f 08	 movzx	 ecx, BYTE PTR [edi+8]
  003a4	51		 push	 ecx
  003a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  003aa	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  003af	85 c0		 test	 eax, eax
  003b1	0f 84 e2 00 00
	00		 je	 $LN51@LoadSetBas

; 246  : 								break;
; 247  : 							this->m_Count++;

  003b7	ff 86 e4 0f 01
	00		 inc	 DWORD PTR [esi+69604]
  003bd	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]

; 248  : 							if ( this->m_Count > OBJ_MAXMONSTER-1 )

  003c3	3d a7 16 00 00	 cmp	 eax, 5799		; 000016a7H
  003c8	0f 8f 65 01 00
	00		 jg	 $LN37@LoadSetBas

; 252  : 								return;
; 253  : 							}
; 254  : 
; 255  : 							this->m_Mp[this->m_Count].m_Dis = this->m_Mp[copycount].m_Dis;

  003ce	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  003d1	0f b6 47 09	 movzx	 eax, BYTE PTR [edi+9]
  003d5	88 44 96 09	 mov	 BYTE PTR [esi+edx*4+9], al

; 256  : 							this->m_Mp[this->m_Count].m_Type = this->m_Mp[copycount].m_Type;

  003d9	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  003df	66 8b 57 06	 mov	 dx, WORD PTR [edi+6]
  003e3	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  003e6	66 89 54 8e 06	 mov	 WORD PTR [esi+ecx*4+6], dx

; 257  : 							this->m_Mp[this->m_Count].m_MapNumber = this->m_Mp[copycount].m_MapNumber;

  003eb	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  003f1	0f b6 4f 08	 movzx	 ecx, BYTE PTR [edi+8]
  003f5	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003f8	88 4c 86 08	 mov	 BYTE PTR [esi+eax*4+8], cl

; 258  : 							this->m_Mp[this->m_Count].m_W = this->m_Mp[copycount].m_W;

  003fc	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00402	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00405	0f b6 47 0d	 movzx	 eax, BYTE PTR [edi+13]
  00409	88 44 96 0d	 mov	 BYTE PTR [esi+edx*4+13], al

; 259  : 							this->m_Mp[this->m_Count].m_H = this->m_Mp[copycount].m_H;

  0040d	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00413	0f b6 57 0e	 movzx	 edx, BYTE PTR [edi+14]
  00417	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0041a	88 54 8e 0e	 mov	 BYTE PTR [esi+ecx*4+14], dl

; 260  : 							this->m_Mp[this->m_Count].m_X = this->m_Mp[copycount].m_X;

  0041e	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00424	0f b6 4f 0a	 movzx	 ecx, BYTE PTR [edi+10]
  00428	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0042b	88 4c 86 0a	 mov	 BYTE PTR [esi+eax*4+10], cl

; 261  : 							this->m_Mp[this->m_Count].m_Y = this->m_Mp[copycount].m_Y;

  0042f	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00435	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00438	0f b6 47 0b	 movzx	 eax, BYTE PTR [edi+11]
  0043c	88 44 96 0b	 mov	 BYTE PTR [esi+edx*4+11], al

; 262  : 							this->m_Mp[this->m_Count].m_ArrangeType = this->m_Mp[copycount].m_ArrangeType;

  00440	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00446	0f b6 57 04	 movzx	 edx, BYTE PTR [edi+4]
  0044a	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0044d	88 54 8e 04	 mov	 BYTE PTR [esi+ecx*4+4], dl

; 263  : 
; 264  : 							if ( Sdir == (BYTE)-1 )

  00451	80 fb ff	 cmp	 bl, 255			; 000000ffH
  00454	75 23		 jne	 SHORT $LN4@LoadSetBas

; 265  : 								this->m_Mp[this->m_Count].m_Dir = rand() % 8;

  00456	e8 00 00 00 00	 call	 _rand
  0045b	8b c8		 mov	 ecx, eax
  0045d	81 e1 07 00 00
	80		 and	 ecx, -2147483641	; 80000007H
  00463	79 05		 jns	 SHORT $LN59@LoadSetBas
  00465	49		 dec	 ecx
  00466	83 c9 f8	 or	 ecx, -8			; fffffff8H
  00469	41		 inc	 ecx
$LN59@LoadSetBas:
  0046a	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  00470	8d 54 40 03	 lea	 edx, DWORD PTR [eax+eax*2+3]
  00474	88 0c 96	 mov	 BYTE PTR [esi+edx*4], cl

; 266  : 							else

  00477	eb 10		 jmp	 SHORT $LN8@LoadSetBas
$LN4@LoadSetBas:

; 267  : 								this->m_Mp[this->m_Count].m_Dir = this->m_Mp[copycount].m_Dir;

  00479	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0047f	8a 4f 0c	 mov	 cl, BYTE PTR [edi+12]
  00482	8d 44 40 03	 lea	 eax, DWORD PTR [eax+eax*2+3]
  00486	88 0c 86	 mov	 BYTE PTR [esi+eax*4], cl
$LN8@LoadSetBas:

; 242  : 					{
; 243  : 						for ( int k = 0; k<rcount-1 ; k++ )

  00489	8b 45 08	 mov	 eax, DWORD PTR _k$154281[ebp]
  0048c	40		 inc	 eax
  0048d	89 45 08	 mov	 DWORD PTR _k$154281[ebp], eax
  00490	3b 45 f8	 cmp	 eax, DWORD PTR $T154406[ebp]
  00493	0f 8c 07 ff ff
	ff		 jl	 $LL9@LoadSetBas
$LN51@LoadSetBas:

; 268  : 						}
; 269  : 					}
; 270  : 				}
; 271  : 
; 272  : 				if ( g_MapServerManager.CheckMapCanMove(this->m_Mp[this->m_Count].m_MapNumber) == FALSE )

  00499	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]
  0049f	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  004a2	0f b6 44 96 08	 movzx	 eax, BYTE PTR [esi+edx*4+8]
  004a7	50		 push	 eax
  004a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MapServerManager@@3VCMapServerManager@@A ; g_MapServerManager
  004ad	e8 00 00 00 00	 call	 ?CheckMapCanMove@CMapServerManager@@QAEHH@Z ; CMapServerManager::CheckMapCanMove
  004b2	85 c0		 test	 eax, eax
  004b4	74 17		 je	 SHORT $LN1@LoadSetBas

; 273  : 					continue;
; 274  : 
; 275  : 				this->m_Count++;

  004b6	ff 86 e4 0f 01
	00		 inc	 DWORD PTR [esi+69604]
  004bc	8b 86 e4 0f 01
	00		 mov	 eax, DWORD PTR [esi+69604]

; 276  : 				if ( this->m_Count > OBJ_MAXMONSTER-1 )

  004c2	3d a7 16 00 00	 cmp	 eax, 5799		; 000016a7H
  004c7	0f 8f 92 00 00
	00		 jg	 $LN39@LoadSetBas
$LN1@LoadSetBas:

; 183  : 
; 184  : 			while ( true )
; 185  : 			{
; 186  : 				Token = GetToken();

  004cd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 187  : 
; 188  : 				if ( strcmp("end", TokenString) == 0 )

  004d2	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  004d7	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  004dc	8d 64 24 00	 npad	 4
$LL46@LoadSetBas:
  004e0	8a 10		 mov	 dl, BYTE PTR [eax]
  004e2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  004e4	75 1a		 jne	 SHORT $LN47@LoadSetBas
  004e6	84 d2		 test	 dl, dl
  004e8	74 12		 je	 SHORT $LN48@LoadSetBas
  004ea	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  004ed	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  004f0	75 0e		 jne	 SHORT $LN47@LoadSetBas
  004f2	83 c0 02	 add	 eax, 2
  004f5	83 c1 02	 add	 ecx, 2
  004f8	84 d2		 test	 dl, dl
  004fa	75 e4		 jne	 SHORT $LL46@LoadSetBas
$LN48@LoadSetBas:
  004fc	33 c0		 xor	 eax, eax
  004fe	eb 05		 jmp	 SHORT $LN49@LoadSetBas
$LN47@LoadSetBas:
  00500	1b c0		 sbb	 eax, eax
  00502	83 d8 ff	 sbb	 eax, -1
$LN49@LoadSetBas:
  00505	85 c0		 test	 eax, eax
  00507	0f 85 a3 fb ff
	ff		 jne	 $LL54@LoadSetBas
$LN56@LoadSetBas:

; 172  : 
; 173  : 	while ( true )
; 174  : 	{
; 175  : 		Token = GetToken();

  0050d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 176  : 
; 177  : 		if ( Token == 2 )

  00512	83 f8 02	 cmp	 eax, 2
  00515	0f 85 38 fb ff
	ff		 jne	 $LL27@LoadSetBas
$LN40@LoadSetBas:

; 280  : 					return;
; 281  : 				}
; 282  : 			}
; 283  : 		}
; 284  : 	}
; 285  : 
; 286  : 	fclose(SMDFile);

  0051b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00521	51		 push	 ecx
  00522	e8 00 00 00 00	 call	 _fclose
  00527	83 c4 04	 add	 esp, 4
  0052a	5b		 pop	 ebx
  0052b	5f		 pop	 edi
  0052c	5e		 pop	 esi

; 287  : }

  0052d	8b e5		 mov	 esp, ebp
  0052f	5d		 pop	 ebp
  00530	c2 04 00	 ret	 4
$LN37@LoadSetBas:

; 249  : 							{
; 250  : 								MsgBox("Monster attribute max over %s %d", __FILE__, __LINE__);

  00533	68 fa 00 00 00	 push	 250			; 000000faH
  00538	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CFd@
  00542	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 251  : 								fclose(SMDFile);

  00547	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0054d	52		 push	 edx
  0054e	e8 00 00 00 00	 call	 _fclose
  00553	83 c4 10	 add	 esp, 16			; 00000010H
  00556	5b		 pop	 ebx
  00557	5f		 pop	 edi
  00558	5e		 pop	 esi

; 287  : }

  00559	8b e5		 mov	 esp, ebp
  0055b	5d		 pop	 ebp
  0055c	c2 04 00	 ret	 4
$LN39@LoadSetBas:

; 277  : 				{
; 278  : 					MsgBox("Monster attribute max over %d (%s %d)", this->m_Count, __FILE__, __LINE__);

  0055f	68 16 01 00 00	 push	 278			; 00000116H
  00564	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EANIJDJ@MonsterSetBase?4cpp?$AA@
  00569	50		 push	 eax
  0056a	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI?$CF@
  0056f	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 279  : 					fclose(SMDFile);

  00574	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00579	50		 push	 eax
  0057a	e8 00 00 00 00	 call	 _fclose
  0057f	83 c4 14	 add	 esp, 20			; 00000014H
  00582	5b		 pop	 ebx
  00583	5f		 pop	 edi
  00584	5e		 pop	 esi

; 287  : }

  00585	8b e5		 mov	 esp, ebp
  00587	5d		 pop	 ebp
  00588	c2 04 00	 ret	 4
?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z ENDP		; CMonsterSetBase::LoadSetBase
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCMonsterSetBase@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMonsterSetBase@@UAEPAXI@Z PROC			; CMonsterSetBase::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMonsterSetBase@@UAE@XZ ; CMonsterSetBase::~CMonsterSetBase
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMonsterSetBase@@UAEPAXI@Z ENDP			; CMonsterSetBase::`scalar deleting destructor'
_TEXT	ENDS
END
