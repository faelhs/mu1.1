; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\ObjBaseAttack.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_DATA	ENDS
PUBLIC	??_7CObjBaseAttack@@6B@				; CObjBaseAttack::`vftable'
PUBLIC	??0CObjBaseAttack@@QAE@XZ			; CObjBaseAttack::CObjBaseAttack
PUBLIC	??_R4CObjBaseAttack@@6B@			; CObjBaseAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCObjBaseAttack@@@8			; CObjBaseAttack `RTTI Type Descriptor'
PUBLIC	??_R3CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObjBaseAttack@@8			; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z ; CObjBaseAttack::MissCheck
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECObjBaseAttack@@UAEPAXI@Z:PROC		; CObjBaseAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CObjBaseAttack@@8
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\objbaseattack.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjBaseAttack@@8 DD FLAT:??_R0?AVCObjBaseAttack@@@8 ; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CObjBaseAttack@@8
rdata$r	SEGMENT
??_R2CObjBaseAttack@@8 DD FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8 ; CObjBaseAttack::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjBaseAttack@@8
rdata$r	SEGMENT
??_R3CObjBaseAttack@@8 DD 00H				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjBaseAttack@@@8
_DATA	SEGMENT
??_R0?AVCObjBaseAttack@@@8 DD FLAT:??_7type_info@@6B@	; CObjBaseAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjBaseAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CObjBaseAttack@@6B@
rdata$r	SEGMENT
??_R4CObjBaseAttack@@6B@ DD 00H				; CObjBaseAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCObjBaseAttack@@@8
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CObjBaseAttack@@6B@
CONST	SEGMENT
??_7CObjBaseAttack@@6B@ DD FLAT:??_R4CObjBaseAttack@@6B@ ; CObjBaseAttack::`vftable'
	DD	FLAT:??_ECObjBaseAttack@@UAEPAXI@Z
	DD	FLAT:?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CObjBaseAttack@@QAE@XZ
_TEXT	SEGMENT
??0CObjBaseAttack@@QAE@XZ PROC				; CObjBaseAttack::CObjBaseAttack, COMDAT
; _this$ = ecx

; 15   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CObjBaseAttack@@6B@

; 16   : 	return;
; 17   : }

  00008	c3		 ret	 0
??0CObjBaseAttack@@QAE@XZ ENDP				; CObjBaseAttack::CObjBaseAttack
_TEXT	ENDS
PUBLIC	??1CObjBaseAttack@@UAE@XZ			; CObjBaseAttack::~CObjBaseAttack
; Function compile flags: /Ogtp
;	COMDAT ??1CObjBaseAttack@@UAE@XZ
_TEXT	SEGMENT
??1CObjBaseAttack@@UAE@XZ PROC				; CObjBaseAttack::~CObjBaseAttack, COMDAT
; _this$ = ecx

; 21   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CObjBaseAttack@@6B@

; 22   : 	return;
; 23   : }

  00006	c3		 ret	 0
??1CObjBaseAttack@@UAE@XZ ENDP				; CObjBaseAttack::~CObjBaseAttack
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3f800000
PUBLIC	?DecreaseArrow@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjBaseAttack::DecreaseArrow
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?DecreaseArrow@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv263 = -4						; size = 4
tv261 = -4						; size = 4
tv237 = -4						; size = 4
tv235 = -4						; size = 4
tv273 = 8						; size = 4
tv260 = 8						; size = 4
_lpObj$ = 8						; size = 4
tv266 = 10						; size = 2
tv241 = 10						; size = 2
?DecreaseArrow@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CObjBaseAttack::DecreaseArrow, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 27   : 	if ( lpObj->Class == CLASS_ELF && lpObj->Type == OBJ_USER )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	66 83 bf 98 00
	00 00 02	 cmp	 WORD PTR [edi+152], 2
  00011	0f 85 bf 01 00
	00		 jne	 $LN1@DecreaseAr
  00017	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  0001c	0f 85 b4 01 00
	00		 jne	 $LN1@DecreaseAr

; 28   : 	{
; 29   : 		CItem * Right = &lpObj->pInventory[0];

  00022	8b b7 8c 0c 00
	00		 mov	 esi, DWORD PTR [edi+3212]

; 30   : 		CItem * Left  = &lpObj->pInventory[1];
; 31   : 
; 32   : 		if ( (Right->m_Type >= ITEMGET(4,8) && Right->m_Type <= ITEMGET(4,14)) ||
; 33   : 			  Right->m_Type == ITEMGET(4,16) || Right->m_Type == ITEMGET(4,18) ||
; 34   : 			  Right->m_Type == ITEMGET(4,19) )

  00028	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  0002c	b8 08 08 00 00	 mov	 eax, 2056		; 00000808H
  00031	66 3b c8	 cmp	 cx, ax
  00034	7c 0e		 jl	 SHORT $LN13@DecreaseAr
  00036	ba 0e 08 00 00	 mov	 edx, 2062		; 0000080eH
  0003b	66 3b ca	 cmp	 cx, dx
  0003e	0f 8e f6 00 00
	00		 jle	 $LN14@DecreaseAr
$LN13@DecreaseAr:
  00044	b8 10 08 00 00	 mov	 eax, 2064		; 00000810H
  00049	66 3b c8	 cmp	 cx, ax
  0004c	0f 84 e8 00 00
	00		 je	 $LN14@DecreaseAr
  00052	ba 12 08 00 00	 mov	 edx, 2066		; 00000812H
  00057	66 3b ca	 cmp	 cx, dx
  0005a	0f 84 da 00 00
	00		 je	 $LN14@DecreaseAr
  00060	b8 13 08 00 00	 mov	 eax, 2067		; 00000813H
  00065	66 3b c8	 cmp	 cx, ax
  00068	0f 84 cc 00 00
	00		 je	 $LN14@DecreaseAr

; 50   : 				}
; 51   : 			}
; 52   : 			else
; 53   : 			{
; 54   : 				return FALSE;
; 55   : 			}
; 56   : 		}
; 57   : 		else if ( (Left->m_Type >= ITEMGET(4,0) && Left->m_Type <= ITEMGET(4,6) ) ||
; 58   : 				   Left->m_Type == ITEMGET(4,17) ||
; 59   : 				   Left->m_Type == ITEMGET(4,20) ||
; 60   : 				   Left->m_Type == ITEMGET(4,21) ||
; 61   : 				   Left->m_Type == ITEMGET(4,22) )

  0006e	0f b7 86 ae 00
	00 00		 movzx	 eax, WORD PTR [esi+174]
  00075	ba 00 08 00 00	 mov	 edx, 2048		; 00000800H
  0007a	66 3b c2	 cmp	 ax, dx
  0007d	7c 0a		 jl	 SHORT $LN5@DecreaseAr
  0007f	ba 06 08 00 00	 mov	 edx, 2054		; 00000806H
  00084	66 3b c2	 cmp	 ax, dx
  00087	7e 2c		 jle	 SHORT $LN6@DecreaseAr
$LN5@DecreaseAr:
  00089	ba 11 08 00 00	 mov	 edx, 2065		; 00000811H
  0008e	66 3b c2	 cmp	 ax, dx
  00091	74 22		 je	 SHORT $LN6@DecreaseAr
  00093	ba 14 08 00 00	 mov	 edx, 2068		; 00000814H
  00098	66 3b c2	 cmp	 ax, dx
  0009b	74 18		 je	 SHORT $LN6@DecreaseAr
  0009d	ba 15 08 00 00	 mov	 edx, 2069		; 00000815H
  000a2	66 3b c2	 cmp	 ax, dx
  000a5	74 0e		 je	 SHORT $LN6@DecreaseAr
  000a7	ba 16 08 00 00	 mov	 edx, 2070		; 00000816H
  000ac	66 3b c2	 cmp	 ax, dx
  000af	0f 85 21 01 00
	00		 jne	 $LN1@DecreaseAr
$LN6@DecreaseAr:

; 62   : 		{
; 63   : 			if ( Right->m_Type == ITEMGET(4,15) )

  000b5	b8 0f 08 00 00	 mov	 eax, 2063		; 0000080fH
  000ba	66 3b c8	 cmp	 cx, ax
  000bd	0f 85 94 00 00
	00		 jne	 $LN12@DecreaseAr

; 64   : 			{
; 65   : 				if ( Right->m_Durability < 1.0f )

  000c3	d9 e8		 fld1
  000c5	d8 5e 24	 fcomp	 DWORD PTR [esi+36]
  000c8	df e0		 fnstsw	 ax
  000ca	f6 c4 41	 test	 ah, 65			; 00000041H

; 66   : 				{
; 67   : 					return FALSE;

  000cd	0f 84 84 00 00
	00		 je	 $LN12@DecreaseAr

; 68   : 				}
; 69   : 
; 70   : 				Right->m_Durability -= 1.0f;

  000d3	d9 46 24	 fld	 DWORD PTR [esi+36]

; 71   : 				GCItemDurSend(lpObj->m_Index, 0, Right->m_Durability, 0);

  000d6	6a 00		 push	 0
  000d8	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  000de	d9 5d 08	 fstp	 DWORD PTR tv260[ebp]
  000e1	d9 45 08	 fld	 DWORD PTR tv260[ebp]
  000e4	d9 7d 0a	 fnstcw	 WORD PTR tv266[ebp]
  000e7	0f b7 45 0a	 movzx	 eax, WORD PTR tv266[ebp]
  000eb	d9 56 24	 fst	 DWORD PTR [esi+36]
  000ee	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000f3	89 45 fc	 mov	 DWORD PTR tv263[ebp], eax
  000f6	8b 07		 mov	 eax, DWORD PTR [edi]
  000f8	d9 6d fc	 fldcw	 WORD PTR tv263[ebp]
  000fb	db 5d fc	 fistp	 DWORD PTR tv261[ebp]
  000fe	8a 4d fc	 mov	 cl, BYTE PTR tv261[ebp]
  00101	0f b6 d1	 movzx	 edx, cl
  00104	52		 push	 edx
  00105	d9 6d 0a	 fldcw	 WORD PTR tv266[ebp]
  00108	6a 00		 push	 0
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00110	83 c4 10	 add	 esp, 16			; 00000010H

; 72   : 
; 73   : 				if ( Right->m_Durability < 1.0f )

  00113	d9 e8		 fld1
  00115	d8 5e 24	 fcomp	 DWORD PTR [esi+36]
  00118	df e0		 fnstsw	 ax
  0011a	f6 c4 41	 test	 ah, 65			; 00000041H
  0011d	0f 85 b3 00 00
	00		 jne	 $LN1@DecreaseAr

; 74   : 				{
; 75   : 					lpObj->pInventory[0].Clear();

  00123	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  00129	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 76   : 					GCInventoryItemDeleteSend(lpObj->m_Index, 0, 0);

  0012e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00130	6a 00		 push	 0
  00132	6a 00		 push	 0
  00134	51		 push	 ecx

; 77   : 				}
; 78   : 			}
; 79   : 			else

  00135	e9 94 00 00 00	 jmp	 $LN19@DecreaseAr
$LN14@DecreaseAr:

; 35   : 		{
; 36   : 			if ( Left->m_Type == ITEMGET(4,7) )

  0013a	ba 07 08 00 00	 mov	 edx, 2055		; 00000807H
  0013f	66 39 96 ae 00
	00 00		 cmp	 WORD PTR [esi+174], dx
  00146	75 0f		 jne	 SHORT $LN12@DecreaseAr

; 37   : 			{
; 38   : 				if ( Left->m_Durability < 1.0f )

  00148	d9 e8		 fld1
  0014a	d8 9e cc 00 00
	00		 fcomp	 DWORD PTR [esi+204]
  00150	df e0		 fnstsw	 ax
  00152	f6 c4 41	 test	 ah, 65			; 00000041H
  00155	75 0a		 jne	 SHORT $LN11@DecreaseAr
$LN12@DecreaseAr:
  00157	5f		 pop	 edi

; 39   : 				{
; 40   : 					return FALSE;

  00158	33 c0		 xor	 eax, eax
  0015a	5e		 pop	 esi

; 87   : }

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 04 00	 ret	 4
$LN11@DecreaseAr:

; 41   : 				}
; 42   : 
; 43   : 				Left->m_Durability -= 1.0f;

  00161	d9 86 cc 00 00
	00		 fld	 DWORD PTR [esi+204]

; 44   : 				GCItemDurSend(lpObj->m_Index, 1, Left->m_Durability, 0);

  00167	6a 00		 push	 0
  00169	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  0016f	d9 5d 08	 fstp	 DWORD PTR tv273[ebp]
  00172	d9 45 08	 fld	 DWORD PTR tv273[ebp]
  00175	d9 7d 0a	 fnstcw	 WORD PTR tv241[ebp]
  00178	0f b7 45 0a	 movzx	 eax, WORD PTR tv241[ebp]
  0017c	d9 96 cc 00 00
	00		 fst	 DWORD PTR [esi+204]
  00182	8b 17		 mov	 edx, DWORD PTR [edi]
  00184	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00189	89 45 fc	 mov	 DWORD PTR tv237[ebp], eax
  0018c	d9 6d fc	 fldcw	 WORD PTR tv237[ebp]
  0018f	db 5d fc	 fistp	 DWORD PTR tv235[ebp]
  00192	8a 45 fc	 mov	 al, BYTE PTR tv235[ebp]
  00195	0f b6 c8	 movzx	 ecx, al
  00198	51		 push	 ecx
  00199	d9 6d 0a	 fldcw	 WORD PTR tv241[ebp]
  0019c	6a 01		 push	 1
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  001a4	83 c4 10	 add	 esp, 16			; 00000010H

; 45   : 
; 46   : 				if ( Left->m_Durability < 1.0f )

  001a7	d9 e8		 fld1
  001a9	d8 9e cc 00 00
	00		 fcomp	 DWORD PTR [esi+204]
  001af	df e0		 fnstsw	 ax
  001b1	f6 c4 41	 test	 ah, 65			; 00000041H
  001b4	75 20		 jne	 SHORT $LN1@DecreaseAr

; 47   : 				{
; 48   : 					lpObj->pInventory[1].Clear();

  001b6	8b 8f 8c 0c 00
	00		 mov	 ecx, DWORD PTR [edi+3212]
  001bc	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  001c2	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 49   : 					GCInventoryItemDeleteSend(lpObj->m_Index, 1, 0);

  001c7	8b 07		 mov	 eax, DWORD PTR [edi]
  001c9	6a 00		 push	 0
  001cb	6a 01		 push	 1
  001cd	50		 push	 eax
$LN19@DecreaseAr:
  001ce	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@DecreaseAr:

; 80   : 			{
; 81   : 				return FALSE;
; 82   : 			}
; 83   : 		}
; 84   : 	}
; 85   : 
; 86   : 	return TRUE;

  001d6	5f		 pop	 edi
  001d7	b8 01 00 00 00	 mov	 eax, 1
  001dc	5e		 pop	 esi

; 87   : }

  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c2 04 00	 ret	 4
?DecreaseArrow@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CObjBaseAttack::DecreaseArrow
_TEXT	ENDS
PUBLIC	??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ ; `string'
PUBLIC	?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ; CObjBaseAttack::CheckAttackArea
EXTRN	?bIsIgnorePacketSpeedHackDetect@@3HA:DWORD	; bIsIgnorePacketSpeedHackDetect
EXTRN	?LogAdd@@YAXW4eLogColor@@PADZZ:PROC		; LogAdd
EXTRN	?Get@CMsg@@QAEPADH@Z:PROC			; CMsg::Get
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gObjCheckAttackArea@@YAHHH@Z:PROC		; gObjCheckAttackArea
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
;	COMDAT ??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
CONST	SEGMENT
??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area (%s,%d,%d) errortype = '
	DB	'%d', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z PROC ; CObjBaseAttack::CheckAttackArea, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 91   : 	if ( lpTargetObj->Type == OBJ_USER || lpTargetObj->m_RecallMon >= 0 )

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _lpTargetObj$[ebp]
  00007	66 83 7f 60 01	 cmp	 WORD PTR [edi+96], 1
  0000c	74 09		 je	 SHORT $LN5@CheckAttac
  0000e	83 bf cc 02 00
	00 00		 cmp	 DWORD PTR [edi+716], 0
  00015	7c 33		 jl	 SHORT $LN4@CheckAttac
$LN5@CheckAttac:

; 92   : 	{
; 93   : 		BYTE attr = MapC[lpTargetObj->MapNumber].GetAttr(lpTargetObj->X, lpTargetObj->Y);
; 94   : 
; 95   : 		if ( (attr&1) == 1 )

  00017	0f bf 87 06 01
	00 00		 movsx	 eax, WORD PTR [edi+262]
  0001e	0f bf 8f 04 01
	00 00		 movsx	 ecx, WORD PTR [edi+260]
  00025	50		 push	 eax
  00026	51		 push	 ecx
  00027	0f b6 8f 09 01
	00 00		 movzx	 ecx, BYTE PTR [edi+265]
  0002e	69 c9 08 07 05
	00		 imul	 ecx, 329480		; 00050708H
  00034	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  0003a	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0003f	a8 01		 test	 al, 1
  00041	74 07		 je	 SHORT $LN4@CheckAttac

; 96   : 		{
; 97   : 			return FALSE;

  00043	33 c0		 xor	 eax, eax
  00045	5f		 pop	 edi

; 119  : }

  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
$LN4@CheckAttac:
  0004a	56		 push	 esi

; 98   : 		}
; 99   : 	}
; 100  : 
; 101  : 	if ( lpObj->Type == OBJ_USER )

  0004b	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0004e	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  00053	75 63		 jne	 SHORT $LN1@CheckAttac

; 102  : 	{
; 103  : 		int iRet = gObjCheckAttackArea(lpObj->m_Index, lpTargetObj->m_Index);

  00055	8b 17		 mov	 edx, DWORD PTR [edi]
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	52		 push	 edx
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  00060	83 c4 08	 add	 esp, 8

; 104  : 
; 105  : 		if ( iRet != 0 )

  00063	85 c0		 test	 eax, eax
  00065	74 51		 je	 SHORT $LN1@CheckAttac

; 106  : 		{
; 107  : 			LogAdd(LOG_BLACK, "[%s][%s] Try Attack In Not Attack Area (%s,%d,%d) errortype = %d",
; 108  : 				lpObj->AccountID, lpObj->Name, lMsg.Get(MSGGET(7, 208) + lpObj->MapNumber),
; 109  : 				lpObj->X, lpObj->Y, iRet);

  00067	0f bf 8e 06 01
	00 00		 movsx	 ecx, WORD PTR [esi+262]
  0006e	0f bf 96 04 01
	00 00		 movsx	 edx, WORD PTR [esi+260]
  00075	50		 push	 eax
  00076	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  0007d	51		 push	 ecx
  0007e	52		 push	 edx
  0007f	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  00084	50		 push	 eax
  00085	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0008a	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  0008f	50		 push	 eax
  00090	8d 4e 6f	 lea	 ecx, DWORD PTR [esi+111]
  00093	51		 push	 ecx
  00094	83 c6 64	 add	 esi, 100		; 00000064H
  00097	56		 push	 esi
  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Attac@
  0009d	6a 00		 push	 0
  0009f	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  000a4	83 c4 20	 add	 esp, 32			; 00000020H

; 110  : 
; 111  : 			if ( bIsIgnorePacketSpeedHackDetect != FALSE )

  000a7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  000ae	74 08		 je	 SHORT $LN1@CheckAttac

; 112  : 			{
; 113  : 				return FALSE;

  000b0	5e		 pop	 esi
  000b1	33 c0		 xor	 eax, eax
  000b3	5f		 pop	 edi

; 119  : }

  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
$LN1@CheckAttac:
  000b8	5e		 pop	 esi

; 114  : 			}
; 115  : 		}
; 116  : 	}
; 117  : 
; 118  : 	return TRUE;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	5f		 pop	 edi

; 119  : }

  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
?CheckAttackArea@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP ; CObjBaseAttack::CheckAttackArea
_TEXT	ENDS
PUBLIC	?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ; CObjBaseAttack::PkCheck
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
EXTRN	?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjDuelCheck
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
EXTRN	?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z:PROC ; gObjGetRelationShip
; Function compile flags: /Ogtp
;	COMDAT ?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z PROC	; CObjBaseAttack::PkCheck, COMDAT
; _this$ = ecx

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 123  : 	if ( lpObj->Type == OBJ_USER && lpTargetObj->Type == OBJ_USER)

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00009	bb 01 00 00 00	 mov	 ebx, 1
  0000e	66 39 5f 60	 cmp	 WORD PTR [edi+96], bx
  00012	0f 85 4a 01 00
	00		 jne	 $LN1@PkCheck
  00018	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  0001b	66 39 5e 60	 cmp	 WORD PTR [esi+96], bx
  0001f	0f 85 3d 01 00
	00		 jne	 $LN1@PkCheck

; 124  : 	{
; 125  : 		if ( lpTargetObj->Level <= 5 || lpObj->Level <= 5 )

  00025	b8 05 00 00 00	 mov	 eax, 5
  0002a	66 39 86 9c 00
	00 00		 cmp	 WORD PTR [esi+156], ax
  00031	0f 8e d8 00 00
	00		 jle	 $LN19@PkCheck
  00037	66 39 87 9c 00
	00 00		 cmp	 WORD PTR [edi+156], ax
  0003e	0f 8e cb 00 00
	00		 jle	 $LN19@PkCheck

; 126  : 		{
; 127  : 			return FALSE;
; 128  : 		}
; 129  : 
; 130  : 		if ( gObjGetRelationShip(lpObj, lpTargetObj) == 2 ) // Rivals

  00044	56		 push	 esi
  00045	57		 push	 edi
  00046	e8 00 00 00 00	 call	 ?gObjGetRelationShip@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjGetRelationShip
  0004b	83 c4 08	 add	 esp, 8
  0004e	83 f8 02	 cmp	 eax, 2
  00051	75 0d		 jne	 SHORT $LN34@PkCheck

; 131  : 		{
; 132  : 			if ( gNonPK == FALSE )

  00053	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK

; 133  : 			{
; 134  : 				return TRUE;

  0005a	0f 84 02 01 00
	00		 je	 $LN1@PkCheck
$LN34@PkCheck:

; 135  : 			}
; 136  : 		}
; 137  : 
; 138  : 		if ( lpObj->lpGuild != NULL && lpTargetObj->lpGuild != NULL )

  00060	8b 8f b4 02 00
	00		 mov	 ecx, DWORD PTR [edi+692]
  00066	85 c9		 test	 ecx, ecx
  00068	74 24		 je	 SHORT $LN14@PkCheck
  0006a	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  00070	85 c0		 test	 eax, eax
  00072	74 1a		 je	 SHORT $LN14@PkCheck

; 139  : 		{
; 140  : 			if ( lpObj->lpGuild->WarState == 1 && lpTargetObj->lpGuild->WarState == 1 )

  00074	38 99 91 05 00
	00		 cmp	 BYTE PTR [ecx+1425], bl
  0007a	75 12		 jne	 SHORT $LN14@PkCheck
  0007c	38 98 91 05 00
	00		 cmp	 BYTE PTR [eax+1425], bl
  00082	75 0a		 jne	 SHORT $LN14@PkCheck

; 141  : 			{
; 142  : 				if ( lpObj->lpGuild->Number == lpTargetObj->lpGuild->Number )

  00084	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00086	3b 08		 cmp	 ecx, DWORD PTR [eax]

; 143  : 				{
; 144  : 					return FALSE;

  00088	0f 84 81 00 00
	00		 je	 $LN19@PkCheck
$LN14@PkCheck:

; 145  : 				}
; 146  : 			}
; 147  : 		}
; 148  : 
; 149  : 		if ( gObjTargetGuildWarCheck(lpObj, lpTargetObj) == FALSE && lpTargetObj->lpGuild != NULL && lpTargetObj->lpGuild->WarState != 0)

  0008e	56		 push	 esi
  0008f	57		 push	 edi
  00090	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gNonPK@@3HA ; gNonPK
  0009b	83 c4 08	 add	 esp, 8
  0009e	85 c0		 test	 eax, eax
  000a0	75 40		 jne	 SHORT $LN9@PkCheck
  000a2	8b 86 b4 02 00
	00		 mov	 eax, DWORD PTR [esi+692]
  000a8	85 c0		 test	 eax, eax
  000aa	74 36		 je	 SHORT $LN9@PkCheck
  000ac	80 b8 91 05 00
	00 00		 cmp	 BYTE PTR [eax+1425], 0
  000b3	74 2d		 je	 SHORT $LN9@PkCheck

; 150  : 		{
; 151  : 			if ( lpTargetObj->lpGuild->WarType == 1 )

  000b5	38 98 92 05 00
	00		 cmp	 BYTE PTR [eax+1426], bl
  000bb	75 11		 jne	 SHORT $LN10@PkCheck

; 152  : 			{
; 153  : 				if ( lpTargetObj->MapNumber != 6 )

  000bd	80 be 09 01 00
	00 06		 cmp	 BYTE PTR [esi+265], 6
  000c4	74 08		 je	 SHORT $LN10@PkCheck

; 154  : 				{
; 155  : 					if ( !gNonPK )

  000c6	85 d2		 test	 edx, edx

; 156  : 					{
; 157  : 						return TRUE;

  000c8	0f 84 94 00 00
	00		 je	 $LN1@PkCheck
$LN10@PkCheck:

; 158  : 					}
; 159  : 				}
; 160  : 			}
; 161  : 
; 162  : 			if ( CC_MAP_RANGE(lpTargetObj->MapNumber) == FALSE )

  000ce	0f b6 86 09 01
	00 00		 movzx	 eax, BYTE PTR [esi+265]
  000d5	3c 12		 cmp	 al, 18			; 00000012H
  000d7	72 36		 jb	 SHORT $LN19@PkCheck
  000d9	b1 17		 mov	 cl, 23			; 00000017H
  000db	3a c8		 cmp	 cl, al
  000dd	1b c0		 sbb	 eax, eax
  000df	40		 inc	 eax

; 163  : 			{
; 164  : 				return FALSE;

  000e0	74 2d		 je	 SHORT $LN19@PkCheck
$LN9@PkCheck:

; 165  : 			}
; 166  : 		}
; 167  : 
; 168  : 		if ( CC_MAP_RANGE(lpObj->MapNumber) != FALSE )

  000e2	8a 8f 09 01 00
	00		 mov	 cl, BYTE PTR [edi+265]
  000e8	80 f9 12	 cmp	 cl, 18			; 00000012H
  000eb	72 2b		 jb	 SHORT $LN8@PkCheck
  000ed	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  000f2	3a c1		 cmp	 al, cl
  000f4	1b c0		 sbb	 eax, eax
  000f6	40		 inc	 eax
  000f7	74 1f		 je	 SHORT $LN8@PkCheck

; 169  : 		{
; 170  : 			if ( g_ChaosCastle.GetCurrentState(lpObj->MapNumber-MAP_INDEX_CHAOSCASTLE1) != 2 )

  000f9	0f b6 c9	 movzx	 ecx, cl
  000fc	83 e9 12	 sub	 ecx, 18			; 00000012H
  000ff	51		 push	 ecx
  00100	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00105	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  0010a	83 f8 02	 cmp	 eax, 2
  0010d	74 16		 je	 SHORT $LN5@PkCheck
$LN19@PkCheck:
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi

; 171  : 			{
; 172  : 				return FALSE;

  00111	33 c0		 xor	 eax, eax
  00113	5b		 pop	 ebx

; 200  : }

  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
$LN8@PkCheck:

; 173  : 			}
; 174  : 		}
; 175  : 		else if ( gNonPK != FALSE )

  00118	85 d2		 test	 edx, edx
  0011a	74 09		 je	 SHORT $LN5@PkCheck

; 176  : 		{
; 177  : 			return FALSE;

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	33 c0		 xor	 eax, eax
  00120	5b		 pop	 ebx

; 200  : }

  00121	5d		 pop	 ebp
  00122	c2 08 00	 ret	 8
$LN5@PkCheck:

; 178  : 		}
; 179  : 
; 180  : 		if ( DS_MAP_RANGE(lpObj->MapNumber) ) // DEvil

  00125	8a 87 09 01 00
	00		 mov	 al, BYTE PTR [edi+265]
  0012b	3c 09		 cmp	 al, 9
  0012d	74 e0		 je	 SHORT $LN19@PkCheck
  0012f	33 c9		 xor	 ecx, ecx
  00131	3c 20		 cmp	 al, 32			; 00000020H
  00133	0f 94 c1	 sete	 cl
  00136	85 c9		 test	 ecx, ecx

; 181  : 		{
; 182  : 			return FALSE;

  00138	75 d5		 jne	 SHORT $LN19@PkCheck

; 183  : 		}
; 184  : 
; 185  : 		if ( BC_MAP_RANGE(lpObj->MapNumber) )

  0013a	3c 0b		 cmp	 al, 11			; 0000000bH
  0013c	72 09		 jb	 SHORT $LN3@PkCheck
  0013e	b2 11		 mov	 dl, 17			; 00000011H
  00140	3a d0		 cmp	 dl, al
  00142	1b c0		 sbb	 eax, eax
  00144	40		 inc	 eax

; 186  : 		{
; 187  : 			return FALSE;

  00145	75 c8		 jne	 SHORT $LN19@PkCheck
$LN3@PkCheck:

; 188  : 		}
; 189  : 
; 190  : 		if ( gObjDuelCheck(lpObj, lpTargetObj) == FALSE )

  00147	56		 push	 esi
  00148	57		 push	 edi
  00149	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  0014e	83 c4 08	 add	 esp, 8
  00151	85 c0		 test	 eax, eax
  00153	75 0d		 jne	 SHORT $LN1@PkCheck

; 191  : 		{
; 192  : 			if ( gObjDuelCheck(lpTargetObj) )

  00155	56		 push	 esi
  00156	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAUOBJECTSTRUCT@@@Z ; gObjDuelCheck
  0015b	83 c4 04	 add	 esp, 4
  0015e	85 c0		 test	 eax, eax

; 193  : 			{
; 194  : 				return FALSE;

  00160	75 ad		 jne	 SHORT $LN19@PkCheck
$LN1@PkCheck:
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi

; 195  : 			}
; 196  : 		}
; 197  : 	}
; 198  : 
; 199  : 	return TRUE;

  00164	8b c3		 mov	 eax, ebx
  00166	5b		 pop	 ebx

; 200  : }

  00167	5d		 pop	 ebp
  00168	c2 08 00	 ret	 8
?PkCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0@Z ENDP	; CObjBaseAttack::PkCheck
_TEXT	ENDS
PUBLIC	?ResistanceCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0H@Z ; CObjBaseAttack::ResistanceCheck
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z:PROC	; GCStateInfoSend
EXTRN	?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z:PROC	; retResistance
EXTRN	?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z:PROC	; gObjBackSpring2
; Function compile flags: /Ogtp
;	COMDAT ?ResistanceCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
?ResistanceCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0H@Z PROC ; CObjBaseAttack::ResistanceCheck, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 204  : #if GS_CASTLE == 1
; 205  : 	if ( lpTargetObj->Type != OBJ_USER )
; 206  : 	{
; 207  : 		if ( lpTargetObj->Class == 277 || lpTargetObj->Class == 283 ||
; 208  : 			 lpTargetObj->Class == 288 || lpTargetObj->Class == 278 ||
; 209  : 			 lpTargetObj->Class == 215 || lpTargetObj->Class == 216 ||
; 210  : 			 lpTargetObj->Class == 217 || lpTargetObj->Class == 218 ||
; 211  : 			 lpTargetObj->Class == 219 )
; 212  : 		{
; 213  : 			return FALSE;
; 214  : 		}
; 215  : 	}
; 216  : 
; 217  : 	if ( lpTargetObj->Type != OBJ_USER )
; 218  : 	{
; 219  : 		if ( CHECK_LIMIT2(lpTargetObj->Class, 205, 210) != FALSE ||
; 220  : 			 CHECK_CLASS(lpTargetObj->Class, 204) != FALSE )
; 221  : 		{
; 222  : 			return FALSE;
; 223  : 		}
; 224  : 	}
; 225  : #endif
; 226  : 	if ( skill == 62 )

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _skill$[ebp]
  00007	56		 push	 esi
  00008	83 fb 3e	 cmp	 ebx, 62			; 0000003eH
  0000b	75 1b		 jne	 SHORT $LN33@Resistance

; 227  : 	{
; 228  : 		gObjBackSpring2(lpTargetObj, lpObj, 3);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00013	6a 03		 push	 3
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAUOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	5e		 pop	 esi

; 335  : 			}
; 336  : 		}
; 337  : 		else
; 338  : 		{
; 339  : 			return FALSE;
; 340  : 		}
; 341  : 	}
; 342  : 
; 343  : 	return TRUE;

  00020	8d 43 c3	 lea	 eax, DWORD PTR [ebx-61]
  00023	5b		 pop	 ebx

; 344  : }

  00024	5d		 pop	 ebp
  00025	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Resistance:

; 229  : 	}
; 230  : 
; 231  : 	if ( skill == 19 || skill == 20 || skill == 21 || skill == 22 || skill == 23)

  00028	83 fb 13	 cmp	 ebx, 19			; 00000013H
  0002b	0f 84 a8 01 00
	00		 je	 $LN31@Resistance
  00031	83 fb 14	 cmp	 ebx, 20			; 00000014H
  00034	0f 84 9f 01 00
	00		 je	 $LN31@Resistance
  0003a	83 fb 15	 cmp	 ebx, 21			; 00000015H
  0003d	0f 84 96 01 00
	00		 je	 $LN31@Resistance
  00043	83 fb 16	 cmp	 ebx, 22			; 00000016H
  00046	0f 84 8d 01 00
	00		 je	 $LN31@Resistance
  0004c	83 fb 17	 cmp	 ebx, 23			; 00000017H
  0004f	0f 84 84 01 00
	00		 je	 $LN31@Resistance

; 234  : 	}
; 235  : 	else if ( skill == 3 )	// Poison

  00055	83 fb 03	 cmp	 ebx, 3
  00058	75 36		 jne	 SHORT $LN29@Resistance

; 236  : 	{
; 237  : 		if ( retResistance(lpTargetObj, 2) == 0 )

  0005a	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  0005d	6a 02		 push	 2
  0005f	56		 push	 esi
  00060	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  00065	83 c4 08	 add	 esp, 8
  00068	85 c0		 test	 eax, eax
  0006a	0f 85 fd 00 00
	00		 jne	 $LN28@Resistance

; 238  : 		{
; 239  : 			gObjAddMsgSendDelay(lpTargetObj, 2, lpObj->m_Index, 150, 0);

  00070	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00073	50		 push	 eax
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	68 96 00 00 00	 push	 150			; 00000096H
  0007b	50		 push	 eax
  0007c	6a 02		 push	 2
  0007e	56		 push	 esi
  0007f	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00084	83 c4 14	 add	 esp, 20			; 00000014H
  00087	5e		 pop	 esi

; 335  : 			}
; 336  : 		}
; 337  : 		else
; 338  : 		{
; 339  : 			return FALSE;
; 340  : 		}
; 341  : 	}
; 342  : 
; 343  : 	return TRUE;

  00088	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  0008b	5b		 pop	 ebx

; 344  : }

  0008c	5d		 pop	 ebp
  0008d	c2 0c 00	 ret	 12			; 0000000cH
$LN29@Resistance:

; 240  : 			return TRUE;
; 241  : 		}
; 242  : 
; 243  : 		return FALSE;
; 244  : 	}
; 245  : 	else if ( skill == 1 )

  00090	83 fb 01	 cmp	 ebx, 1
  00093	75 46		 jne	 SHORT $LN26@Resistance

; 246  : 	{
; 247  : 		if ( lpTargetObj->m_PoisonType == 0 )

  00095	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  00098	80 be 25 02 00
	00 00		 cmp	 BYTE PTR [esi+549], 0
  0009f	0f 85 c8 00 00
	00		 jne	 $LN28@Resistance

; 248  : 		{
; 249  : 			if ( retResistance(lpTargetObj, 1) == 0 )

  000a5	53		 push	 ebx
  000a6	56		 push	 esi
  000a7	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  000ac	83 c4 08	 add	 esp, 8
  000af	85 c0		 test	 eax, eax
  000b1	0f 85 b6 00 00
	00		 jne	 $LN28@Resistance

; 250  : 			{
; 251  : 				lpTargetObj->m_PoisonType = 1;
; 252  : 				lpTargetObj->m_PoisonBeattackCount = 20;
; 253  : 				lpTargetObj->lpAttackObj = lpObj;

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]

; 254  : 				lpTargetObj->m_ViewSkillState |= 1;

  000ba	09 9e c4 01 00
	00		 or	 DWORD PTR [esi+452], ebx
  000c0	88 9e 25 02 00
	00		 mov	 BYTE PTR [esi+549], bl
  000c6	c6 86 27 02 00
	00 14		 mov	 BYTE PTR [esi+551], 20	; 00000014H
  000cd	89 8e 38 02 00
	00		 mov	 DWORD PTR [esi+568], ecx
  000d3	5e		 pop	 esi

; 335  : 			}
; 336  : 		}
; 337  : 		else
; 338  : 		{
; 339  : 			return FALSE;
; 340  : 		}
; 341  : 	}
; 342  : 
; 343  : 	return TRUE;

  000d4	8b c3		 mov	 eax, ebx
  000d6	5b		 pop	 ebx

; 344  : }

  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH
$LN26@Resistance:

; 255  : 			}
; 256  : 			else
; 257  : 			{
; 258  : 				return FALSE;
; 259  : 			}	
; 260  : 		}
; 261  : 		else
; 262  : 		{
; 263  : 			return FALSE;
; 264  : 		}
; 265  : 	}
; 266  : 	else if ( skill == 38 ) // Death Poison

  000db	83 fb 26	 cmp	 ebx, 38			; 00000026H
  000de	75 5b		 jne	 SHORT $LN20@Resistance

; 267  : 	{
; 268  : 		if ( lpTargetObj->m_PoisonType == 0 || lpTargetObj->m_PoisonType == 1 )

  000e0	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  000e3	8a 86 25 02 00
	00		 mov	 al, BYTE PTR [esi+549]
  000e9	84 c0		 test	 al, al
  000eb	74 04		 je	 SHORT $LN18@Resistance
  000ed	3c 01		 cmp	 al, 1

; 278  : 			}
; 279  : 			else
; 280  : 			{
; 281  : 				return FALSE;
; 282  : 			}
; 283  : 		}
; 284  : 		else
; 285  : 		{
; 286  : 			return FALSE;

  000ef	75 7c		 jne	 SHORT $LN28@Resistance
$LN18@Resistance:

; 269  : 		{
; 270  : 			if ( retResistance(lpTargetObj, 1) == 0 )

  000f1	6a 01		 push	 1
  000f3	56		 push	 esi
  000f4	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  000f9	83 c4 08	 add	 esp, 8
  000fc	85 c0		 test	 eax, eax
  000fe	75 6d		 jne	 SHORT $LN28@Resistance

; 271  : 			{
; 272  : 				lpTargetObj->m_PoisonType = 38;
; 273  : 				lpTargetObj->m_PoisonBeattackCount = 10;
; 274  : 				lpTargetObj->lpAttackObj = lpObj;
; 275  : 				lpTargetObj->m_ViewSkillState |= 1;

  00100	83 8e c4 01 00
	00 01		 or	 DWORD PTR [esi+452], 1
  00107	8b 86 c4 01 00
	00		 mov	 eax, DWORD PTR [esi+452]
  0010d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]

; 276  : 
; 277  : 				GCStateInfoSend(lpTargetObj, 1, lpTargetObj->m_ViewSkillState);

  00110	50		 push	 eax
  00111	6a 01		 push	 1
  00113	56		 push	 esi
  00114	c6 86 25 02 00
	00 26		 mov	 BYTE PTR [esi+549], 38	; 00000026H
  0011b	c6 86 27 02 00
	00 0a		 mov	 BYTE PTR [esi+551], 10	; 0000000aH
  00122	89 96 38 02 00
	00		 mov	 DWORD PTR [esi+568], edx
  00128	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00130	5e		 pop	 esi

; 335  : 			}
; 336  : 		}
; 337  : 		else
; 338  : 		{
; 339  : 			return FALSE;
; 340  : 		}
; 341  : 	}
; 342  : 
; 343  : 	return TRUE;

  00131	b8 01 00 00 00	 mov	 eax, 1
  00136	5b		 pop	 ebx

; 344  : }

  00137	5d		 pop	 ebp
  00138	c2 0c 00	 ret	 12			; 0000000cH
$LN20@Resistance:

; 287  : 		}
; 288  : 
; 289  : 		return TRUE;
; 290  : 	}
; 291  : 	else if ( skill == 7 || skill == 39 )

  0013b	83 fb 07	 cmp	 ebx, 7
  0013e	74 35		 je	 SHORT $LN12@Resistance
  00140	83 fb 27	 cmp	 ebx, 39			; 00000027H
  00143	74 30		 je	 SHORT $LN12@Resistance

; 307  : 				}
; 308  : 			}
; 309  : 			else
; 310  : 			{
; 311  : 				return FALSE;
; 312  : 			}
; 313  : 		}
; 314  : 		else
; 315  : 		{
; 316  : 			return FALSE;
; 317  : 		}
; 318  : 	}
; 319  : 	else if ( skill == 51 ) // Ice Arrow

  00145	83 fb 33	 cmp	 ebx, 51			; 00000033H
  00148	0f 85 a6 00 00
	00		 jne	 $LN1@Resistance

; 320  : 	{
; 321  : 		if ( lpTargetObj->m_SkillHardenTime <= 0 )

  0014e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00151	83 b8 9c 02 00
	00 00		 cmp	 DWORD PTR [eax+668], 0
  00158	7f 13		 jg	 SHORT $LN28@Resistance

; 322  : 		{
; 323  : 			if ( retResistance(lpTargetObj, 0) == 0 )

  0015a	6a 00		 push	 0
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  00162	83 c4 08	 add	 esp, 8
  00165	85 c0		 test	 eax, eax
  00167	0f 84 87 00 00
	00		 je	 $LN1@Resistance
$LN28@Resistance:
  0016d	5e		 pop	 esi

; 324  : 			{
; 325  : 				/*lpTargetObj->m_SkillHarden = 7;
; 326  : 				lpTargetObj->m_SkillHardenTime = 7;
; 327  : 				lpTargetObj->lpAttackObj = lpObj;
; 328  : 				lpTargetObj->m_ViewSkillState |= 1;
; 329  : 				lpTargetObj->PathCount = 0;
; 330  : 				gObjSetPosition(lpTargetObj->m_Index, lpTargetObj->X, lpTargetObj->Y);*/
; 331  : 			}
; 332  : 			else
; 333  : 			{
; 334  : 				return FALSE;

  0016e	33 c0		 xor	 eax, eax
  00170	5b		 pop	 ebx

; 344  : }

  00171	5d		 pop	 ebp
  00172	c2 0c 00	 ret	 12			; 0000000cH
$LN12@Resistance:

; 292  : 	{
; 293  : 		if (lpTargetObj->m_ColdBeattackCount == 0 )

  00175	8b 75 0c	 mov	 esi, DWORD PTR _lpTargetObj$[ebp]
  00178	80 be 28 02 00
	00 00		 cmp	 BYTE PTR [esi+552], 0
  0017f	75 ec		 jne	 SHORT $LN28@Resistance

; 294  : 		{
; 295  : 			if ( retResistance(lpTargetObj, 0) == 0 )

  00181	6a 00		 push	 0
  00183	56		 push	 esi
  00184	e8 00 00 00 00	 call	 ?retResistance@@YAHPAUOBJECTSTRUCT@@H@Z ; retResistance
  00189	83 c4 08	 add	 esp, 8
  0018c	85 c0		 test	 eax, eax
  0018e	75 dd		 jne	 SHORT $LN28@Resistance

; 296  : 			{
; 297  : 				lpTargetObj->m_ColdBeattackCount = 10;
; 298  : 				lpTargetObj->lpAttackObj = lpObj;

  00190	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]

; 299  : 				lpTargetObj->DelayActionTime = 800;
; 300  : 				lpTargetObj->DelayLevel = 1;
; 301  : 				lpTargetObj->m_ViewSkillState |= 2;

  00193	83 8e c4 01 00
	00 02		 or	 DWORD PTR [esi+452], 2
  0019a	c6 86 28 02 00
	00 0a		 mov	 BYTE PTR [esi+552], 10	; 0000000aH
  001a1	89 86 38 02 00
	00		 mov	 DWORD PTR [esi+568], eax
  001a7	c7 86 20 02 00
	00 20 03 00 00	 mov	 DWORD PTR [esi+544], 800 ; 00000320H
  001b1	c6 86 24 02 00
	00 01		 mov	 BYTE PTR [esi+548], 1

; 302  : 				lpTargetObj->m_IceType = skill;

  001b8	88 9e 26 02 00
	00		 mov	 BYTE PTR [esi+550], bl

; 303  : 
; 304  : 				if ( skill == 39 )

  001be	83 fb 27	 cmp	 ebx, 39			; 00000027H
  001c1	75 31		 jne	 SHORT $LN1@Resistance

; 305  : 				{
; 306  : 					GCStateInfoSend(lpTargetObj, 1, 2);

  001c3	6a 02		 push	 2
  001c5	6a 01		 push	 1
  001c7	56		 push	 esi
  001c8	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EH@Z ; GCStateInfoSend
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d0	5e		 pop	 esi

; 335  : 			}
; 336  : 		}
; 337  : 		else
; 338  : 		{
; 339  : 			return FALSE;
; 340  : 		}
; 341  : 	}
; 342  : 
; 343  : 	return TRUE;

  001d1	8d 43 da	 lea	 eax, DWORD PTR [ebx-38]
  001d4	5b		 pop	 ebx

; 344  : }

  001d5	5d		 pop	 ebp
  001d6	c2 0c 00	 ret	 12			; 0000000cH
$LN31@Resistance:

; 232  : 	{
; 233  : 		gObjAddMsgSendDelay(lpTargetObj, 2, lpObj->m_Index, 150, 0);

  001d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  001de	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001e1	6a 00		 push	 0
  001e3	68 96 00 00 00	 push	 150			; 00000096H
  001e8	52		 push	 edx
  001e9	6a 02		 push	 2
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAUOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  001f1	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@Resistance:

; 335  : 			}
; 336  : 		}
; 337  : 		else
; 338  : 		{
; 339  : 			return FALSE;
; 340  : 		}
; 341  : 	}
; 342  : 
; 343  : 	return TRUE;

  001f4	5e		 pop	 esi
  001f5	b8 01 00 00 00	 mov	 eax, 1
  001fa	5b		 pop	 ebx

; 344  : }

  001fb	5d		 pop	 ebp
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?ResistanceCheck@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0H@Z ENDP ; CObjBaseAttack::ResistanceCheck
_TEXT	ENDS
EXTRN	?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCDamageSend@@YAXHHHHH@Z:PROC			; GCDamageSend
EXTRN	_rand:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffd4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@MissCheck
	DD	FLAT:$LN17@MissCheck
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z
_TEXT	SEGMENT
tv204 = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
_iDefenseRate$155802 = 12				; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
_skillSuccess$ = 20					; size = 4
_magicsend$ = 24					; size = 4
_bAllMiss$ = 28						; size = 4
?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z PROC ; CObjBaseAttack::MissCheck, COMDAT
; _this$ = ecx

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 348  : 	__try

  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 349  : 	{
; 350  : 		int iAttackRate = 0;	// lc20
; 351  : 		int iDefenseRate = lpTargetObj->m_SuccessfulBlocking;	// lc24

  0003a	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$[ebp]
  0003d	8b 83 18 03 00
	00		 mov	 eax, DWORD PTR [ebx+792]
  00043	89 45 0c	 mov	 DWORD PTR _iDefenseRate$155802[ebp], eax

; 352  : 		int iMSBDamage = 0;	// MonsterSetBasse Damage
; 353  : 
; 354  : 		if ( lpObj->Type == OBJ_USER )	// Miss for Uses

  00046	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00049	66 83 7e 60 01	 cmp	 WORD PTR [esi+96], 1
  0004e	0f 85 e0 00 00
	00		 jne	 $LN11@MissCheck

; 357  : 			{
; 358  : 				iAttackRate = lpObj->Level * 5 + ((lpObj->Dexterity + lpObj->AddDexterity) * 6) / 2 + ( lpObj->Strength + lpObj->AddStrength) / 4  + ((lpObj->Leadership + lpObj->AddLeadership)/10);

  00054	0f bf 86 e2 00
	00 00		 movsx	 eax, WORD PTR [esi+226]
  0005b	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  00062	03 c1		 add	 eax, ecx
  00064	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]

; 355  : 		{
; 356  : 			if ( lpObj->Class == CLASS_DARKLORD ) // DL

  00067	66 83 be 98 00
	00 00 04	 cmp	 WORD PTR [esi+152], 4
  0006f	75 76		 jne	 SHORT $LN10@MissCheck

; 357  : 			{
; 358  : 				iAttackRate = lpObj->Level * 5 + ((lpObj->Dexterity + lpObj->AddDexterity) * 6) / 2 + ( lpObj->Strength + lpObj->AddStrength) / 4  + ((lpObj->Leadership + lpObj->AddLeadership)/10);

  00071	03 c0		 add	 eax, eax
  00073	99		 cdq
  00074	2b c2		 sub	 eax, edx
  00076	d1 f8		 sar	 eax, 1
  00078	0f b7 8e da 00
	00 00		 movzx	 ecx, WORD PTR [esi+218]
  0007f	0f b7 96 d8 00
	00 00		 movzx	 edx, WORD PTR [esi+216]
  00086	03 ca		 add	 ecx, edx
  00088	89 45 e4	 mov	 DWORD PTR tv204[ebp], eax
  0008b	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00090	f7 e9		 imul	 ecx
  00092	c1 fa 02	 sar	 edx, 2
  00095	8b fa		 mov	 edi, edx
  00097	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0009a	8b 45 e4	 mov	 eax, DWORD PTR tv204[ebp]
  0009d	03 c2		 add	 eax, edx
  0009f	03 f8		 add	 edi, eax
  000a1	0f bf 86 e0 00
	00 00		 movsx	 eax, WORD PTR [esi+224]
  000a8	0f b7 8e b4 00
	00 00		 movzx	 ecx, WORD PTR [esi+180]
  000af	03 c1		 add	 eax, ecx
  000b1	99		 cdq
  000b2	83 e2 03	 and	 edx, 3
  000b5	03 c2		 add	 eax, edx
  000b7	c1 f8 02	 sar	 eax, 2
  000ba	03 f8		 add	 edi, eax
  000bc	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000c3	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  000c6	03 fa		 add	 edi, edx

; 359  : 				iAttackRate += iAttackRate * lpObj->SetOpImproveSuccessAttackRate / 100;

  000c8	0f b6 8e 7d 0f
	00 00		 movzx	 ecx, BYTE PTR [esi+3965]
  000cf	0f af cf	 imul	 ecx, edi
  000d2	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000d7	f7 e9		 imul	 ecx
  000d9	c1 fa 05	 sar	 edx, 5
  000dc	8b c2		 mov	 eax, edx
  000de	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e1	03 c2		 add	 eax, edx
  000e3	03 f8		 add	 edi, eax

; 360  : 			}
; 361  : 			else

  000e5	eb 53		 jmp	 SHORT $LN8@MissCheck
$LN10@MissCheck:

; 362  : 			{
; 363  : 				iAttackRate = lpObj->Level * 5 + ((lpObj->Dexterity + lpObj->AddDexterity) * 3) / 2 + ( lpObj->Strength + lpObj->AddStrength) / 4 ;

  000e7	99		 cdq
  000e8	2b c2		 sub	 eax, edx
  000ea	8b f8		 mov	 edi, eax
  000ec	d1 ff		 sar	 edi, 1
  000ee	0f bf 86 e0 00
	00 00		 movsx	 eax, WORD PTR [esi+224]
  000f5	0f b7 96 b4 00
	00 00		 movzx	 edx, WORD PTR [esi+180]
  000fc	03 c2		 add	 eax, edx
  000fe	99		 cdq
  000ff	83 e2 03	 and	 edx, 3
  00102	03 c2		 add	 eax, edx
  00104	c1 f8 02	 sar	 eax, 2
  00107	03 f8		 add	 edi, eax
  00109	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00110	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00113	03 f8		 add	 edi, eax

; 364  : 				iAttackRate += iAttackRate * lpObj->SetOpImproveSuccessAttackRate / 100;

  00115	0f b6 8e 7d 0f
	00 00		 movzx	 ecx, BYTE PTR [esi+3965]
  0011c	0f af cf	 imul	 ecx, edi
  0011f	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00124	f7 e9		 imul	 ecx
  00126	c1 fa 05	 sar	 edx, 5
  00129	8b ca		 mov	 ecx, edx
  0012b	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0012e	03 ca		 add	 ecx, edx
  00130	03 f9		 add	 edi, ecx

; 365  : 			}
; 366  : 		}
; 367  : 		else	// Miss for Monsters

  00132	eb 06		 jmp	 SHORT $LN8@MissCheck
$LN11@MissCheck:

; 368  : 		{
; 369  : 			iAttackRate = lpObj->m_AttackRating;

  00134	8b be 04 03 00
	00		 mov	 edi, DWORD PTR [esi+772]
$LN8@MissCheck:

; 370  : 		}
; 371  : 
; 372  : 		if ( iAttackRate < iDefenseRate )

  0013a	3b 7d 0c	 cmp	 edi, DWORD PTR _iDefenseRate$155802[ebp]
  0013d	7d 09		 jge	 SHORT $LN7@MissCheck

; 373  : 		{
; 374  : 			bAllMiss = TRUE;

  0013f	8b 55 1c	 mov	 edx, DWORD PTR _bAllMiss$[ebp]
  00142	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1
$LN7@MissCheck:

; 375  : 		}
; 376  : 
; 377  : 		if ( bAllMiss != FALSE )	// When All Miss

  00148	8b 45 1c	 mov	 eax, DWORD PTR _bAllMiss$[ebp]
  0014b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0014e	74 49		 je	 SHORT $LN6@MissCheck

; 378  : 		{
; 379  : 			if ( (rand()%100) >= 5 )

  00150	e8 00 00 00 00	 call	 _rand
  00155	99		 cdq
  00156	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0015b	f7 f9		 idiv	 ecx
  0015d	83 fa 05	 cmp	 edx, 5
  00160	7c 74		 jl	 SHORT $LN2@MissCheck

; 380  : 			{
; 381  : 				GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, iMSBDamage);

  00162	6a 00		 push	 0
  00164	6a 00		 push	 0
  00166	6a 00		 push	 0
  00168	8b 13		 mov	 edx, DWORD PTR [ebx]
  0016a	52		 push	 edx
  0016b	8b 06		 mov	 eax, DWORD PTR [esi]
  0016d	50		 push	 eax
  0016e	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  00173	83 c4 14	 add	 esp, 20			; 00000014H

; 382  : 
; 383  : 				if (magicsend != 0 )

  00176	83 7d 18 00	 cmp	 DWORD PTR _magicsend$[ebp], 0
  0017a	0f 84 ad 00 00
	00		 je	 $LN4@MissCheck

; 384  : 				{
; 385  : 					GCMagicAttackNumberSend(lpObj, skill, lpTargetObj->m_Index, skillSuccess);

  00180	8b 4d 14	 mov	 ecx, DWORD PTR _skillSuccess$[ebp]
  00183	51		 push	 ecx
  00184	8b 13		 mov	 edx, DWORD PTR [ebx]
  00186	52		 push	 edx
  00187	8b 45 10	 mov	 eax, DWORD PTR _skill$[ebp]
  0018a	50		 push	 eax
  0018b	56		 push	 esi
  0018c	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00191	83 c4 10	 add	 esp, 16			; 00000010H

; 386  : 				}
; 387  : 
; 388  : 				return FALSE;

  00194	e9 94 00 00 00	 jmp	 $LN4@MissCheck
$LN6@MissCheck:

; 389  : 			}
; 390  : 		}
; 391  : 		else	// if the is a chance  ot hit the target
; 392  : 		{
; 393  : 			if ( (rand()%iAttackRate) < iDefenseRate)

  00199	e8 00 00 00 00	 call	 _rand
  0019e	99		 cdq
  0019f	f7 ff		 idiv	 edi
  001a1	3b 55 0c	 cmp	 edx, DWORD PTR _iDefenseRate$155802[ebp]
  001a4	7d 30		 jge	 SHORT $LN2@MissCheck

; 394  : 			{
; 395  : 				GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, iMSBDamage);

  001a6	6a 00		 push	 0
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001ae	51		 push	 ecx
  001af	8b 16		 mov	 edx, DWORD PTR [esi]
  001b1	52		 push	 edx
  001b2	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  001b7	83 c4 14	 add	 esp, 20			; 00000014H

; 396  : 
; 397  : 				if ( magicsend != 0 )

  001ba	83 7d 18 00	 cmp	 DWORD PTR _magicsend$[ebp], 0
  001be	74 6d		 je	 SHORT $LN4@MissCheck

; 398  : 				{
; 399  : 					GCMagicAttackNumberSend(lpObj, skill, lpTargetObj->m_Index,  skillSuccess);

  001c0	8b 45 14	 mov	 eax, DWORD PTR _skillSuccess$[ebp]
  001c3	50		 push	 eax
  001c4	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001c6	51		 push	 ecx
  001c7	8b 55 10	 mov	 edx, DWORD PTR _skill$[ebp]
  001ca	52		 push	 edx
  001cb	56		 push	 esi
  001cc	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAUOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  001d1	83 c4 10	 add	 esp, 16			; 00000010H

; 400  : 				}
; 401  : 
; 402  : 				return FALSE;

  001d4	eb 57		 jmp	 SHORT $LN4@MissCheck
$LN2@MissCheck:

; 403  : 			}
; 404  : 		}
; 405  : 	}

  001d6	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH

; 410  : 	}
; 411  : 
; 412  : 	return TRUE;

  001dd	b8 01 00 00 00	 mov	 eax, 1

; 413  : }

  001e2	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  001e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ec	59		 pop	 ecx
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 18 00	 ret	 24			; 00000018H
$LN16@MissCheck:
$LN22@MissCheck:

; 406  : 	__except (lpObj->Level=1,-1)

  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001fe	66 89 81 9c 00
	00 00		 mov	 WORD PTR [ecx+156], ax
  00205	83 c8 ff	 or	 eax, -1
$LN21@MissCheck:
$LN18@MissCheck:
  00208	c3		 ret	 0
$LN17@MissCheck:
  00209	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 407  : 	{
; 408  : 		LogAdd(LOG_BLACK, lMsg.Get(MSGGET(2, 12)), lpObj->Name);

  0020c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0020f	83 c2 6f	 add	 edx, 111		; 0000006fH
  00212	52		 push	 edx
  00213	68 0c 02 00 00	 push	 524			; 0000020cH
  00218	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0021d	e8 00 00 00 00	 call	 ?Get@CMsg@@QAEPADH@Z	; CMsg::Get
  00222	50		 push	 eax
  00223	6a 00		 push	 0
  00225	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@MissCheck:

; 409  : 		return FALSE;

  0022d	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00234	33 c0		 xor	 eax, eax

; 413  : }

  00236	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00239	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00240	59		 pop	 ecx
  00241	5f		 pop	 edi
  00242	5e		 pop	 esi
  00243	5b		 pop	 ebx
  00244	8b e5		 mov	 esp, ebp
  00246	5d		 pop	 ebp
  00247	c2 18 00	 ret	 24			; 00000018H
?MissCheck@CObjBaseAttack@@UAEHPAUOBJECTSTRUCT@@0HHHAAH@Z ENDP ; CObjBaseAttack::MissCheck
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@40c3880000000000
PUBLIC	__real@00000000
PUBLIC	?MissCheckPvP@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0HHHAAH@Z ; CObjBaseAttack::MissCheckPvP
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40c3880000000000
CONST	SEGMENT
__real@40c3880000000000 DQ 040c3880000000000r	; 10000
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MissCheckPvP@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0HHHAAH@Z
_TEXT	SEGMENT
_iDefenseRate$ = -8					; size = 4
_iAttackRate$ = -4					; size = 4
tv334 = 8						; size = 4
tv320 = 8						; size = 4
tv314 = 8						; size = 4
tv308 = 8						; size = 4
tv303 = 8						; size = 4
tv299 = 8						; size = 4
tv298 = 8						; size = 4
tv295 = 8						; size = 4
tv294 = 8						; size = 4
tv288 = 8						; size = 4
tv286 = 8						; size = 4
tv282 = 8						; size = 4
tv255 = 8						; size = 4
tv192 = 8						; size = 4
_iAttackSuccessRate$ = 8				; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
_skillSuccess$ = 20					; size = 4
_magicsend$ = 24					; size = 4
_bAllMiss$ = 28						; size = 4
?MissCheckPvP@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0HHHAAH@Z PROC ; CObjBaseAttack::MissCheckPvP, COMDAT
; _this$ = ecx

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 417  : 	float iAttackRate = 0;

  00006	d9 ee		 fldz
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	d9 55 fc	 fst	 DWORD PTR _iAttackRate$[ebp]

; 418  : 	float iDefenseRate = 0;
; 419  : 	int iAttackSuccessRate = 0;
; 420  : 
; 421  : 	if ( lpObj->Class == CLASS_KNIGHT )

  0000d	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00010	d9 55 f8	 fst	 DWORD PTR _iDefenseRate$[ebp]
  00013	0f b7 86 98 00
	00 00		 movzx	 eax, WORD PTR [esi+152]
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	75 32		 jne	 SHORT $LN26@MissCheckP

; 422  : 	{
; 423  : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 45) / 10;	// #formula

  0001f	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  00026	6b c9 2d	 imul	 ecx, 45			; 0000002dH
  00029	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0002e	f7 e9		 imul	 ecx
  00030	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00037	c1 fa 02	 sar	 edx, 2
  0003a	8b ca		 mov	 ecx, edx
  0003c	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0003f	03 ca		 add	 ecx, edx
  00041	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00044	03 ca		 add	 ecx, edx
  00046	89 4d 08	 mov	 DWORD PTR tv314[ebp], ecx
  00049	db 45 08	 fild	 DWORD PTR tv314[ebp]
  0004c	e9 ad 00 00 00	 jmp	 $LN71@MissCheckP
$LN26@MissCheckP:

; 424  : 	}
; 425  : 	else if ( lpObj->Class == CLASS_DARKLORD )

  00051	83 f8 04	 cmp	 eax, 4
  00054	75 1f		 jne	 SHORT $LN24@MissCheckP

; 426  : 	{
; 427  : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 4 );	// #formula

  00056	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  0005d	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  00064	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00067	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0006a	89 45 08	 mov	 DWORD PTR tv308[ebp], eax
  0006d	db 45 08	 fild	 DWORD PTR tv308[ebp]
  00070	e9 89 00 00 00	 jmp	 $LN71@MissCheckP
$LN24@MissCheckP:

; 428  : 	}
; 429  : 	else if ( lpObj->Class == CLASS_ELF )

  00075	83 f8 02	 cmp	 eax, 2
  00078	75 31		 jne	 SHORT $LN22@MissCheckP

; 430  : 	{
; 431  : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 6 ) / 10;	// #formula

  0007a	0f b7 86 b6 00
	00 00		 movzx	 eax, WORD PTR [esi+182]
  00081	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00084	03 c9		 add	 ecx, ecx
  00086	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0008b	f7 e9		 imul	 ecx
  0008d	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00094	c1 fa 02	 sar	 edx, 2
  00097	8b ca		 mov	 ecx, edx
  00099	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0009c	03 ca		 add	 ecx, edx
  0009e	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000a1	03 ca		 add	 ecx, edx
  000a3	89 4d 08	 mov	 DWORD PTR tv303[ebp], ecx
  000a6	db 45 08	 fild	 DWORD PTR tv303[ebp]
  000a9	eb 53		 jmp	 SHORT $LN71@MissCheckP
$LN22@MissCheckP:

; 432  : 	}
; 433  : 	else if ( lpObj->Class == CLASS_MAGUMSA )

  000ab	83 f8 03	 cmp	 eax, 3
  000ae	75 2f		 jne	 SHORT $LN20@MissCheckP

; 434  : 	{
; 435  : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 35 ) / 10;	// #formula

  000b0	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  000b7	6b c9 23	 imul	 ecx, 35			; 00000023H
  000ba	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000bf	f7 e9		 imul	 ecx
  000c1	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000c8	c1 fa 02	 sar	 edx, 2
  000cb	8b ca		 mov	 ecx, edx
  000cd	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  000d0	03 ca		 add	 ecx, edx
  000d2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000d5	03 ca		 add	 ecx, edx
  000d7	89 4d 08	 mov	 DWORD PTR tv299[ebp], ecx
  000da	db 45 08	 fild	 DWORD PTR tv299[ebp]
  000dd	eb 1f		 jmp	 SHORT $LN71@MissCheckP
$LN20@MissCheckP:

; 436  : 	}
; 437  : 	else if ( lpObj->Class == CLASS_WIZARD )

  000df	66 85 c0	 test	 ax, ax
  000e2	75 1d		 jne	 SHORT $LN18@MissCheckP

; 438  : 	{
; 439  : 		iAttackRate = lpObj->Level * 3 + ( lpObj->Dexterity * 4 );	// #formula

  000e4	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  000eb	0f b7 8e b6 00
	00 00		 movzx	 ecx, WORD PTR [esi+182]
  000f2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  000f5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000f8	89 45 08	 mov	 DWORD PTR tv298[ebp], eax
  000fb	db 45 08	 fild	 DWORD PTR tv298[ebp]
$LN71@MissCheckP:
  000fe	d9 5d fc	 fstp	 DWORD PTR _iAttackRate$[ebp]
$LN18@MissCheckP:

; 440  : 	}
; 441  : 
; 442  : 	if ( lpTargetObj->Class == CLASS_KNIGHT )

  00101	8b 5d 0c	 mov	 ebx, DWORD PTR _lpTargetObj$[ebp]
  00104	0f b7 83 98 00
	00 00		 movzx	 eax, WORD PTR [ebx+152]
  0010b	83 f8 01	 cmp	 eax, 1
  0010e	75 1e		 jne	 SHORT $LN17@MissCheckP

; 443  : 	{
; 444  : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 2;	// #formula

  00110	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  00117	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  0011e	d1 e9		 shr	 ecx, 1
  00120	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00123	89 45 08	 mov	 DWORD PTR tv295[ebp], eax
  00126	db 45 08	 fild	 DWORD PTR tv295[ebp]
  00129	e9 8f 00 00 00	 jmp	 $LN72@MissCheckP
$LN17@MissCheckP:

; 445  : 	}
; 446  : 	else if ( lpTargetObj->Class == CLASS_DARKLORD )

  0012e	83 f8 04	 cmp	 eax, 4
  00131	75 1b		 jne	 SHORT $LN15@MissCheckP

; 447  : 	{
; 448  : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 2;	// #formula

  00133	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  0013a	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  00141	d1 e9		 shr	 ecx, 1
  00143	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00146	89 45 08	 mov	 DWORD PTR tv294[ebp], eax
  00149	db 45 08	 fild	 DWORD PTR tv294[ebp]
  0014c	eb 6f		 jmp	 SHORT $LN72@MissCheckP
$LN15@MissCheckP:

; 449  : 	}
; 450  : 	else if ( lpTargetObj->Class == CLASS_ELF )

  0014e	83 f8 02	 cmp	 eax, 2
  00151	75 2a		 jne	 SHORT $LN13@MissCheckP

; 451  : 	{
; 452  : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 10;	// #formula

  00153	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  0015a	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0015f	f7 e9		 imul	 ecx
  00161	c1 fa 02	 sar	 edx, 2
  00164	8b ca		 mov	 ecx, edx
  00166	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00169	03 ca		 add	 ecx, edx
  0016b	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  00172	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00175	89 45 08	 mov	 DWORD PTR tv288[ebp], eax
  00178	db 45 08	 fild	 DWORD PTR tv288[ebp]
  0017b	eb 40		 jmp	 SHORT $LN72@MissCheckP
$LN13@MissCheckP:

; 453  : 	}
; 454  : 	else if ( lpTargetObj->Class == CLASS_MAGUMSA )

  0017d	83 f8 03	 cmp	 eax, 3
  00180	75 1c		 jne	 SHORT $LN11@MissCheckP

; 455  : 	{
; 456  : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 4;	// #formula

  00182	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  00189	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  00190	c1 e9 02	 shr	 ecx, 2
  00193	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  00196	89 45 08	 mov	 DWORD PTR tv286[ebp], eax
  00199	db 45 08	 fild	 DWORD PTR tv286[ebp]
  0019c	eb 1f		 jmp	 SHORT $LN72@MissCheckP
$LN11@MissCheckP:

; 457  : 	}
; 458  : 	else if ( lpTargetObj->Class == CLASS_WIZARD )

  0019e	66 85 c0	 test	 ax, ax
  001a1	75 1d		 jne	 SHORT $LN9@MissCheckP

; 459  : 	{
; 460  : 		iDefenseRate = lpTargetObj->Level * 2 + lpTargetObj->Dexterity / 4;	// #formula

  001a3	0f b7 8b b6 00
	00 00		 movzx	 ecx, WORD PTR [ebx+182]
  001aa	0f bf 93 9c 00
	00 00		 movsx	 edx, WORD PTR [ebx+156]
  001b1	c1 e9 02	 shr	 ecx, 2
  001b4	8d 04 51	 lea	 eax, DWORD PTR [ecx+edx*2]
  001b7	89 45 08	 mov	 DWORD PTR tv282[ebp], eax
  001ba	db 45 08	 fild	 DWORD PTR tv282[ebp]
$LN72@MissCheckP:
  001bd	d9 5d f8	 fstp	 DWORD PTR _iDefenseRate$[ebp]
$LN9@MissCheckP:

; 461  : 	}
; 462  : 
; 463  : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || (DWORD)lpTargetObj <= 0 )	// #error lpTargetObj

  001c0	d9 45 fc	 fld	 DWORD PTR _iAttackRate$[ebp]
  001c3	d8 d1		 fcom	 ST(1)
  001c5	df e0		 fnstsw	 ax
  001c7	f6 c4 41	 test	 ah, 65			; 00000041H
  001ca	0f 8b fe 00 00
	00		 jnp	 $LN38@MissCheckP
  001d0	d9 45 f8	 fld	 DWORD PTR _iDefenseRate$[ebp]
  001d3	d8 d2		 fcom	 ST(2)
  001d5	df e0		 fnstsw	 ax
  001d7	dd da		 fstp	 ST(2)
  001d9	f6 c4 41	 test	 ah, 65			; 00000041H
  001dc	0f 8b fa 00 00
	00		 jnp	 $LN47@MissCheckP
  001e2	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  001e9	66 85 c0	 test	 ax, ax
  001ec	0f 8e ea 00 00
	00		 jle	 $LN47@MissCheckP
  001f2	85 db		 test	 ebx, ebx
  001f4	0f 84 e2 00 00
	00		 je	 $LN47@MissCheckP

; 465  : 
; 466  : 	float iExpressionA = ( iAttackRate * 10000.0f ) / ( iAttackRate + iDefenseRate );	// #formula
; 467  : 	float iExpressionB = ( lpObj->Level * 10000 ) / ( lpObj->Level + lpTargetObj->Level );	// #formula
; 468  : 
; 469  : 	iExpressionA /= 10000.0f;
; 470  : 	iExpressionB /= 10000.0f;
; 471  : 
; 472  : 	iAttackSuccessRate = 100.0f * iExpressionA * iExpressionB;

  001fa	d9 c0		 fld	 ST(0)
  001fc	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00203	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@40c3880000000000
  00209	57		 push	 edi
  0020a	dc c9		 fmul	 ST(1), ST(0)
  0020c	0f bf bb 9c 00
	00 00		 movsx	 edi, WORD PTR [ebx+156]
  00213	d9 cb		 fxch	 ST(3)
  00215	de c2		 faddp	 ST(2), ST(0)
  00217	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  0021a	69 c0 10 27 00
	00		 imul	 eax, 10000		; 00002710H
  00220	de f1		 fdivrp	 ST(1), ST(0)
  00222	99		 cdq
  00223	f7 f9		 idiv	 ecx
  00225	d9 5d 08	 fstp	 DWORD PTR tv255[ebp]
  00228	d9 45 08	 fld	 DWORD PTR tv255[ebp]
  0022b	d8 f1		 fdiv	 ST(0), ST(1)
  0022d	d9 5d 08	 fstp	 DWORD PTR tv320[ebp]
  00230	d9 45 08	 fld	 DWORD PTR tv320[ebp]
  00233	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4059000000000000
  00239	89 45 08	 mov	 DWORD PTR tv192[ebp], eax
  0023c	db 45 08	 fild	 DWORD PTR tv192[ebp]
  0023f	de f2		 fdivrp	 ST(2), ST(0)
  00241	d9 c9		 fxch	 ST(1)
  00243	d9 5d 08	 fstp	 DWORD PTR tv334[ebp]
  00246	d8 4d 08	 fmul	 DWORD PTR tv334[ebp]
  00249	e8 00 00 00 00	 call	 __ftol2_sse
  0024e	89 45 08	 mov	 DWORD PTR _iAttackSuccessRate$[ebp], eax

; 473  : 
; 474  : 	if ( (lpTargetObj->Level - lpObj->Level) >= 100 )

  00251	0f bf 86 9c 00
	00 00		 movsx	 eax, WORD PTR [esi+156]
  00258	2b f8		 sub	 edi, eax
  0025a	83 ff 64	 cmp	 edi, 100		; 00000064H
  0025d	5f		 pop	 edi
  0025e	7c 06		 jl	 SHORT $LN6@MissCheckP

; 475  : 	{
; 476  : 		iAttackSuccessRate -= 5;

  00260	83 6d 08 05	 sub	 DWORD PTR _iAttackSuccessRate$[ebp], 5
  00264	eb 2b		 jmp	 SHORT $LN2@MissCheckP
$LN6@MissCheckP:

; 477  : 	}
; 478  : 	else if ( (lpTargetObj->Level - lpObj->Level) >= 200 )

  00266	0f b7 86 9c 00
	00 00		 movzx	 eax, WORD PTR [esi+156]
  0026d	0f bf d0	 movsx	 edx, ax
  00270	0f bf 83 9c 00
	00 00		 movsx	 eax, WORD PTR [ebx+156]
  00277	2b c2		 sub	 eax, edx
  00279	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0027e	7c 06		 jl	 SHORT $LN4@MissCheckP

; 479  : 	{
; 480  : 		iAttackSuccessRate -= 10;

  00280	83 6d 08 0a	 sub	 DWORD PTR _iAttackSuccessRate$[ebp], 10 ; 0000000aH
  00284	eb 0b		 jmp	 SHORT $LN2@MissCheckP
$LN4@MissCheckP:

; 481  : 	}
; 482  : 	else if ( (lpTargetObj->Level - lpObj->Level) >= 300 )

  00286	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  0028b	7c 04		 jl	 SHORT $LN2@MissCheckP

; 483  : 	{
; 484  : 		iAttackSuccessRate -= 15;

  0028d	83 6d 08 0f	 sub	 DWORD PTR _iAttackSuccessRate$[ebp], 15 ; 0000000fH
$LN2@MissCheckP:

; 485  : 	}
; 486  : 
; 487  : 	DWORD dwRate = rand() % 100;

  00291	e8 00 00 00 00	 call	 _rand
  00296	99		 cdq
  00297	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0029c	f7 f9		 idiv	 ecx

; 488  : 
; 489  : 	if ( dwRate > iAttackSuccessRate )

  0029e	3b 55 08	 cmp	 edx, DWORD PTR _iAttackSuccessRate$[ebp]
  002a1	76 1e		 jbe	 SHORT $LN1@MissCheckP

; 490  : 	{
; 491  : 		GCDamageSend(lpObj->m_Index, lpTargetObj->m_Index, 0, 0, 0);

  002a3	8b 13		 mov	 edx, DWORD PTR [ebx]
  002a5	8b 06		 mov	 eax, DWORD PTR [esi]
  002a7	6a 00		 push	 0
  002a9	6a 00		 push	 0
  002ab	6a 00		 push	 0
  002ad	52		 push	 edx
  002ae	50		 push	 eax
  002af	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  002b4	83 c4 14	 add	 esp, 20			; 00000014H
  002b7	5e		 pop	 esi
  002b8	33 c0		 xor	 eax, eax
  002ba	5b		 pop	 ebx

; 496  : }

  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c2 18 00	 ret	 24			; 00000018H
$LN1@MissCheckP:
  002c1	5e		 pop	 esi

; 492  : 		return FALSE;
; 493  : 	}
; 494  : 
; 495  : 	return TRUE;

  002c2	b8 01 00 00 00	 mov	 eax, 1
  002c7	5b		 pop	 ebx

; 496  : }

  002c8	8b e5		 mov	 esp, ebp
  002ca	5d		 pop	 ebp
  002cb	c2 18 00	 ret	 24			; 00000018H
$LN38@MissCheckP:

; 461  : 	}
; 462  : 
; 463  : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || (DWORD)lpTargetObj <= 0 )	// #error lpTargetObj

  002ce	dd d9		 fstp	 ST(1)
  002d0	5e		 pop	 esi
  002d1	dd d8		 fstp	 ST(0)

; 464  : 		return FALSE;

  002d3	33 c0		 xor	 eax, eax
  002d5	5b		 pop	 ebx

; 496  : }

  002d6	8b e5		 mov	 esp, ebp
  002d8	5d		 pop	 ebp
  002d9	c2 18 00	 ret	 24			; 00000018H
$LN47@MissCheckP:

; 461  : 	}
; 462  : 
; 463  : 	if ( iAttackRate <= 0.0f || iDefenseRate <= 0.0f || lpObj->Level <= 0 || (DWORD)lpTargetObj <= 0 )	// #error lpTargetObj

  002dc	dd d8		 fstp	 ST(0)
  002de	5e		 pop	 esi
  002df	dd d8		 fstp	 ST(0)

; 464  : 		return FALSE;

  002e1	33 c0		 xor	 eax, eax
  002e3	5b		 pop	 ebx

; 496  : }

  002e4	8b e5		 mov	 esp, ebp
  002e6	5d		 pop	 ebp
  002e7	c2 18 00	 ret	 24			; 00000018H
?MissCheckPvP@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0HHHAAH@Z ENDP ; CObjBaseAttack::MissCheckPvP
_TEXT	ENDS
PUBLIC	?GetTargetDefense@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0AAE@Z ; CObjBaseAttack::GetTargetDefense
EXTRN	?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ:PROC	; CItem::IsWingOpGetOnePercentDamage
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
; Function compile flags: /Ogtp
;	COMDAT ?GetTargetDefense@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0AAE@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_MsgDamage$ = 16					; size = 4
?GetTargetDefense@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0AAE@Z PROC ; CObjBaseAttack::GetTargetDefense, COMDAT
; _this$ = ecx

; 499  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 500  : 	int skilldefense = lpTargetObj->m_SkillDefense;
; 501  : 	int targetdefense = lpTargetObj->m_Defense + skilldefense;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]

; 502  : 
; 503  : 	targetdefense -= (targetdefense * lpTargetObj->m_SkillMagumReduceDefense)/100;

  00006	8b 88 a0 02 00
	00		 mov	 ecx, DWORD PTR [eax+672]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b b0 10 03 00
	00		 mov	 esi, DWORD PTR [eax+784]
  00014	03 b0 78 02 00
	00		 add	 esi, DWORD PTR [eax+632]

; 504  : 	
; 505  : 	int percentdamage = 0;
; 506  : 
; 507  : 	if ( lpObj->pInventory[7].IsItem() != FALSE )

  0001a	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  0001d	0f af ce	 imul	 ecx, esi
  00020	b8 e1 7a 14 ae	 mov	 eax, -1374389535	; ae147ae1H
  00025	f7 e9		 imul	 ecx
  00027	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  0002d	c1 fa 05	 sar	 edx, 5
  00030	8b c2		 mov	 eax, edx
  00032	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00035	03 c2		 add	 eax, edx
  00037	57		 push	 edi
  00038	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  0003e	03 f0		 add	 esi, eax
  00040	33 ff		 xor	 edi, edi
  00042	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00047	85 c0		 test	 eax, eax
  00049	74 13		 je	 SHORT $LN3@GetTargetD

; 508  : 	{
; 509  : 		percentdamage = lpObj->pInventory[7].IsWingOpGetOnePercentDamage();

  0004b	8b 8b 8c 0c 00
	00		 mov	 ecx, DWORD PTR [ebx+3212]
  00051	81 c1 98 04 00
	00		 add	 ecx, 1176		; 00000498H
  00057	e8 00 00 00 00	 call	 ?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ ; CItem::IsWingOpGetOnePercentDamage
  0005c	8b f8		 mov	 edi, eax
$LN3@GetTargetD:

; 510  : 	}
; 511  : 
; 512  : 	percentdamage += lpObj->SetOpIgnoreDefense;

  0005e	0f b6 8b 7a 0f
	00 00		 movzx	 ecx, BYTE PTR [ebx+3962]
  00065	03 f9		 add	 edi, ecx

; 513  : 
; 514  : 	if ( percentdamage != 0)

  00067	74 20		 je	 SHORT $LN7@GetTargetD

; 515  : 	{
; 516  : 		if ( (rand()%100) <= percentdamage)

  00069	e8 00 00 00 00	 call	 _rand
  0006e	99		 cdq
  0006f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00074	f7 f9		 idiv	 ecx
  00076	3b d7		 cmp	 edx, edi
  00078	7f 0f		 jg	 SHORT $LN7@GetTargetD

; 517  : 		{
; 518  : 			targetdefense = 0;
; 519  : 			MsgDamage = 1;

  0007a	8b 55 10	 mov	 edx, DWORD PTR _MsgDamage$[ebp]
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	33 c0		 xor	 eax, eax
  00081	c6 02 01	 mov	 BYTE PTR [edx], 1
  00084	5b		 pop	 ebx

; 524  : }

  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
$LN7@GetTargetD:
  00089	5f		 pop	 edi

; 520  : 		}
; 521  : 	}
; 522  : 
; 523  : 	return targetdefense;

  0008a	8b c6		 mov	 eax, esi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 524  : }

  0008e	5d		 pop	 ebp
  0008f	c2 0c 00	 ret	 12			; 0000000cH
?GetTargetDefense@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@0AAE@Z ENDP ; CObjBaseAttack::GetTargetDefense
_TEXT	ENDS
PUBLIC	??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@ ; `string'
PUBLIC	??_C@_0BC@NHPGBLMH@ObjBaseAttack?4cpp?$AA@	; `string'
PUBLIC	?GetPartyMemberCount@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z ; CObjBaseAttack::GetPartyMemberCount
EXTRN	?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:BYTE			; gObj
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
;	COMDAT ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@
CONST	SEGMENT
??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@ DB 'error : De'
	DB	'cPartyMemberHPandMP %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHPGBLMH@ObjBaseAttack?4cpp?$AA@
CONST	SEGMENT
??_C@_0BC@NHPGBLMH@ObjBaseAttack?4cpp?$AA@ DB 'ObjBaseAttack.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?GetPartyMemberCount@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_retcount$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?GetPartyMemberCount@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z PROC ; CObjBaseAttack::GetPartyMemberCount, COMDAT
; _this$ = ecx

; 527  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 528  : 	LPOBJ lpPartyObj;
; 529  : 	int partynum = lpObj->PartyNumber;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00007	8b 83 a8 02 00
	00		 mov	 eax, DWORD PTR [ebx+680]

; 530  : 
; 531  : 	if ( OBJMAX_RANGE(partynum) == FALSE )

  0000d	85 c0		 test	 eax, eax
  0000f	78 0e		 js	 SHORT $LN14@GetPartyMe
  00011	33 c9		 xor	 ecx, ecx
  00013	3d e7 1c 00 00	 cmp	 eax, 7399		; 00001ce7H
  00018	0f 9e c1	 setle	 cl
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 20		 jne	 SHORT $LN7@GetPartyMe
$LN14@GetPartyMe:

; 532  : 	{
; 533  : 		LogAdd(LOG_BLACK, "error : DecPartyMemberHPandMP %s %d", __FILE__, __LINE__);

  0001f	68 15 02 00 00	 push	 533			; 00000215H
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NHPGBLMH@ObjBaseAttack?4cpp?$AA@
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CFs@
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 ?LogAdd@@YAXW4eLogColor@@PADZZ ; LogAdd
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 534  : 		return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	5b		 pop	 ebx

; 561  : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN7@GetPartyMe:
  0003f	56		 push	 esi

; 535  : 	}
; 536  : 
; 537  : 	int partycount = gParty.m_PartyS[partynum].Count;
; 538  : 	int retcount = 0;

  00040	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  00043	c1 e6 04	 shl	 esi, 4
  00046	57		 push	 edi
  00047	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _retcount$[ebp], 0
  0004e	81 c6 0c 00 00
	00		 add	 esi, OFFSET ?gParty@@3VPartyClass@@A+12
  00054	bf 05 00 00 00	 mov	 edi, 5
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL6@GetPartyMe:

; 541  : 	{
; 542  : 		int memberindex = gParty.m_PartyS[partynum].Number[n];

  00060	8b 06		 mov	 eax, DWORD PTR [esi]

; 543  : 
; 544  : 		if ( memberindex >= 0 )

  00062	85 c0		 test	 eax, eax
  00064	78 2c		 js	 SHORT $LN5@GetPartyMe

; 545  : 		{
; 546  : 			lpPartyObj = &gObj[memberindex];
; 547  : 
; 548  : 			if ( lpObj->MapNumber == lpPartyObj->MapNumber )

  00066	8a 8b 09 01 00
	00		 mov	 cl, BYTE PTR [ebx+265]
  0006c	69 c0 64 15 00
	00		 imul	 eax, 5476		; 00001564H
  00072	3a 88 09 01 00
	00		 cmp	 cl, BYTE PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax+265]
  00078	75 18		 jne	 SHORT $LN5@GetPartyMe

; 549  : 			{
; 550  : 				int dis = gObjCalDistance(lpObj, &gObj[memberindex]);

  0007a	8d 90 00 00 00
	00		 lea	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A[eax]
  00080	52		 push	 edx
  00081	53		 push	 ebx
  00082	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAUOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00087	83 c4 08	 add	 esp, 8

; 551  : 				
; 552  : 				if ( dis < MAX_PARTY_DISTANCE_EFFECT )

  0008a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0008d	7d 03		 jge	 SHORT $LN5@GetPartyMe

; 553  : 				{
; 554  : 					retcount++;

  0008f	ff 45 08	 inc	 DWORD PTR _retcount$[ebp]
$LN5@GetPartyMe:

; 539  : 
; 540  : 	for ( int n=0;n<MAX_USER_IN_PARTY;n++)

  00092	83 c6 04	 add	 esi, 4
  00095	4f		 dec	 edi
  00096	75 c8		 jne	 SHORT $LL6@GetPartyMe

; 555  : 				}
; 556  : 			}
; 557  : 		}
; 558  : 	}
; 559  : 
; 560  : 	return retcount;

  00098	8b 45 08	 mov	 eax, DWORD PTR _retcount$[ebp]
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx

; 561  : }

  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
?GetPartyMemberCount@CObjBaseAttack@@QAEHPAUOBJECTSTRUCT@@@Z ENDP ; CObjBaseAttack::GetPartyMemberCount
_TEXT	ENDS
PUBLIC	?Init@ComboSkillData@@QAEXXZ			; ComboSkillData::Init
; Function compile flags: /Ogtp
;	COMDAT ?Init@ComboSkillData@@QAEXXZ
_TEXT	SEGMENT
?Init@ComboSkillData@@QAEXXZ PROC			; ComboSkillData::Init, COMDAT
; _this$ = ecx

; 566  : 	this->dwTime = 0;
; 567  : 	this->Skill[0] = -1;

  00000	b0 ff		 mov	 al, 255			; 000000ffH
  00002	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00008	66 c7 41 04 ff
	ff		 mov	 WORD PTR [ecx+4], 65535	; 0000ffffH

; 568  : 	this->Skill[1] = -1;
; 569  : 	this->Skill[2] = -1;

  0000e	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 570  : 	this->ProgressIndex = -1;

  00011	c7 41 08 ff ff
	ff ff		 mov	 DWORD PTR [ecx+8], -1

; 571  : }	// line : 23

  00018	c3		 ret	 0
?Init@ComboSkillData@@QAEXXZ ENDP			; ComboSkillData::Init
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCObjBaseAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCObjBaseAttack@@UAEPAXI@Z PROC			; CObjBaseAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCObjBaseAttack@@UAEPAXI@Z ENDP			; CObjBaseAttack::`scalar deleting destructor'
_TEXT	ENDS
END
