; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\faelhs\mu-1.1\eMu - GameServer Sapphire S0\GameServer\CSQLValue.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?RTrim@CSQLValue@@AAEHPADH@Z			; CSQLValue::RTrim
; Function compile flags: /Ogtp
; File c:\users\faelhs\mu-1.1\emu - gameserver sapphire s0\gameserver\csqlvalue.cpp
;	COMDAT ?RTrim@CSQLValue@@AAEHPADH@Z
_TEXT	SEGMENT
_sData$ = 8						; size = 4
_iDataSz$ = 12						; size = 4
?RTrim@CSQLValue@@AAEHPADH@Z PROC			; CSQLValue::RTrim, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 23   : 	int iPos = iDataSz;
; 24   : 
; 25   : 	if(iDataSz == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iDataSz$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 04		 jne	 SHORT $LN5@RTrim

; 40   : 
; 41   : 	return iPos; //Return the new data length.
; 42   : }

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
$LN5@RTrim:

; 26   : 		return iDataSz;//Return the new data length.
; 27   : 
; 28   : 	if(sData[iDataSz-1] != ' ')

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _sData$[ebp]
  00011	80 7c 01 ff 20	 cmp	 BYTE PTR [ecx+eax-1], 32 ; 00000020H

; 29   : 		return iDataSz;//Return the new data length.

  00016	75 1c		 jne	 SHORT $LN6@RTrim

; 30   : 
; 31   : 	iPos--;

  00018	48		 dec	 eax

; 32   : 
; 33   : 	while(iPos != 0 && sData[iPos] == ' ')

  00019	74 0e		 je	 SHORT $LN2@RTrim
  0001b	eb 03 8d 49 00	 npad	 5
$LL3@RTrim:
  00020	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  00024	75 09		 jne	 SHORT $LN11@RTrim

; 34   : 		iPos--;

  00026	48		 dec	 eax

; 32   : 
; 33   : 	while(iPos != 0 && sData[iPos] == ' ')

  00027	75 f7		 jne	 SHORT $LL3@RTrim
$LN2@RTrim:

; 35   : 
; 36   : 	if(sData[iPos] != ' ')

  00029	80 3c 08 20	 cmp	 BYTE PTR [eax+ecx], 32	; 00000020H
  0002d	74 01		 je	 SHORT $LN1@RTrim
$LN11@RTrim:

; 37   : 		iPos++;

  0002f	40		 inc	 eax
$LN1@RTrim:

; 38   : 
; 39   : 	sData[iPos] = '\0';

  00030	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN6@RTrim:

; 40   : 
; 41   : 	return iPos; //Return the new data length.
; 42   : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?RTrim@CSQLValue@@AAEHPADH@Z ENDP			; CSQLValue::RTrim
_TEXT	ENDS
PUBLIC	?ReplaceSingleQuotes@CSQLValue@@AAEXPADH@Z	; CSQLValue::ReplaceSingleQuotes
; Function compile flags: /Ogtp
;	COMDAT ?ReplaceSingleQuotes@CSQLValue@@AAEXPADH@Z
_TEXT	SEGMENT
_sData$ = 8						; size = 4
_iDataSz$ = 12						; size = 4
?ReplaceSingleQuotes@CSQLValue@@AAEXPADH@Z PROC		; CSQLValue::ReplaceSingleQuotes, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 	int iRPos = 0;
; 49   : 
; 50   : 	while(iRPos < iDataSz)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _iDataSz$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 d2		 test	 edx, edx
  0000a	7e 13		 jle	 SHORT $LN2@ReplaceSin
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _sData$[ebp]
  0000f	90		 npad	 1
$LL3@ReplaceSin:

; 51   : 	{
; 52   : 		if(sData[iRPos] == '\'')

  00010	80 3c 08 27	 cmp	 BYTE PTR [eax+ecx], 39	; 00000027H
  00014	75 04		 jne	 SHORT $LN1@ReplaceSin

; 53   : 		{
; 54   : 			sData[iRPos] = '`';

  00016	c6 04 08 60	 mov	 BYTE PTR [eax+ecx], 96	; 00000060H
$LN1@ReplaceSin:

; 55   : 		}
; 56   : 		iRPos++;

  0001a	40		 inc	 eax
  0001b	3b c2		 cmp	 eax, edx
  0001d	7c f1		 jl	 SHORT $LL3@ReplaceSin
$LN2@ReplaceSin:

; 57   : 	}
; 58   : }

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?ReplaceSingleQuotes@CSQLValue@@AAEXPADH@Z ENDP		; CSQLValue::ReplaceSingleQuotes
_TEXT	ENDS
PUBLIC	?Initialize@CSQLValue@@QAEXPAU_TAG_COLUMNINFO@@_N11@Z ; CSQLValue::Initialize
; Function compile flags: /Ogtp
;	COMDAT ?Initialize@CSQLValue@@QAEXPAU_TAG_COLUMNINFO@@_N11@Z
_TEXT	SEGMENT
_lpColumnValue$ = 8					; size = 4
_bTrimCharData$ = 12					; size = 1
_bReplaceSingleQuotes$ = 16				; size = 1
_bThrowErrors$ = 20					; size = 1
?Initialize@CSQLValue@@QAEXPAU_TAG_COLUMNINFO@@_N11@Z PROC ; CSQLValue::Initialize, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 65   : 	this->bcTrimCharData = bTrimCharData;

  00003	8a 45 0c	 mov	 al, BYTE PTR _bTrimCharData$[ebp]

; 66   : 	this->bcReplaceSingleQuotes = bReplaceSingleQuotes;

  00006	8a 55 10	 mov	 dl, BYTE PTR _bReplaceSingleQuotes$[ebp]
  00009	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 67   : 	this->bcThrowErrors = bThrowErrors;

  0000c	8a 45 14	 mov	 al, BYTE PTR _bThrowErrors$[ebp]
  0000f	88 51 05	 mov	 BYTE PTR [ecx+5], dl

; 68   : 	this->lpCValue = lpColumnValue;

  00012	8b 55 08	 mov	 edx, DWORD PTR _lpColumnValue$[ebp]
  00015	88 41 06	 mov	 BYTE PTR [ecx+6], al
  00018	89 11		 mov	 DWORD PTR [ecx], edx

; 69   : }

  0001a	5d		 pop	 ebp
  0001b	c2 10 00	 ret	 16			; 00000010H
?Initialize@CSQLValue@@QAEXPAU_TAG_COLUMNINFO@@_N11@Z ENDP ; CSQLValue::Initialize
_TEXT	ENDS
PUBLIC	?IsValid@CSQLValue@@QAE_NXZ			; CSQLValue::IsValid
; Function compile flags: /Ogtp
;	COMDAT ?IsValid@CSQLValue@@QAE_NXZ
_TEXT	SEGMENT
?IsValid@CSQLValue@@QAE_NXZ PROC			; CSQLValue::IsValid, COMDAT
; _this$ = ecx

; 75   : 	return this->bcIsValid;

  00000	8a 41 07	 mov	 al, BYTE PTR [ecx+7]

; 76   : }

  00003	c3		 ret	 0
?IsValid@CSQLValue@@QAE_NXZ ENDP			; CSQLValue::IsValid
_TEXT	ENDS
PUBLIC	?IsNull@CSQLValue@@QAE_NXZ			; CSQLValue::IsNull
; Function compile flags: /Ogtp
;	COMDAT ?IsNull@CSQLValue@@QAE_NXZ
_TEXT	SEGMENT
?IsNull@CSQLValue@@QAE_NXZ PROC				; CSQLValue::IsNull, COMDAT
; _this$ = ecx

; 82   : 	return this->lpCValue->Data.IsNull;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8a 40 08	 mov	 al, BYTE PTR [eax+8]

; 83   : }

  00005	c3		 ret	 0
?IsNull@CSQLValue@@QAE_NXZ ENDP				; CSQLValue::IsNull
_TEXT	ENDS
PUBLIC	?Size@CSQLValue@@QAEHXZ				; CSQLValue::Size
; Function compile flags: /Ogtp
;	COMDAT ?Size@CSQLValue@@QAEHXZ
_TEXT	SEGMENT
?Size@CSQLValue@@QAEHXZ PROC				; CSQLValue::Size, COMDAT
; _this$ = ecx

; 89   : 	return this->lpCValue->Data.Size;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 90   : }

  00005	c3		 ret	 0
?Size@CSQLValue@@QAEHXZ ENDP				; CSQLValue::Size
_TEXT	ENDS
PUBLIC	?ToString@CSQLValue@@QAEPADXZ			; CSQLValue::ToString
; Function compile flags: /Ogtp
;	COMDAT ?ToString@CSQLValue@@QAEPADXZ
_TEXT	SEGMENT
?ToString@CSQLValue@@QAEPADXZ PROC			; CSQLValue::ToString, COMDAT
; _this$ = ecx

; 110  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 111  : 	if(this->lpCValue->Data.IsNull)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00009	74 04		 je	 SHORT $LN9@ToString

; 112  : 	{
; 113  : 		return NULL;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 135  : }

  0000e	c3		 ret	 0
$LN9@ToString:

; 114  : 	}
; 115  : 
; 116  : 	if(this->lpCValue->DataType == SQLTypes::Char || this->lpCValue->DataType == SQLTypes::NChar)

  0000f	8b 88 0c 04 00
	00		 mov	 ecx, DWORD PTR [eax+1036]
  00015	83 f9 01	 cmp	 ecx, 1
  00018	74 2f		 je	 SHORT $LN7@ToString
  0001a	81 f9 f8 ff 00
	00		 cmp	 ecx, 65528		; 0000fff8H
  00020	74 27		 je	 SHORT $LN7@ToString

; 125  : 		}
; 126  : 	}
; 127  : 	else if(this->lpCValue->DataType == SQLTypes::VarChar || this->lpCValue->DataType == SQLTypes::NVarChar)

  00022	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00025	74 08		 je	 SHORT $LN2@ToString
  00027	81 f9 f7 ff 00
	00		 cmp	 ecx, 65527		; 0000fff7H
  0002d	75 44		 jne	 SHORT $LN5@ToString
$LN2@ToString:

; 128  : 	{
; 129  : 		if(this->bcReplaceSingleQuotes)

  0002f	80 7e 05 00	 cmp	 BYTE PTR [esi+5], 0
  00033	74 3e		 je	 SHORT $LN5@ToString

; 123  : 		{
; 124  : 			this->ReplaceSingleQuotes(((char *)this->lpCValue->Data.Buffer), this->lpCValue->Data.Size);

  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	8b 10		 mov	 edx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	52		 push	 edx
  0003c	8b ce		 mov	 ecx, esi
  0003e	e8 00 00 00 00	 call	 ?ReplaceSingleQuotes@CSQLValue@@AAEXPADH@Z ; CSQLValue::ReplaceSingleQuotes

; 130  : 		{
; 131  : 			this->ReplaceSingleQuotes(((char *)this->lpCValue->Data.Buffer), this->lpCValue->Data.Size);
; 132  : 		}
; 133  : 	}
; 134  : 	return (char *)this->lpCValue->Data.Buffer;

  00043	8b 06		 mov	 eax, DWORD PTR [esi]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	5e		 pop	 esi

; 135  : }

  00048	c3		 ret	 0
$LN7@ToString:

; 117  : 	{
; 118  : 		if(this->bcTrimCharData)

  00049	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0004d	74 0e		 je	 SHORT $LN6@ToString

; 119  : 		{
; 120  : 			this->RTrim(((char *)this->lpCValue->Data.Buffer), this->lpCValue->Data.Size);

  0004f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00052	8b 10		 mov	 edx, DWORD PTR [eax]
  00054	51		 push	 ecx
  00055	52		 push	 edx
  00056	8b ce		 mov	 ecx, esi
  00058	e8 00 00 00 00	 call	 ?RTrim@CSQLValue@@AAEHPADH@Z ; CSQLValue::RTrim
$LN6@ToString:

; 121  : 		}
; 122  : 		if(this->bcReplaceSingleQuotes)

  0005d	80 7e 05 00	 cmp	 BYTE PTR [esi+5], 0
  00061	74 10		 je	 SHORT $LN5@ToString

; 123  : 		{
; 124  : 			this->ReplaceSingleQuotes(((char *)this->lpCValue->Data.Buffer), this->lpCValue->Data.Size);

  00063	8b 06		 mov	 eax, DWORD PTR [esi]
  00065	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00068	8b 10		 mov	 edx, DWORD PTR [eax]
  0006a	51		 push	 ecx
  0006b	52		 push	 edx
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?ReplaceSingleQuotes@CSQLValue@@AAEXPADH@Z ; CSQLValue::ReplaceSingleQuotes
$LN5@ToString:

; 130  : 		{
; 131  : 			this->ReplaceSingleQuotes(((char *)this->lpCValue->Data.Buffer), this->lpCValue->Data.Size);
; 132  : 		}
; 133  : 	}
; 134  : 	return (char *)this->lpCValue->Data.Buffer;

  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	8b 00		 mov	 eax, DWORD PTR [eax]
  00077	5e		 pop	 esi

; 135  : }

  00078	c3		 ret	 0
?ToString@CSQLValue@@QAEPADXZ ENDP			; CSQLValue::ToString
_TEXT	ENDS
PUBLIC	?ToBoolean@CSQLValue@@QAE_NXZ			; CSQLValue::ToBoolean
; Function compile flags: /Ogtp
;	COMDAT ?ToBoolean@CSQLValue@@QAE_NXZ
_TEXT	SEGMENT
?ToBoolean@CSQLValue@@QAE_NXZ PROC			; CSQLValue::ToBoolean, COMDAT
; _this$ = ecx

; 141  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToBoolean

; 142  : 	{
; 143  : 		return 0;

  00008	32 c0		 xor	 al, al

; 146  : }

  0000a	c3		 ret	 0
$LN1@ToBoolean:

; 144  : 	}
; 145  : 	return *(bool *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	8a 00		 mov	 al, BYTE PTR [eax]

; 146  : }

  0000f	c3		 ret	 0
?ToBoolean@CSQLValue@@QAE_NXZ ENDP			; CSQLValue::ToBoolean
_TEXT	ENDS
PUBLIC	?ToIntegerS@CSQLValue@@QAEHXZ			; CSQLValue::ToIntegerS
; Function compile flags: /Ogtp
;	COMDAT ?ToIntegerS@CSQLValue@@QAEHXZ
_TEXT	SEGMENT
?ToIntegerS@CSQLValue@@QAEHXZ PROC			; CSQLValue::ToIntegerS, COMDAT
; _this$ = ecx

; 153  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToIntegerS

; 154  : 	{
; 155  : 		return 0;

  00008	33 c0		 xor	 eax, eax

; 158  : }

  0000a	c3		 ret	 0
$LN1@ToIntegerS:

; 156  : 	}
; 157  : 	return *(signed int *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 158  : }

  0000f	c3		 ret	 0
?ToIntegerS@CSQLValue@@QAEHXZ ENDP			; CSQLValue::ToIntegerS
_TEXT	ENDS
PUBLIC	?ToIntegerU@CSQLValue@@QAEIXZ			; CSQLValue::ToIntegerU
; Function compile flags: /Ogtp
;	COMDAT ?ToIntegerU@CSQLValue@@QAEIXZ
_TEXT	SEGMENT
?ToIntegerU@CSQLValue@@QAEIXZ PROC			; CSQLValue::ToIntegerU, COMDAT
; _this$ = ecx

; 164  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToIntegerU

; 165  : 	{
; 166  : 		return 0;

  00008	33 c0		 xor	 eax, eax

; 169  : }

  0000a	c3		 ret	 0
$LN1@ToIntegerU:

; 167  : 	}
; 168  : 	return *(unsigned int *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]

; 169  : }

  0000f	c3		 ret	 0
?ToIntegerU@CSQLValue@@QAEIXZ ENDP			; CSQLValue::ToIntegerU
_TEXT	ENDS
PUBLIC	?ToShortS@CSQLValue@@QAEFXZ			; CSQLValue::ToShortS
; Function compile flags: /Ogtp
;	COMDAT ?ToShortS@CSQLValue@@QAEFXZ
_TEXT	SEGMENT
?ToShortS@CSQLValue@@QAEFXZ PROC			; CSQLValue::ToShortS, COMDAT
; _this$ = ecx

; 175  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToShortS

; 176  : 	{
; 177  : 		return 0;

  00008	33 c0		 xor	 eax, eax

; 180  : }

  0000a	c3		 ret	 0
$LN1@ToShortS:

; 178  : 	}
; 179  : 	return *(signed short *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	66 8b 00	 mov	 ax, WORD PTR [eax]

; 180  : }

  00010	c3		 ret	 0
?ToShortS@CSQLValue@@QAEFXZ ENDP			; CSQLValue::ToShortS
_TEXT	ENDS
PUBLIC	?ToShortU@CSQLValue@@QAEGXZ			; CSQLValue::ToShortU
; Function compile flags: /Ogtp
;	COMDAT ?ToShortU@CSQLValue@@QAEGXZ
_TEXT	SEGMENT
?ToShortU@CSQLValue@@QAEGXZ PROC			; CSQLValue::ToShortU, COMDAT
; _this$ = ecx

; 186  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToShortU

; 187  : 	{
; 188  : 		return 0;

  00008	33 c0		 xor	 eax, eax

; 191  : }

  0000a	c3		 ret	 0
$LN1@ToShortU:

; 189  : 	}
; 190  : 	return *(unsigned short *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	66 8b 00	 mov	 ax, WORD PTR [eax]

; 191  : }

  00010	c3		 ret	 0
?ToShortU@CSQLValue@@QAEGXZ ENDP			; CSQLValue::ToShortU
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?ToDouble@CSQLValue@@QAENXZ			; CSQLValue::ToDouble
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ToDouble@CSQLValue@@QAENXZ
_TEXT	SEGMENT
?ToDouble@CSQLValue@@QAENXZ PROC			; CSQLValue::ToDouble, COMDAT
; _this$ = ecx

; 197  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToDouble

; 198  : 	{
; 199  : 		return 0;

  00008	d9 ee		 fldz

; 202  : }

  0000a	c3		 ret	 0
$LN1@ToDouble:

; 200  : 	}
; 201  : 	return *(double *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	dd 00		 fld	 QWORD PTR [eax]

; 202  : }

  0000f	c3		 ret	 0
?ToDouble@CSQLValue@@QAENXZ ENDP			; CSQLValue::ToDouble
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?ToFloat@CSQLValue@@QAEMXZ			; CSQLValue::ToFloat
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ToFloat@CSQLValue@@QAEMXZ
_TEXT	SEGMENT
?ToFloat@CSQLValue@@QAEMXZ PROC				; CSQLValue::ToFloat, COMDAT
; _this$ = ecx

; 208  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 03		 je	 SHORT $LN1@ToFloat

; 209  : 	{
; 210  : 		return 0;

  00008	d9 ee		 fldz

; 213  : }

  0000a	c3		 ret	 0
$LN1@ToFloat:

; 211  : 	}
; 212  : 	return *(float *)this->lpCValue->Data.Buffer;

  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	d9 00		 fld	 DWORD PTR [eax]

; 213  : }

  0000f	c3		 ret	 0
?ToFloat@CSQLValue@@QAEMXZ ENDP				; CSQLValue::ToFloat
_TEXT	ENDS
PUBLIC	?ToI64U@CSQLValue@@QAE_KXZ			; CSQLValue::ToI64U
; Function compile flags: /Ogtp
;	COMDAT ?ToI64U@CSQLValue@@QAE_KXZ
_TEXT	SEGMENT
?ToI64U@CSQLValue@@QAE_KXZ PROC				; CSQLValue::ToI64U, COMDAT
; _this$ = ecx

; 219  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 05		 je	 SHORT $LN1@ToI64U

; 220  : 	{
; 221  : 		return 0;

  00008	33 c0		 xor	 eax, eax
  0000a	33 d2		 xor	 edx, edx

; 224  : }

  0000c	c3		 ret	 0
$LN1@ToI64U:

; 222  : 	}
; 223  : 	return *(unsigned __int64 *)this->lpCValue->Data.Buffer;

  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 224  : }

  00014	c3		 ret	 0
?ToI64U@CSQLValue@@QAE_KXZ ENDP				; CSQLValue::ToI64U
_TEXT	ENDS
PUBLIC	?ToI64S@CSQLValue@@QAE_JXZ			; CSQLValue::ToI64S
; Function compile flags: /Ogtp
;	COMDAT ?ToI64S@CSQLValue@@QAE_JXZ
_TEXT	SEGMENT
?ToI64S@CSQLValue@@QAE_JXZ PROC				; CSQLValue::ToI64S, COMDAT
; _this$ = ecx

; 230  : 	if(this->lpCValue->Data.IsNull)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  00006	74 05		 je	 SHORT $LN1@ToI64S

; 231  : 	{
; 232  : 		return 0;

  00008	33 c0		 xor	 eax, eax
  0000a	33 d2		 xor	 edx, edx

; 235  : }

  0000c	c3		 ret	 0
$LN1@ToI64S:

; 233  : 	}
; 234  : 	return *(signed __int64 *)this->lpCValue->Data.Buffer;

  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 235  : }

  00014	c3		 ret	 0
?ToI64S@CSQLValue@@QAE_JXZ ENDP				; CSQLValue::ToI64S
_TEXT	ENDS
PUBLIC	?ToString@CSQLValue@@QAEHPADH@Z			; CSQLValue::ToString
EXTRN	_memcpy_s:PROC
; Function compile flags: /Ogtp
;	COMDAT ?ToString@CSQLValue@@QAEHPADH@Z
_TEXT	SEGMENT
_sOut$ = 8						; size = 4
_iMaxSz$ = 12						; size = 4
?ToString@CSQLValue@@QAEHPADH@Z PROC			; CSQLValue::ToString, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 96   : 	if(this->lpCValue->Data.IsNull)

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  0000c	74 0d		 je	 SHORT $LN1@ToString@2

; 97   : 	{
; 98   : 		sOut[0] = '\0';

  0000e	8b 45 08	 mov	 eax, DWORD PTR _sOut$[ebp]
  00011	c6 00 00	 mov	 BYTE PTR [eax], 0

; 99   : 		return 0;

  00014	33 c0		 xor	 eax, eax
  00016	5e		 pop	 esi

; 105  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN1@ToString@2:

; 100  : 	}
; 101  : 
; 102  : 	memcpy_s(sOut, iMaxSz, this->ToString(), this->lpCValue->Data.Size);

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	57		 push	 edi
  0001f	51		 push	 ecx
  00020	8b ce		 mov	 ecx, esi
  00022	e8 00 00 00 00	 call	 ?ToString@CSQLValue@@QAEPADXZ ; CSQLValue::ToString
  00027	8b 55 0c	 mov	 edx, DWORD PTR _iMaxSz$[ebp]
  0002a	8b 7d 08	 mov	 edi, DWORD PTR _sOut$[ebp]
  0002d	50		 push	 eax
  0002e	52		 push	 edx
  0002f	57		 push	 edi
  00030	e8 00 00 00 00	 call	 _memcpy_s

; 103  : 	sOut[this->lpCValue->Data.Size] = '\0';

  00035	8b 06		 mov	 eax, DWORD PTR [esi]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
  0003d	c6 04 0f 00	 mov	 BYTE PTR [edi+ecx], 0

; 104  : 	return this->lpCValue->Data.Size;

  00041	8b 16		 mov	 edx, DWORD PTR [esi]
  00043	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 105  : }

  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
?ToString@CSQLValue@@QAEHPADH@Z ENDP			; CSQLValue::ToString
_TEXT	ENDS
END
